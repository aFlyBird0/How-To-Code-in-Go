[{"id":0,"href":"/docs/01-How_To_Install_Go_and_Set_Up_a_Local-Programming_Environment_on_Ubuntu_18.04_DigitalOcean/","title":"01 How to Install Go and Set Up a Local Programming Environment on Ubuntu 18.04 Digital Ocean","section":"Docs","content":"如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境 #  Go 语言简介 #  Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两种语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 #  你需要一台安装了 Ubuntu 18.04 的电脑或者虚拟机，并且有对该计算机的管理员访问权限和网络连接。 您可以通过 Ubuntu 18.04 版本页面 下载此操作系统。\n第一步 — 安装 Go #  在这一步，你通过 Go 官方下载页面下载最新版本来安装 Go。\n为此，你需要找到最新二进制版本压缩包的 URL 。你还要注意旁边列出的 SHA256 哈希值，因为你将用它来验证下载的文件。\n你将通过命令行来完成安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。\n命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。尽管有很多终端命令需要学习，但是这些命令可以让你做更强大的事情。有关命令行的更多信息，请查看 Linux 终端简介 教程。\n在 Ubuntu 18.04 上，你可以通过点击屏幕左上角的 Ubuntu 图标并在搜索栏中输入terminal来找到终端程序。点击终端程序图标来打开终端。或者你可以在键盘上同时按住的“CTRL”、“ALT”和“T”键来自动打开终端程序。\n终端打开之后，你可以手动安装 Go 二进制。虽然可以通过包管理工具，比如 apt-get，但是通过手动安装可以帮助你理解一个有效的 Go 工作区系统里面任何必要的配置信息的修改。\n下载 Go 之前，确保你在 home (~) 目录：\ncd ~ 根据从官方 Go 下载页面复制的压缩包 URL，使用 curl 命令拉取下载：\ncurl -LO https://dl.google.com/go/go1.12.1.linux-amd64.tar.gz 接下来，使用 sha256sum 命令来校验压缩包：\nsha256sum go1.12.1.linux-amd64.tar.gz 运行上面命令显示的哈希值应该和下载页面的哈希值一致，如果不一致的话，那么这个压缩包就不是一个有效文件，需要重新下载。\nOutput 2a3fdabf665496a0db5f41ec6af7a9b15a49fbe71a85a50ca38b1f13a103aeec go1.12.1.linux-amd64.tar.gz 接下来，解压下载的文件并将其安装到系统所需位置。一般都是放在 /usr/local 目录下面：\nsudo tar -xvf go1.12.1.linux-amd64.tar.gz -C /usr/local 那么在 /usr/local 目录下面有一个 go 目录。\n注意：尽管 /usr/local/go 是官方推荐的位置，但有些用户可能更喜欢或需要不同的路径。\n在这一步中，你在 Ubuntu 18.04 机器上下载并安装了 Go 。接下来你将配置 Go 的工作区。\n第二步 — 创建你的 Go 工作区 #  安装完 Go 之后，你可以创建你的编码工作区。Go 语言的工作区在其根目录下包含两个目录：\n src: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。  src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src  └── github.com  └── digitalocean  └── godo  ├── .git # Git repository metadata  ├── account.go # package source  ├── account_test.go # test source  ├── ...  ├── timestamp.go  ├── timestamp_test.go  └── util  ├── droplet.go  └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令为你的 Go 工作区创建目录结构：\nmkdir -p $HOME/go/{bin,src} -p 选项是告诉 mkdir 在目录中创建所有的上级目录，尽管他们可能不存在。使用 {bin,src} 为 mkdir 创建一组参数，并告诉它创建 bin 目录和 src 目录。\n以上命令将确保下面的目录结构各就各位：\n└── $HOME  └── go  ├── bin  └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n你可以通过将全局变量添加到你的 ~/.profile 中来设置你的 $GOPATH。 你可能想根据你的 shell 配置将其添加到 .zshrc 或 .bashrc 文件中。\n首先，使用 nano 或你喜欢的文本编辑器打开 ~/.profile：\nnano ~/.profile 通过下面的命令设置你的 $GOPATH ：\n~/.profile export GOPATH=$HOME/go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中：\n~/.profile export PATH=$PATH:$GOPATH/bin 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n最后，你需要将 go 二进制文件添加到 PATH 中。 你可以通过在行尾添加 /usr/local/go/bin 来实现：\n~/.profile export PATH=$PATH:$GOPATH/bin:/usr/local/go/bin 将 /usr/local/go/bin 添加到 $PATH 中，可以使所有 Go 工具都可以在系统上的任何位置使用。\n为了更新你的 shell 配置，请使用下面的命令来加载全局变量:\n. ~/.profile 您可以通过使用 echo 命令并检查其输出，来验证你的 $PATH 是否已更新：\necho $PATH 你将看到你的 $GOPATH/bin 显示在你的主目录中。如果你以 root 身份登录，你将在路径中看到 /root/go/bin。\nOutput /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/root/go/bin:/usr/local/go/bin 你还会看到 /usr/local/go/bin 的 Go 工具的路径：\nOutput /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/root/go/bin:/usr/local/go/bin 通过检查 Go 的当前版本来验证安装：\ngo version 我们应该得到类似下面的输出：\nOutput go version go1.12.1 linux/amd64 现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo 这将下载 godo 库的内容并在你的计算机上创建 $GOPATH/src/github.com/digitalocean/godo 目录。 你可以通过列出目录来检查下看看是否成功下载了 godo包：\nll $GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; main Outputdrwxr-xr-x 4 root root 4096 Apr 5 00:43 ./ drwxr-xr-x 3 root root 4096 Apr 5 00:43 ../ drwxr-xr-x 8 root root 4096 Apr 5 00:43 .git/ -rwxr-xr-x 1 root root 8 Apr 5 00:43 .gitignore* -rw-r--r-- 1 root root 61 Apr 5 00:43 .travis.yml -rw-r--r-- 1 root root 2808 Apr 5 00:43 CHANGELOG.md -rw-r--r-- 1 root root 1851 Apr 5 00:43 CONTRIBUTING.md . . . -rw-r--r-- 1 root root 4893 Apr 5 00:43 vpcs.go -rw-r--r-- 1 root root 4091 Apr 5 00:43 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第三步 — 创建一个简单的程序 #  现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在新文件里写下你的程序：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n退出 nano 返回 shell 之后，运行程序：\ngo run hello.go hello.go 程序会使终端产生以下输出：\nOutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 #  恭喜！至此，你已经在 Ubuntu 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":1,"href":"/docs/02-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_macOS_DigitalOcean/","title":"02 How to Install Go and Set Up a Local Programming Environment on MAC Os Digital Ocean","section":"Docs","content":"如何在 macOS 上安装 Go 和设置本地编程环境 #  Go 语言简介 #  Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两门语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 #  你需要一台拥有管理员权限并且能够连接上网的 macOS 的电脑。\n第一步 — 打开终端 #  我们将会在终端上完成我们大部分的安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。\nmacOS 终端是一个可以访问命令行界面的应用程序。就像其他应用程序那样，你可以通过进入 Finder ，导航到 Applications 文件夹，最后进入 Utilities 文件夹找到它。然后就像打开其他应用程序一样双击终端将其打开。或者，你可以通过按住CMD 和 SPACE 键来启动 Spotlight，然后在出现的框中输入终端来查找它。\n尽管有很多终端命令需要学习，但是这些命令可以让你做更强大的事情。 文章Linux 终端简介 可以让你更好地了解 Linux 终端，它和 macOS 终端类似。\n现在你已经打开了终端，你可以下载并安装 Xcode，这是安装 Go 语言所需的开发者工具包。\n第二步 — 安装 Xcode #  Xcode 是一个集成开发环境(IDE)，由 macOS 软件开发工具组成。你可以在终端窗口中输入以下命令来检查 Xcode 是否已安装。\nxcode-select -p 下面的输出表明 Xcode 已经安装了：\nOutput /Library/Developer/CommandLineTools 如果收到错误信息，请在你的网络浏览器中安装来自 App Store 的Xcode 并接受默认选项。\n安装完 Xcode 后，返回终端窗口。接下来，你需要安装 Xcode 的单独命令行工具应用，可以通过输入以下命令：\nxcode-select --install 至此，Xcode 及其命令行工具应用已安装完毕，我们准备安装包管理器 Homebrew。\n第三步 — 安装和设置 Homebrew #  尽管 macOS 终端具有 Linux 终端和其他 Unix 系统的许多功能，但它没有提供包管理器的最佳实践。 包管理器是一组软件工具集，用于安装过程的自动化，包括初始软件的安装、升级和配置，以及根据需要删除软件。 他们将安装包保存在一个中心位置，并且可以以常用格式维护系统上的所有软件包。 Homebrew 为 macOS 提供了一个免费的开源软件包管理系统，简化了 macOS 上的软件安装。\n要安装 Homebrew ，请在终端窗口输入以下命令：\n/usr/bin/ruby -e \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026#34; Homebrew 是用 Ruby 开发的，因此它会修改你计算机的 Ruby 路径。curl 命令从指定的 URL 中提取脚本。该脚本解释了它将要做什么，然后会暂停下来提示你确认。这给了你大量反馈，关于该脚本对你的系统将要做什么并让你有机会验证该过程。\n如果你需要输入密码，请注意你的输入内容不会显示在终端窗口中，但会被记录下来。 输入密码后，只需按 返回 键即可。 否则，当系统提示你确认安装时，按字母 y 表示“是”。\n让我们来看看与 curl 命令相关的一些标志：\n The -f or --fail flag tells the Terminal window to give no HTML document output on server errors. -f 或者 --fail 标志告诉终端窗口在服务器错误时不提供 HTML 文档输出。 The -s or --silent flag mutes curl so that it does not show the progress meter, and combined with the -S or --show-error flag it will ensure that curl shows an error message if it fails. -s 或者 --silent 标志给curl静音使其不显示进度表，并且结合 -S 或者 --show-error 标志来确保 curl 在失败时显示错误消息。 The -L or --location flag will tell curl to redo the request to a new place if the server reports that the requested page has moved to a different location. -L 或者 --location 标志告诉 curl 如果服务器报告请求的页面已移动到不同的位置，请在新位置重试请求。  安装过程完成后，我们将把 Homebrew 目录放在 PATH 环境变量的顶部。 这将确保 Homebrew 安装命令将会被 macOS 自动选择的工具调用，这些工具可能与我们正在创建的开发环境背道而驰。\n你应该使用命令行文本编辑器 nano 使用 nano 命令创建或者打开 ~/.bash_profile 文件：\nnano ~/.bash_profile 在终端窗口中打开文件后，输入以下内容：\nexport PATH=/usr/local/bin:$PATH 要保存更改，请按住 CTRL 键和字母 o ，并在出现提示时按 RETURN 键。 现在你可以通过按住 CTRL 键和字母 x 来退出 nano。\n在终端中执行以下命令来激活这些更改：\nsource ~/.bash_profile 完成此操作后，你对 PATH 环境变量所做的更改将生效。\n可以通过输入以下命令来确保 Homebrew 已成功安装：\nbrew doctor 如果此时不需要更新，终端将输出以下内容：\nOutput Your system is ready to brew. 否则，你可能会收到提示你运行另一个命令（例如 brew update）的警告，以确保你的 Homebrew 的版本是最新的。\n一旦 Homebrew 准备好了，就开始安装 Go 了。\n第四步 — 安装 Go #  你可以通过 brew search 命令来使用 Homebrew 搜索所有可用的软件包。 出于本教程的目的，你将搜索与 Go 相关的包或模块：\nbrew search golang 注意：本教程不使用 brew search go，因为它返回的结果太多。 因为 go 是一个很小的词，并且会匹配很多包，所以使用 golang 作为搜索词变得很普遍。 这也是在互联网上搜索 Go 相关文章时的常见做法。 Golang 一词源于 Go 的域，即 golang.org。\n终端会输出一个你可以安装的列表：\nOutput golang golang-migrate Go 将是列表中的一项。继续安装它：\nbrew install golang 终端窗口将为你显示有关 Go 安装过程的反馈。 安装完成可能需要几分钟时间。\n要检查你安装 Go 的版本，输入以下命令：\ngo version 将会输出当前安装的 Go 语言的特定版本，默认情况下它是可用 Go 版本中的最新、最稳定的。\n以后要更新 Go，你可以运行以下命令先更新 Homebrew，然后再更新 Go。 现在不必这样做，因为你刚刚安装了最新版本：\nbrew update brew upgrade golang brew update 将更新 Homebrew 本身，确保你拥有要安装的软件包的最新信息。 brew upgrade golang 会将 golang 包更新到最新版本。\n保持 Go 一直是最新版本是一种很好的做法。\n在你的计算机上安装 Go 后，你现在可以为你的 Go 项目创建工作区。\n第五步 — 创建你的 Go 工作区 #  现在你已经安装了 Xcode、Homebrew 和 Go，可以接着创建你的编程工作区。\nGo 语言的工作区在其根目录下包含两个目录：\n src: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。  src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src  └── github.com  └── digitalocean  └── godo  ├── .git # Git reposistory metadata  ├── account.go # package source  ├── account_test.go # test source  ├── ...  ├── timestamp.go  ├── timestamp_test.go  └── util  ├── droplet.go  └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令为你的 Go 工作区创建目录结构：\nmkdir -p $HOME/go/{bin,src} -p 选项是告诉 mkdir 在目录中创建所有的上级目录，尽管他们可能不存在。使用 {bin,src} 为 mkdir 创建一组参数，并告诉它创建 bin 目录和 src 目录。\n以上命令将确保下面的目录结构各就各位：\n└── $HOME  └── go  ├── bin  └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n你可以通过将全局变量添加到你的 ~/.profile 中来设置你的 $GOPATH。 你可能想根据你的 shell 配置将其添加到 .zshrc 或 .bashrc 文件中。\n首先，使用 nano 或你喜欢的文本编辑器打开 ~/.profile：\nnano ~/.bash_profile 通过下面的命令设置你的 $GOPATH ：\n~/.bash\\_profile export GOPATH=$HOME/go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中：\n~/.bash\\_profile export PATH=$PATH:$GOPATH/bin 现在，你的 ~/.bash_profile 中应该有以下条目：\n~/.bash\\_profile export GOPATH=$HOME/go export PATH=$PATH:$GOPATH/bin 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n为了更新你的 shell 配置，请使用下面的命令来加载全局变量:\n. ~/.bash_profile 您可以通过使用 echo 命令并检查其输出，来验证你的 $PATH 是否已更新：\necho $PATH 你将看到你的 $GOPATH/bin 显示在你的主目录中。如果你以 sammy 身份登录，你将在路径中看到 /Users/sammy/go/bin。\nOutput /Users/sammy/go/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo We can see it successfully downloaded the godo package by listing the directory:\n你可以通过列出目录来检查下看看是否成功下载了 godo包：\nls -l $GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\nOutput -rw-r--r-- 1 sammy staff 2892 Apr 5 15:56 CHANGELOG.md -rw-r--r-- 1 sammy staff 1851 Apr 5 15:56 CONTRIBUTING.md . . . -rw-r--r-- 1 sammy staff 4893 Apr 5 15:56 vpcs.go -rw-r--r-- 1 sammy staff 4091 Apr 5 15:56 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第六步 — 创建一个简单的程序 #  现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。\n因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在终端中打开文本文件后，输入你的程序代码：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y就行。\n该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n退出 nano 返回 shell 后，运行程序：\ngo run hello.go hello.go 程序会使终端产生以下输出：\nOutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 #  恭喜！至此，你已经在 macOS 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":2,"href":"/docs/03-How_To_Install_Go_and_Set_Up_a_Local_Programming_Environment_on_Windows_10_DigitalOcean/","title":"03 How to Install Go and Set Up a Local Programming Environment on Windows 10 Digital Ocean","section":"Docs","content":"如何在 Windows 10 上安装 Go 和设置本地编程环境 #  Go 语言简介 #  Go 是一门在 Google 备受挫折后而诞生的语言。开发者不得不频繁地在两门语言中选择，要么选择一门执行效率高但是编译时间长的语言，要么选择一种易于编程但在生产中运行效率低下的语言。 Go 被设计为同时提供所有这三个功能：快速编译、易于编程和生产中的高效执行。\n虽然 Go 是一门通用的编程语言，可用于许多不同类型的编程项目。但它特别适合网络/分布式系统项目，赢得了“云语言”的美誉。Go 语言专注于通过一组强大的工具来帮助现代程序员完成更多的工作，通过使格式成为语言规范的一部分来消除对格式的争论，以及通过编译为单个二进制文件来简化部署。 Go 易于学习，关键字非常少，这使其成为不论是初学者还是经验丰富的开发人员的不二之选。\n本教程将指导你通过命令行来安装 Go 和配置 Go 编程环境。本教程特别针对 Ubuntu 18.04 的安装过程，但是对于其他 Debian Linux 发行版也同样适用。\n安装前提 #  你需要一台拥有管理员权限并且能够连接上网的 Windows 10 的电脑。\n第一步 — 打开并配置 PowerShell #  我们将会在终端上完成我们大部分的安装和设置，这是一种与计算机交互的非图形化方式。也就是说，你输入的是文本，然后也是通过文本得到计算机的反馈，而不是点击按钮。命令行，也就是我们熟知的 shell 或者 终端 ，可以帮助你修改或自动化很多你每天执行在计算机上的任务，这是软件开发人员必备的工具。\nPowerShell 是微软提供的一个命令行 shell 界面的程序。通过 cmdlets （发音为 command-lets ）来执行管理任务，它们是 .NET 软件框架可以执行操作的专用类。PowerShell 于 2016 年 8 月开源，现在可跨平台使用，适用于 Windows 和 UNIX 系统（包括 Mac 和 Linux）。\n如何找到 Windows PowerShell 呢，你可以右击屏幕左下角的开始按钮，弹出菜单后，点击搜索，然后在搜索栏中输入 PowerShell 。当你看到选项时，右击桌面应用程序中的 Windows PowerShell。 出于本教程的目的，选择以管理员身份运行。 当系统提示你出现一个对话框，询问是否允许此应用程序对您的 PC 进行更改？ 单击是。\n完成此操作后，你将看到一个基于文本的界面，其中包含如下所示的字符串：\n输入以下命令退出系统文件夹：\ncd ~ 然后你会进入到主目录中，比如 PS C:\\Users\\sammy\n要继续安装过程，你必须通过 PowerShell 设置权限。默认情况下以最安全的模式运行，作为管理员你可以设置以下几个级别的权限：\n Restricted 是默认执行策略。 在这种模式下，你将无法运行脚本，并且 PowerShell 只能作为交互式 shell 工作。 AllSigned 将使你能够运行由受信任的发布者签名的所有脚本和配置文件，这意味着可能让计算机面临着运行恶意脚本的风险，这脚本碰巧由受信任发布者签名。 RemoteSigned 将允许你运行由受信任的发布者签名的从 Internet 下载的脚本和配置文件，如果这些受信任的脚本实际上是恶意的，则再次使你的计算机暴露在漏洞面前。. Unrestricted 将运行从 Internet 下载的所有脚本和配置文件，只要你确认你知晓该文件是从 Internet 下载的。 在这种情况下，不需要数字签名，因此你可能会让你计算机面临运行从 Internet 下载的未签名和潜在恶意脚本的风险。  在本教程中，你将使用 RemoteSigned 执行策略来设置当前用户的权限。 这将允许 PowerShell 接受受信任的脚本，而不会使权限像 Unrestricted 权限那样广泛。 在 PowerShell 中输入以下内容：\nSet-ExecutionPolicy -Scope CurrentUser 然后 PowerShell 将提示你为你提供一个可执行策略。 输入以下内容来使用RemoteSigned 策略：\nRemoteSigned  一旦你按了回车键，系统会要求你确认对执行政策的更改。 输入字母 y 以使更改生效。 你可以通过询问机器上的当前权限来确认这是否生效：\nGet-ExecutionPolicy -List 你应该会收到如下所示的输出：\nOutput  Scope ExecutionPolicy  ----- --------------- MachinePolicy Undefined  UserPolicy Undefined  Process Undefined  CurrentUser RemoteSigned  LocalMachine Undefined 这表明当前用户可以运行从 Internet 下载的受信任脚本。 你现在可以继续下载设置 Go 编程环境所需的文件。\n第二步 — 安装包管理器 Chocolatey #  所谓包管理器就是一组软件工具的集合，这些工具使得安装过程自动化。这包括软件的初始安装、升级和配置，以及根据需要删除软件。 他们将软件安装保存在一个中央位置，并且可以以常用格式维护系统上的所有软件包。\nChocolatey 是一个为 Windows 构建的命令行包管理器，其工作方式与 Linux 上的 apt-get 类似。 Chocolatey 提供开源版本，可帮助你快速安装应用程序和工具。 你可以用它来下载开发环境所需的内容。\n在安装脚本之前，请阅读一下脚本并确认它对你的机器所做的更改是否令你感到满意。 为此，请使用 .NET 脚本框架下载 Chocolatey 脚本并将其显示在终端窗口中。\n首先创建一个名为 $script 的 WebClient 对象，该对象与 Internet Explorer 共享 Internet 连接设置：\n$script = New-Object Net.WebClient 通过将带有 | 的 $script 对象传递给 Get-Member 类来查看可用选项：\n$script | Get-Member 这将返回此 WebClient 对象的所有成员（属性和方法）：\n . . . [secondary_label Snippet of Output] DownloadFileAsync Method void DownloadFileAsync(uri address, string fileName), void DownloadFileAsync(ur... DownloadFileTaskAsync Method System.Threading.Tasks.Task DownloadFileTaskAsync(string address, string fileNa... DownloadString Method string DownloadString(string address), string DownloadString(uri address) #method we will use DownloadStringAsync Method void DownloadStringAsync(uri address), void DownloadStringAsync(uri address, Sy... DownloadStringTaskAsync Method System.Threading.Tasks.Task[string] DownloadStringTaskAsync(string address), Sy…  . . . 查看输出内容，你可以识别出用于在 PowerShell 窗口中显示脚本和签名的 DownloadString 方法。 使用此方法检查脚本：\n$script.DownloadString(\u0026#34;https://chocolatey.org/install.ps1\u0026#34;) 检查脚本后，通过在 PowerShell 中输入以下内容来安装 Chocolatey：\niwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex cmdlet iwr 或 Invoke-WebRequest 允许你从 Web 中提取数据。 然后将脚本传递给 iex 或 Invoke-Expression cmdlet，后者将执行脚本的内容并开始 Chocolatey 包管理器的安装。\n允许 PowerShell 安装 Chocolatey。 等到安装完成后，你可以使用 choco 命令开始安装其他工具。\n如果你以后需要随时升级 Chocolatey，请运行以下命令：\nchoco upgrade chocolatey 安装包管理器后，你可以安装 Go 编程环境所需的其余部分。\n第三步 — 安装文本编辑器 Nano (可选) #  在这一步中，你将安装 nano，这是一个使用命令行界面的文本编辑器。 你可以使用 nano 直接在 PowerShell 中编写程序。 这不是强制性步骤，因为你也可以使用带有图形用户界面的文本编辑器，例如 Notepad 。 本教程推荐使用 nano，因为它将帮助你习惯使用 PowerShell。\n使用 Chocolatey 安装 nano：\nchoco install -y nano -y 标志会自动确认你要运行脚本，而不会提示你确认。\n安装 nano 后，你可以使用 nano 命令创建新的文本文件。 你将在本教程后面使用它来编写你的第一个 Go 程序。\n第四步 — 安装 Go #  就像你在上一步中安装 nano 一样，你将使用 Chocolatey 安装 Go：\nchoco install -y golang 注意： 因为 go 是一个很小的词，所以使用 golang 作为安装包的术语， 这也是在互联网上搜索 Go 相关文章时的常见做法。 Golang 一词源于 Go 的域，即 golang.org\nPowerShell 安装 Go 的过程中，会在 PowerShell 中生成输出内容。 安装完成后，你应该会看到以下输出：\nOutput Environment Vars (like PATH) have changed. Close/reopen your shell to see the changes (or in powershell/cmd.exe just type `refreshenv`). The install of golang was successful.  Software installed as \u0026#39;msi\u0026#39;, install location is likely default.  Chocolatey installed 1/1 packages. See the log for details (C:\\ProgramData\\chocolatey\\logs\\chocolatey.log). 安装完成后，你可以确认下 Go 是否已安装。 要查看更改，请以管理员身份关闭并重新打开 PowerShell，然后检查本地计算机上可用的 Go 版本：\ngo version 你将得到类似以下内容的输出：\nOutput go version go1.12.1 windows/amd643.7.0 安装 Go 后，你可以为开发项目设置工作区。\n第五步 — 创建你的 Go 工作区 #  现在你已经安装了 Chocolatey、nano 和 Go，可以接着创建你的编程工作区。\nGo 语言的工作区在其根目录下包含两个目录：\n src: 该目录包含 Go 的源文件。所谓源文件就是你用 Go 编程语言写的文件。源文件被 Go 编译器构建成可执行的二进制文件。 bin: 该目录包含了 Go 工具构建和安装的可执行文件。可执行文件就是运行在你系统上并执行任务的二进制文件。通常是你的源码或者是其他下载的 Go 源代码编译的程序。  src 子目录可能包含多个版本控制仓库（例如 Git, Mercurial 和 Bazaar）。当你引入第三方库的时候，你可以看到类似 github.com, golang.org 或其他目录，如果你使用的是 github.com 之类的代码仓库，你还将把项目和源文件放在该目录下。 我们将在此步骤的后面部分探讨这个概念。这允许你在你的项目中规范导入代码。 规范导入就是引用完全限定包的导入，例如 github.com/digitalocean/godo 。\n下面是典型的工作区目录结构：\n. ├── bin │ ├── buffalo # command executable │ ├── dlv # command executable │ └── packr # command executable └── src  └── github.com  └── digitalocean  └── godo  ├── .git # Git repository metadata  ├── account.go # package source  ├── account_test.go # test source  ├── ...  ├── timestamp.go  ├── timestamp_test.go  └── util  ├── droplet.go  └── droplet_test.go 从 1.8 开始，Go 工作区的默认目录是用户的 home 目录，并带有 go 子目录，或者是 $HOME/go 目录。 如果你使用的是早于 1.8 的 Go 版本，目前认为最佳做法是为你的工作区使用 $HOME/go 位置。\n使用下面命令导航到 $HOME 目录：\ncd $HOME 接下来，为你的 Go 工作区创建目录结构：\nmkdir go/bin, go/src 以上命令将确保下面的目录结构各就各位：\n└── $HOME └── go ├── bin └── src 在 Go 1.8 之前，需要设置一个名为 $GOPATH 的本地环境变量。 $GOPATH 告诉编译器在哪里可以找到导入的第三方源代码，同样包括任何你写的本地源代码。 虽然不再明确要求它，但它仍然被认为是一种很好的做法，因为许多第三方工具仍然依赖于设置的这个变量。\n由于你使用 Chocolatey 进行安装，因此应该已经设置了此环境变量。 你可以使用以下命令验证这一点：\n$env:GOPATH 你应该会看到以下输出，其中 sammy 代替了你的用户名：\nOutput C:\\Users\\sammy\\go 当 Go 编译和安装工具时，会将他们放在 $GOPATH/bin 目录。为方便起见，通常将工作区的 /bin 子目录添加到 ~/.profile 中的 PATH 中。你可以使用 PowerShell 中的 setx 命令执行此操作：\nsetx PATH \u0026#34;$($env:path);$GOPATH\\bin\u0026#34; 这将允许你在系统上的任何位置运行通过 Go 工具编译或下载的任何程序。\n现在你已经创建了工作区的根目录并设置了 $GOPATH 环境变量，你可以根据以下目录结构创建你未来的项目。 此示例假设你使用 github.com 作为仓库：\n$GOPATH/src/github.com/username/project 例如，如果你正在开发 https://github.com/digitalocean/godo 项目，它将存储在以下目录中：\n$GOPATH/src/github.com/digitalocean/godo 该项目结构使项目可以通过 go get 工具使用。它也有助于以后的可读性。 你可以通过使用 go get 命令并获取 godo 库来验证这一点：\ngo get github.com/digitalocean/godo 注意： 如果你没有安装 git，Windows 会打开一个对话框询问你是否要安装它。 单击 Yes 继续并按照安装说明进行操作。\n你可以通过列出目录来检查下看看是否成功下载了 godo包：\nls $env:GOPATH/src/github.com/digitalocean/godo 你应该看到类似下面这样的输出：\nOutput Directory: C:\\Users\\sammy\\go\\src\\github.com\\digitalocean\\godo Mode LastWriteTime Length Name ---- ------------- ------ ---- d----- 4/10/2019 2:59 PM util -a---- 4/10/2019 2:59 PM 9 .gitignore -a---- 4/10/2019 2:59 PM 69 .travis.yml -a---- 4/10/2019 2:59 PM 1592 account.go -a---- 4/10/2019 2:59 PM 1679 account_test.go -rw-r--r-- 1 sammy staff 2892 Apr 5 15:56 CHANGELOG.md -rw-r--r-- 1 sammy staff 1851 Apr 5 15:56 CONTRIBUTING.md . . . -a---- 4/10/2019 2:59 PM 5076 vpcs.go -a---- 4/10/2019 2:59 PM 4309 vpcs_test.go 在这一步中，你创建了一个 Go 工作区并且配置了必要的环境变量。下一步你将使用一些代码来测试下工作区。\n第六步 — 创建一个简单的程序 #  现在你已经设置了工作区，来创建一个 “Hello, World!” 程序吧。这可以检验工作区配置是否正确，并且给你一个更加熟悉 Go 的机会。因为我们创建的是单个 Go 源文件，而不是实际项目，所以我们不需要在工作区中执行此操作。\n在你的 home 目录，打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在 nano 中打开文本文件后，输入你的程序代码：\nhello.go package main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n该代码使用了 fmt 包并且使用 Hello, World! 作为参数调用了 Println 函数。这将导致短语 Hello, World! 在程序运行时打印到终端上。\n退出 nano 返回 shell 之后，运行程序：\ngo run hello.go 你刚刚创建的 hello.go 程序应该会在 PowerShell 产生以下输出：\nOutput Hello, World! 在此步骤中，你使用了一个简单小程序来验证是否正确配置了 Go 工作区。\n总结 #  恭喜！至此，你已经在 Ubuntu 机器上设置了 Go 编程工作区，可以开始写项目了！\n"},{"id":3,"href":"/docs/04-How_To_Write_Your_First_Program_in_Go_DigitalOcean/","title":"04 How to Write Your First Program in Go Digital Ocean","section":"Docs","content":"如何用 Go 编写你的第一个程序 #  前言 #  “Hello, World!” 程序是计算机编程中的经典且历史悠久的传统。 对于初学者来说，这是一个简单而完整的第一个程序，它是一个确保你的环境配置正确的好方法。\n本教程将引导你在 Go 中创建此程序。 但是，为了使程序更有趣，你将修改传统的 “Hello, World!” 程序，以便它可以询问用户的姓名。 然后，你将在回复中使用该姓名。 完成本教程后，你将拥有一个运行起来如下所示的程序：\nOutput Please enter your name. Sammy Hello, Sammy! I\u0026#39;m Go! 安装前提 #  在开始本教程之前，你需要一个本地的 Go 开发环境。你可以按照下面其中一个教程在你的计算机上进行设置：\n 如何在 macOS 上安装 Go 和设置本地编程环境 如何在 Ubuntu 18.04 上安装 Go 和设置本地编程环境 如何在 Windows 10 上安装 Go 和设置本地编程环境  第一步 — 编写最基本的 “Hello, World!” 程序 #  为了编写 Hello, World!” 程序，请打开一个命令行文本编辑器，例如 nano，然后创建一个新文件：\nnano hello.go 在 nano 中打开文本文件后，输入你的程序代码：\nhello.go package main  import \u0026#34;fmt\u0026#34;  func main() {  fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 让我们分解下代码的各个部分。\npackage 是一个 Go 关键字，它定义了这个文件属于哪个代码包。 每个文件夹只能有一个包，并且文件夹中每个 .go 文件必须在其文件顶部声明相同的包名。 在这个例子中，代码属于 main 包。\nimport 是一个 Go 关键字，它告诉 Go 编译器你想在这个文件中使用哪些其他包。 在这里，你导入标准库附带的 fmt 包。 fmt 包提供了在开发时很有用的格式化和打印功能。\nfmt.Println 是一个 Go 函数，位于 fmt 包中，它告诉计算机将一些文本打印到屏幕上。\n在 fmt.Println 函数后面跟着一系列字符，例如 \u0026quot;Hello, World!\u0026quot;，用引号括起来。 引号内的任何字符都称为 string。 fmt.Println 函数会在程序运行时将此字符串打印到屏幕上。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y，然后按 ENTER 退出。\n现在你可以试试你的程序了。\n第二步 — 运行 Go 程序 #  你的 “Hello, World!” 程序写好之后，你就可以运行程序了。你可以用 go 命令然后后面跟着你刚刚创建的文件名。\ngo run hello.go 程序执行后会显示以下输出：\nOutput Hello, World! 让我们来探索下实际发生了什么。\nGo 程序在运行之前必须要先编译。当你使用文件名调用 go run 时，在本例中为 hello.go，go 命令将 编译 应用程序，然后运行生成的二进制文件。 对于用 编译型 编程语言编写的程序，编译器将获取程序的源代码并生成另一种类型的低级代码（例如机器代码）来生成可执行程序。\nGo 应用程序需要一个 main 包和一个确切的 唯一 main() 函数，作为应用程序的入口点。 main 函数不接受任何参数并且不返回任何值。 相反，它告诉 Go 编译器应该将包编译为可执行包。\n编译后，代码通过在 main 包中输入 main() 函数来执行。 它通过_调用_ fmt.Println 函数来执行fmt.Println(\u0026quot;Hello, World!\u0026quot;) 行。 Hello, World! 的字符串值被传递给函数。 在此示例中，字符串 Hello, World! 也称为 参数，因为它是传递给方法的值。\nHello, World! 两边的引号不会打印到屏幕上，因为你用它们告诉 Go 你的字符串在哪里开始和结束。\n在这一步中，你已经用 Go 编程创建了一个有效的“Hello, World！” 。 在下一步中，你将探索如何使程序更具交互性。\n第三步 — 提示用户输入 #  每次运行程序时，它都会产生相同的输出。 在此步骤中，你可以把提示用户输入他们的姓名添加到程序中。 然后，你将在输出中使用他们的名字。\n不要修改现有程序，而是使用 nano 编辑器创建一个名为 greeting.go 的新程序：\nnano greeting.go 首先，添加这段代码，提示用户输入他们的姓名：\ngreeting.go package main  import ( \t\u0026#34;fmt\u0026#34; )  func main() {  fmt.Println(\u0026#34;Please enter your name.\u0026#34;) } 再一次，你使用 fmt.Println 函数将一些文本打印到屏幕上。\n现在添加下面高亮行代码来存储用户的输入：\ngreeting.go package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string } var name string 行将使用 var 关键字 创建一个新变量。 你将变量命名为 “name” ，它的类型为 “string” 。\n然后添加下面高亮行代码来捕捉用户的输入：\ngreeting.go package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string fmt.Scanln(\u0026amp;name) } fmt.Scanln 方法告诉计算机等待以换行符或 (\\n) 字符结尾的键盘输入。 该方法会暂停程序，允许用户输入他们想要的任何文本。 当用户按下键盘上的 ENTER 键时，程序将继续。 然后捕获所有点击，包括 ENTER ，然后将其转换为字符串。\n你想在程序中使用这些字符输出，因此你通过将这些字符 写入 到被称为 name 的字符串 变量 中来保存这些字符。 Go 将该字符串存储在计算机的内存中，直到程序完成运行。\n最后，在程序中添加以下高亮行来打印输出：\ngreeting.go package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Please enter your name.\u0026#34;) var name string fmt.Scanln(\u0026amp;name) fmt.Printf(\u0026#34;Hi, %s! I\u0026#39;m Go!\u0026#34;, name) } 这一次，你使用的是 fmt.Printf，而不是再次使用 fmt.Println 方法。 fmt.Printf 函数接受一个字符串，并使用特殊的打印 占位符, (%s)，将 name 的值注入到字符串中。 你这样做是因为 Go 不支持 字符串插值 ，它可以让你获取分配给变量的值并将其插入在字符串中。\n按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y。\n现在运行程序。 系统将提示你输入你的姓名，因此请输入并按 ENTER。 输出可能不完全符合你的预期：\nOutput Please enter your name. Sammy Hi, Sammy ! I\u0026#39;m Go! 而不是 Hi, Sammy! I'm Go!，名字后面有一个换行符。\n该程序捕获了我们 所有 的点击，包括我们按下以告诉程序继续的 ENTER 键。 在字符串中，按 ENTER 键会创建一个特殊字符，该字符会创建一个新行。 该程序的输出完全按照你的要求执行； 它正在显示你输入的文本，包括新行。 这不是你期望的输出，但你可以使用其他功能对其进行修复。\n在你的编辑器里面打开 greeting.go\nnano greeting.go 在你的程序里定位到下面这一行：\ngreeting.go ... fmt.Scanln(\u0026amp;name) ... 在其后面增加下面一行：\ngreeting.go name = strings.TrimSpace(name) 上面使用了 Go 标准库 strings 包中的 TrimSpace 函数，来处理你使用 fmt.Scanln 捕获的字符串。 strings.TrimSpace 函数从字符串的开头和结尾删除任何空格字符，包括换行符。 在这种情况下，它会删除你按下 ENTER 时创建的字符串末尾的换行符。\n要使用 strings 包，你需要在程序顶部导入它。\n在你的程序找到下面这几行代码：\ngreeting.go import ( \u0026#34;fmt\u0026#34; ) 增加下面几行来导入 strings 包：\ngreeting.go import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) 你的程序现在包含了以下代码：\ngreeting.go package main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func main() { \tfmt.Println(\u0026#34;Please enter your name.\u0026#34;) \tvar name string \tfmt.Scanln(\u0026amp;name) \tname = strings.TrimSpace(name) \tfmt.Printf(\u0026#34;Hi, %s! I\u0026#39;m Go!\u0026#34;, name) } 按 CTRL 和 X 键退出 nano。 当提示保存文件时，按 Y。\n再次运行程序：\ngo run greeting.go 这一次，在你输入你的名字并按 ENTER 后，你会得到预期的输出：\nOutput Please enter your name. Sammy Hi, Sammy! I\u0026#39;m Go! 你现在有一个 Go 程序，它接受用户的输入并将其打印回屏幕。\n总结 #  在本教程中，你编写了 一个 “Hello, World！” 程序，可以从用户那里获取输入、处理结果并显示输出。 既然你有一个基本程序可以使用，请尝试进一步扩展你的程序。 例如，询问用户最喜欢的颜色，让程序说它最喜欢的颜色是红色。 你甚至可以尝试使用相同的技术来创建一个简单的 Mad-Lib 程序。\n"},{"id":4,"href":"/docs/05-Understanding_the_GOPATH/","title":"05 Understanding the Gopath","section":"Docs","content":"理解 GOPATH #  介绍 #  本文将带领你了解什么是 GOPATH，它是如何工作的，以及如何设置它。这是设置 Go 开发环境以及理解 Go 如何查找、安装和构建源文件的关键步骤。在本文中，我们将使用 GOPATH 来指代我们将要讨论的文件夹结构的概念。我们将使用 $GOPATH 来指代 Go 用来查找文件夹结构的环境变量。\nGo 工作区 是 Go 管理源码文件、编译的二进制文件和用于后续更快编译的缓存对象。虽然可能有多个空间，但只有一个 Go 工作区是典型的，也是被建议的使用方式。GOPATH 充当工作区的根文件夹。\n设置 $GOPATH 环境变量 #  $GOPATH 环境变量列出了 Go 用来寻找 Go 工作区的地方。\n默认情况下，Go 假设 GOPATH 位于 $HOME/go，其中 $HOME 是电脑上上我们帐户的根目录。我们可以通过设置 $GOPATH 环境变量来修改它。为了进一步的研究，请参考在 Linux 中阅读和设置环境变量的教程。\n想要了解更多关于设置 $GOPATH 变量的信息，可以参考 Go 文档。\n此外，本系列教程 简单介绍了安装 Go 和设置 Go 开发环境的方法。\n$GOPATH 不是 $GOROOT #  $GOROOT 是 Go 的代码、编译器和工具所在的地方ーー这不是我们的源代码。$GOROOT 通常类似于 /usr/local/go。我们的 $GOPATH 通常类似于 $HOME/go。\n虽然我们不再需要专门设置 $GOROOT 变量，但它仍然在旧材料中被引用。\n现在，让我们讨论一下 Go Workspace 的结构。\nGo 工作区剖析 #  在一个 Go Workspace 或者 GOPATH 中，有三个目录: bin、 pkg 和 src。这些目录中的每一个对于 Go 工具链都有特殊的意义。\n. ├── bin ├── pkg └── src └── github.com/foo/bar └── bar.go 让我们来看看每个目录。\n$GOPATH/bin 目录是 Go 放置 go install 编译的二进制文件的地方。我们的操作系统使用 $PATH 环境变量在没有完整路径的情况下找到二进制应用程序并执行。建议将此目录添加到全局 $PATH 变量中。\n例如，如果我们不在 $PATH 中添加 $GOPATH/bin 来执行一个程序，我们需要运行:\n$ $GOPATH/bin/myapp 当 $GOPATH/bin 被添加到 $PATH 时，我们可以像这样进行同样的调用:\n$ myapp $GOPATH/pkg 目录是 Go 存储预编译目标文件的地方，以加速程序的后续编译。通常，大多数开发人员不需要访问这个目录。如果遇到编译问题，可以安全地删除该目录，然后 Go 将重新生成该目录。\n在 src 目录是我们放置所有的 .go 文件，或源代码的地方。这不应与 Go 工具使用的源代码混淆，后者位于 $GOROOT 中。在编写 Go 应用程序、包和库时，我们将把这些文件放在 $GOPATH/src/path/to/code 下。\n包是什么？ #  Go 代码是以包的形式组织的。包表示磁盘上单个目录中的所有文件。一个目录只能包含来自同一包的某些文件。包与所有用户编写的 Go 源文件一起存储在 $GOPATH/src 目录下。我们可以通过导入不同的软件包来理解软件包解析。\n如果我们的代码是 $GOPATH/src/blue/red，那么它的包名应该是 red。\nimport \u0026#34;blue/red\u0026#34; red 包的导入声明如下:\n存储在源代码仓库中的软件包，如 GitHub 和 BitBucket，将仓库的完整位置作为导入路径的一部分。\n例如，我们可以使用下面的导入路径来导入 https://github.com/gobuffalo/buffalo 的源代码:\nimport \u0026#34;github.com/gobuffalo/buffalo\u0026#34; 因此，这个源代码应该位于磁盘上的下列位置:\n$GOPATH/src/github.com/gobuffalo/buffalo 结论 #  在这篇文章中，我们讨论了 GOPATH 作为一个文件夹的集合，Go 期望我们的源代码保存在里面，以及这些文件夹是什么，它们包含什么。我们讨论了如何通过设置 $GOPATH 环境变量，将默认的 $HOME/go 位置改为用户选择的位置。最后，我们讨论了 Go 如何在该文件夹结构中搜索包。\n在 Go 1.11中引入的 Go Modules旨在取代 Go Workspaces 和 GOPATH。虽然建议开始使用模块，但是有些环境(如公司环境)，可能还没有准备好使用模块。\nGOPATH 是 Go 设置中比较棘手的一个方面，但是一旦设置好了，我们通常会忘记它。\n"},{"id":5,"href":"/docs/06-How_To_Write_Comments_in_Go/","title":"06 How to Write Comments in Go","section":"Docs","content":"如何在 Go 中写注释 #  介绍 #  注释是存在于计算机程序中，被编译器和解释器忽略的代码行。在程序中包含注释使得代码对于人类来说更具可读性，因为它提供了一些关于程序的每个部分正在做什么的信息或解释。\n根据你程序的目的，注释可以作为你自己的笔记或者提醒，或者它们可以是为了其他程序员能够理解你的代码在做什么而写的。\n一般来说，在写或者更新程序的时候写评论是个不错的主意，因为以后很容易忘记你的思维过程，而且以后写的评论长期来看可能没那么有用。\n注释语法 #  Go 中的注释以一组向前斜杠（//）开始，一直到行尾。在前向斜杠集合之后有一个空白符号是惯用的方式。\n一般来说，评论看起来是这样的:\n// This is a comment 注释不会执行，因此在运行程序时没有注释的指示。注释在源代码中供人阅读，而不是供计算机执行。\n在一个 “Hello, World!” 的程序中，注释可能如下所示：\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \t// Print “Hello, World!” to console \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 在一个迭代切片的 for 循环时，注释可能如下所示：\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \t// Define sharks variable as a slice of strings \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \t// For loop that iterates over sharks list and prints each string item \tfor _, shark := range sharks { \tfmt.Println(shark) \t} } 注释应该与注释代码的缩进相同。也就是说，一个没有缩进的函数定义将有一个没有缩进的注释，并且下面的每个缩进级别中，注释与所注释的代码对齐。\n比如，下面是 main 函数如何注释，以及各个缩进级别的代码和注释：\n package main  import \u0026#34;fmt\u0026#34;  const favColor string = \u0026#34;blue\u0026#34;  func main() { \tvar guess string \t// Create an input loop \tfor { \t// Ask the user to guess my favorite color \tfmt.Println(\u0026#34;Guess my favorite color:\u0026#34;) \t// Try to read a line of input from the user. Print out the error 0 \tif _, err := fmt.Scanln(\u0026amp;guess); err != nil { \tfmt.Printf(\u0026#34;%s\\n\u0026#34;, err) \treturn \t} \t// Did they guess the correct color? \tif favColor == guess { \t// They guessed it! \tfmt.Printf(\u0026#34;%q is my favorite color!\\n\u0026#34;, favColor) \treturn \t} \t// Wrong! Have them guess again. \tfmt.Printf(\u0026#34;Sorry, %q is not my favorite color. Guess again.\\n\u0026#34;, guess) \t} } 编写注释是为了帮助程序员，无论是最初的程序员还是在项目中使用或合作的其他人。如果注释不能与代码库一起适当地维护和更新，那么对于编写与代码相矛盾或将与将来的代码相矛盾的注释，不如不包含注释。\n在给代码注释时，你应该回答代码背后的 原因，而不是 什么 或 怎么 回事。除非代码特别复杂，否则查看代码通常可以回答是 什么 或者 怎么 的问题，这就是为什么注释通常是围绕 为什么 的原因。\n注释块 #  注释块可以用来解释更复杂的代码或那些读者可能并不熟悉的代码。\n你可以用两种方式在 Go 中创建注释块。第一种方法是使用一组双向前斜杠，并在每行中重复它们。\n// First line of a block comment // Second line of a block comment 第二种是使用开始标记（/*）和结束标记（*/）。为了记录代码，惯例方式是使用 // 语法。你只能使用 /* ... */ 语法进行调试，我们将在本文后面讨论这个问题。\n/* Everything here will be considered a block comment */ 在这个例子中，注释块定义了 MustGet() 函数中发生的事情：\n// MustGet will retrieve a url and return the body of the page. // If Get encounters any errors, it will panic. func MustGet(url string) string { \tresp, err := http.Get(url) \tif err != nil { \tpanic(err) \t}  \t// don\u0026#39;t forget to close the body \tdefer resp.Body.Close() \tvar body []byte \tif body, err = ioutil.ReadAll(resp.Body); err != nil { \tpanic(err) \t} \treturn string(body) } 在 Go 中导出函数的开头经常会看到注释块; 这些注释也是生成代码文档的元素。当操作不那么直观，而需要完全解释时，也会使用注释块。除了记录函数之外，你应该尽量避免对代码进行过度注释，并相信其他程序员能够理解 Go，除非你是为特定的用户编写代码。\n内联注释 #  内联注释出现在语句的同一行，位于代码本身之后。像其他注释一样，它们以一组向前斜杠开始。同样，不需要在前向斜杠后面加空格，但是惯例是这样做的。\n一般来说，内联注释是这样的:\n[code] // Inline comment about the code 内联注释应该谨慎使用，但是对于解释代码中棘手或不明显的部分来说可能是有效的。如果你认为自己将来可能不记得正在编写的代码中的某一行，或者你正在与一个你认识的人合作，而这个人可能并不熟悉代码的所有方面，那么它们也会很有用。\n例如，如果你在你的 Go 程序中没有使用大量的数学，你或者你的合作者可能不知道下面的代码创建了一个复杂的数字，所以你可能需要包含一个关于这个的内联注释:\nz := x % 2 // Get the modulus of x 你也可以使用行内注释来解释做某事背后的原因，或者提供一些额外的信息，比如:\nx := 8 // Initialize x with an arbitrary number 你应该只在必要的时候，并且当它们可以为阅读程序的人提供有用的指导时，使用内联注释。\n注释测试代码 #  除了使用注释作为记录代码的方式之外，还可以使用开始标记（/*）和结束标记（*/）来创建块注释。这允许你在测试或调试当前正在创建的程序时注释掉不想执行的代码。也就是说，当你在实现新代码后遇到错误时，你可能希望对其中的一些代码行进行注释，以查看是否能够解决这个确切的问题。\nUsing the /* and */ tags can also allow you to try alternatives while you’re determining how to set up your code. You can also use block comments to comment out code that is failing while you continue to work on other parts of your code. 在决定如何设置代码时，使用 /* 和 */ 标记还可以让你尝试其他选择。你也可以使用注释块来注释失败的代码，同时继续处理代码的其他部分。\n// Function to add two numbers func addTwoNumbers(x, y int) int { \tsum := x + y \treturn sum }  // Function to multiply two numbers func multiplyTwoNumbers(x, y int) int { \tproduct := x * y \treturn product }  func main() { \t/* In this example, we\u0026#39;re commenting out the addTwoNumbers function because it is failing, therefore preventing it from executing. Only the multiplyTwoNumbers function will run a := addTwoNumbers(3, 5) fmt.Println(a) */  \tm := multiplyTwoNumbers(5, 9) \tfmt.Println(m) } 注意: 注释掉代码只能用于测试目的。不要在最终的程序中保留注释掉的代码片段。\n使用 /* 和 */ 标记注释代码可以让你尝试不同的编程方法，并通过系统地注释和运行程序的各个部分来帮助你找到错误的源代码。\n结论 #  在你的 Go 程序中使用注释有助于使你的程序对于人类来说更具可读性，包括未来的你自己。添加适当相关和有用的注释可以使其他人更容易地与你合作编程项目，并使代码的价值更加明显。\n在 Go 中正确注释代码还可以让你用到 Godoc 工具。Godoc 是一个从代码中提取注释并为 Go 程序生成文档的工具。\n"},{"id":6,"href":"/docs/07-Understanding_Data_Types_in_Go/","title":"07 Understanding Data Types in Go","section":"Docs","content":"理解 Go 的数据类型 #  介绍 #  数据类型是指在编写程序时特定变量存储的值的类型。数据类型还决定对数据可以执行哪些操作。\n在本文中，我们将介绍 Go 本身的重要数据类型。本文并不是对数据类型的详尽调查，但将帮助你熟悉 Go 中可用的选项。理解一些基本数据类型将可以让你能够编写更清晰的代码，从而更有效地执行。\n背景 #  了解数据类型的一种方法是考虑我们在现实世界中使用的不同类型的数据。现实世界中数据的一个例子是数字: 例如，我们可以使用无符号整数（0，1，2，\u0026hellip;）、有符号整数（\u0026hellip; ，-1，0，1，\u0026hellip;）和无理数（π）。\n通常，在数学中，我们可以把不同类型的数字组合起来，来得到某个答案。例如，我们可以把 5 加到 π 上:\n5 + π 我们可以把这个方程式作为答案因为存在无理数，也可以把 π 近似舍入到十进制的缩写数字，再把这些数字相加:\n5 + π = 5 + 3.14 = 8.14 但是，如果我们开始尝试用另一种数据类型，比如单词来计算数字，就变得不那么有意义了。我们如何解下面的公式呢？\nshark + 8 对于计算机来说，每种数据类型区别很大，就像文字和数字一样。因此，对于不同的数据类型的赋值和修改操作，我们必须谨慎。\n整数 #  和数学一样，计算机编程中的 整数 可以是正数、负数或者 0（\u0026hellip; -1,0,1，\u0026hellip;）。在 Go 中，整数被称为 int。与其他编程语言一样，不应该在四位数或更多的数字中使用逗号，所以在程序中写入 1,000 时，请写为 1000。\n我们可以简单向下面这种方式打印一个整数：\nfmt.Println(-459) Output -459 或者，我们可以声明一个变量，在这个例子中是我们用来表示和操作数字的符号，如：\nvar absoluteZero int = -459 fmt.Println(absoluteZero) Output -459 我们也可以在 Go 中对整数进行计算。在下面的代码块中，我们将使用 := 分配符来声明和实例化变量 sum：\nsum := 116 - 68 fmt.Println(sum) Output 48 如输出所示，数学算子 - 从 116 中减去整数 68，得到 48。你将在声明变量的数据类型部分了解有关变量声明的更多信息。\n在 Go 程序中，有多种方式可以使用整数。随着你继续学习 Go，你将有很多机会使用整数并在此数据类型的知识基础上进行构建。\n浮点数 #  浮点数 或 float 用于表示不能表示为整数的实数。实数包括所有的有理数和无理数，因此，浮点数可以包含小数部分，比如 9.0 或 -116.42。Go 程序中的浮点数，可以认为是一个包含小数点的数字。\n就像我们处理整数一样，我们可以用这样一种简单的方式打印出一个浮点数:\nfmt.Println(-459.67) Output -459.67 我们也可以声明一个变量表示浮点数，如：\nabsoluteZero := -459.67 fmt.Println(absoluteZero) Output -459.67 和整数类似，我们也可以在 Go 中计算浮点数：\nvar sum = 564.0 + 365.24 fmt.Println(sum) Output 929.24 对于整数和浮点数，记住 3 ≠ 3.0 很重要，因为 3 表示的是一个整数，而 3.0 表示的是一个浮点数。\n数字类型的大小 #  除了整数和浮点数之间的区别之外，Go 还有两种类型的数值数据，这两种数值数据通过其大小的静态或动态特性进行区分。第一种类型是与_体系结构无关_的类型，这意味着无论代码运行在哪台机器上，以位为单位的数据的大小都不会改变。\n今天的大多数系统架构都是32位或64位的。例如，你可能正在一台现代的 Windows 笔记本电脑上开发，其操作系统运行在 Windows 64位架构上。然而，如果你正在为一个像健身手表这样的设备开发应用时，你可能正在使用一个32位的架构。如果你使用像 int32 这样独立于体系架构的类型，那么无论你为何种体系架构编译，该类型都将具有一个固定的大小。\n第二种是_实现专用_的类型。在这种类型中，位大小可以根据程序所在的体系架构的不同而变化。例如，如果我们使用 int 类型，当 Go 为 32 位架构编译时，数据类型的大小将为 32 位。如果程序是为 64 位架构编译的，那么变量的大小是 64 位。\n除了数据类型大小不同外，类似整数的类型还有两种基本类型: 有符号_和_无符号。int8 是一个有符号整数，可以取 -128 到 127 之间的值。uint8 是一个无符号整数，只能取 0 到 255 之间的正数值。\n取值范围与位的大小有关。对于二进制数据，8 位可以表示总共 256 个不同的值。因为 int 类型需要同时支持正值和负值，所以 8 位整数（int8）的范围是 -128 到 127，总共有 256 个不同的值。\nGo 具有以下与架构无关的整数类型:\nuint8 unsigned 8-bit integers (0 to 255) uint16 unsigned 16-bit integers (0 to 65535) uint32 unsigned 32-bit integers (0 to 4294967295) uint64 unsigned 64-bit integers (0 to 18446744073709551615) int8 signed 8-bit integers (-128 to 127) int16 signed 16-bit integers (-32768 to 32767) int32 signed 32-bit integers (-2147483648 to 2147483647) int64 signed 64-bit integers (-9223372036854775808 to 9223372036854775807) 浮点数和复数的大小也是变化的：\nfloat32 IEEE-754 32-bit floating-point numbers float64 IEEE-754 64-bit floating-point numbers complex64 complex numbers with float32 real and imaginary parts complex128 complex numbers with float64 real and imaginary parts 还有一些数字类型的别名，通过分配有用的名称来表示特定的数据类型：\nbyte alias for uint8 rune alias for int32 byte 别名的目的是清楚地表明程序何时使用字节作为字符串元素的常用计算度量，而不是与字节数据度量无关的小整数。尽管程序编译后 byte 和 uint8 是相同的，但 byte 通常用于表示数字形式的字符数据，而 uint8 则用于表示程序中的数字。\nrune 别名有点不同。如果 byte 和 uint8 是完全相同的数据，那么 rune 可以是一个字节或四个字节，这个范围由 int32 决定。rune 用来表示 Unicode 字符，而只有 ASCII 字符可以由 int32 数据类型单独表示。\n此外，Go 还有以下特定实现的类型:\nuint unsigned, either 32 or 64 bits int signed, either 32 or 64 bits uintptr unsigned integer large enough to store the uninterpreted bits of a pointer value 特定实现的类型大小将由程序编译的架构决定。\n选择数值数据类型 #  选择正确的大小通常更多地取决于编程所针对的目标架构的性能，而不是所处理的数据的大小。但是，无需知道性能对程序的具体影响，你可以在动手前遵循一些基本指导原则。\n正如本文前面所讨论的，有与架构无关的类型和特定实现的类型。对于整数数据，Go 中通常使用 int 或 uint 等实现类型，而不是 int64 或 uint64。这通常会为你的目标架构带来最快的处理速度。例如，如果使用 int64 并将其编译为 32 位架构上的应用，那么处理这些值所需的时间至少多花一倍，因为在该架构下移动数据需要额外的 CPU 周期。如果使用 int，程序会将其定义为 32 位体系结构的 32 位大小，并且处理起来会快得多。\n如果你知道你不会超过特定的大小范围，那么选择与体系结构无关的类型既可以提高速度，又可以减少内存使用。例如，如果你知道你的数据不会超过 100，而且只是一个正数，那么选择 uint8 会使你的程序更有效率，因为它需要更少的内存。\n既然我们已经了解了数值数据类型的一些可能范围，接下来让我们看看如果在程序中超过这些范围会发生什么。\n溢出 vs. 折叠 #  当你试图存储一个比设计存储的数据类型更大的值时，Go 有可能会_溢出_和_折叠_一个数字，这取决于这个值是在编译时还是在运行时计算的。当程序在尝试构建程序时发现错误时，就会发生编译时错误。程序编译完成后，在实际执行过程中会发生的是运行时错误。\n在下面的例子中，我们将 maxUint32 设置为它的最大值:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar maxUint32 uint32 = 4294967295 // Max uint32 size \tfmt.Println(maxUint32) } 编译后的运行结果如下：\nOutput 4294967295 如果我们在运行时对该值加 1，它将会被折叠为 0：\nOutput 0 另一方面，我们修改程序，在分配值且编译前加 1：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar maxUint32 uint32 = 4294967295 + 1 \tfmt.Println(maxUint32)  } 在编译时，如果编译器可以确定一个值将太大而无法保存在指定的数据类型中时，它将抛出 overflow 溢出错误。这意味着计算的值对于指定的数据类型来说太大了。\n因为编译器可以确定它会溢出值，它现在会抛出一个错误:\nOutputprog.go:6:36: constant 4294967296 overflows uint32 理解数据的边界将帮助你避免将来程序中可能出现的错误。\n现在我们已经介绍了数值类型，让我们来看看如何存储布尔值。\n布尔值 #  boolean 数据类型可以从两个值中取值，即 true 或 false，在声明为数据类型时定义为 bool。布尔值用于表示与数学逻辑分支相关的真值，它为计算机科学中的算法提供信息。\n值 true 和 false 将始终分别使用小写的 t 和 f，因为它们是 Go 中预先声明的标识符。\n许多数学运算给出的答案要么是真要么是假：\n 大于  500 \u0026gt; 100 true 1 \u0026gt; 5 false   小于  200 \u0026lt; 400 true 4 \u0026lt; 2 false   等于  5 = 5 true 500 = 400 false    与数字相似，我们可以用变量保存布尔值：\nmyBool := 5 \u0026gt; 8 接下来我们可以调用 fmt.Println() 函数来打印布尔值：\nfmt.Println(myBool) 因为 5 小于 8， 我们将会得到下面的输出结果：\nOutput false 随着你在 Go 中编写越来越多的程序，你会越来越熟悉布尔值是如何工作的，以及不同的函数和操作计算为 true 或 false 会如何改变程序的进程。\n字符串 #  字符串是由一个或多个字符（字母、数字、符号）组成的序列，这些字符可以是常量，也可以是变量。字符串存在于 Go 中的反引号 ``` 或 \u0026quot; 中，并且根据使用的引号具有不同的特征。\n如果使用反引号，就是创建了一个_原始_字符串。如果使用双引号，就是创建了一个_解释_字符串。\n原始字符串 #  原始字符串文字是反引号之间的字符序列，通常称为反引号。在引号中，除了引号字符本身之外，反引号之间的任何字符都会显示。\na := `Say \u0026#34;hello\u0026#34; to Go!` fmt.Println(a) Output Say \u0026#34;hello\u0026#34; to Go! 通常，反斜杠用于表示字符串中的特殊字符。例如，在解释字符串中，\\n 表示字符串中的新行。但是，反斜杠在原始字符串中没有特殊含义:\na := `Say \u0026#34;hello\u0026#34; to Go!\\n` fmt.Println(a) 因为反斜杠在字符串文字中没有特殊含义，它实际上会打印出 \\n 的值，而不是创建一个新的行:\nOutput Say \u0026#34;hello\u0026#34; to Go!\\n 原始字符串也可以用来创建多行字符串：\na := `This string is on multiple lines within a single back quote on either side.` fmt.Println(a) Output This string is on multiple lines within a single back quote on either side. 在前面的代码块中，新行会按字面意思从输入传递到输出。\n解释字符串 #  解释字符串是双引号之间的字符序列，如 \u0026quot;bar\u0026quot; 中所示。在引号中，除了换行符和非转义双引号外，任何字符都可以出现。要在解释字符串中显示双引号，可以使用反斜杠作为转义字符，如下所示:\na := \u0026#34;Say \\\u0026#34;hello\\\u0026#34; to Go!\u0026#34; fmt.Println(a) Output Say \u0026#34;hello\u0026#34; to Go! 你几乎总会使用解释字符串，因为它们允许在其中使用转义字符。想要了解更多关于字符串使用的信息，请查看Go 中使用字符串的简介。\nUTF-8 字符的字符串 #  UTF-8 是一种编码方案，用于将可变宽度字符编码为一到四个字节。Go 支持开箱即用的 UTF-8 字符，不需要任何特殊设置、库或包。像字母 A 这样的罗马字符可以用像数字65这样的 ASCII 值表示。但是，如果使用特殊字符，例如世这样的国际字符，则需要 UTF-8。Go 对 UTF-8 数据使用 rune 别名类型。\na := \u0026#34;Hello, 世界\u0026#34; 你可以在 for 循环中使用 range 关键字来索引 Go 中的任何字符串，甚至是 UTF-8 字符串。for 循环和 range 将在本系列后面更深入地讨论; 现在，重要的是知道我们可以使用它来计算给定字符串中的字节数：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ta := \u0026#34;Hello, 世界\u0026#34; \tfor i, c := range a { \tfmt.Printf(\u0026#34;%d: %s\\n\u0026#34;, i, string(c)) \t} \tfmt.Println(\u0026#34;length of \u0026#39;Hello, 世界\u0026#39;: \u0026#34;, len(a)) } 在上面的代码块中，我们声明了变量 a，并为其赋值 Hello，世界。分配的文本中包含 UTF-8 字符。\n然后我们使用了一个标准的 for 循环以及 range 关键字。在 Go 中，range 关键字将通过字符串索引，每次返回一个字符，以及字符位于字符串中的字节索引。\n使用 fmt.Printf 函数中，我们提供了一个格式字符串 %d:%s\\n。%d 是数字的打印动词（在本例中是整数），%s 是字符串的打印动词。然后我们提供了 i 的值，它是 for 循环的当前索引，c 是 for 循环中的当前字符。\n最后，我们使用内建的 len 函数打印了变量 a 的整个长度。\n在前面，我们提到了 rune 是 int32 的别名，可以由一到四个字节组成。世 字符需要三个字节来定义，当通过 UTF-8 字符串进行循环时，索引也会相应地移动。这就是当它被打印出来时 i 不是顺序的原因。\nOutput0: H 1: e 2: l 3: l 4: o 5: , 6: 7: 世 10: 界 length of \u0026#39;Hello, 世界\u0026#39;: 13 如你所见，字符串的长度比它循环迭代的次数大。\n你不会总使用 UTF-8 字符串，但当使用时，你将会理解为什么他们叫做 rune 而不是单个 int32。\n声明变量的数据类型 #  既然你已经了解了不同的基本数据类型，接下来我们将讨论如何在 Go 中将这些类型分配给变量。\n在 Go 中，我们可以使用关键字 var ，后面跟着变量名和所需的数据类型来定义一个变量。\n在下面的示例中，我们将声明一个类型为 float64 的变量 pi。\n关键字 var 是首先声明的:\n`var` pi float64 后面是我们的变量名，pi：\nvar `pi` float64 最后是数据类型 float64：\nvar pi `float64` 我们也有指定初始值的选项，比如 3.14：\nvar pi float64 = `3.14` Go 是一种_静态类型_语言。静态类型意味着在编译时检查程序中的每个语句。它还意味着数据类型绑定到变量，而在动态链接的语言中是数据类型绑定到值。\n例如，在 Go 中，当声明一个变量时，类型被声明:\nvar pi float64 = 3.14 var week int = 7 如果以不同的方式声明这些变量，它们中的每一个都可能是不同的数据类型。\n这与 PHP 语言不同，它的数据类型与值相关联:\n$s = \u0026#34;sammy\u0026#34;; // $s is automatically a string $s = 123; // $s is automatically an integer 在前面的代码块中，第一个 $s 是一个字符串，因为它被赋值为 \u0026quot;sammy\u0026quot;，第二个是一个整数，因为它的值为 123。\n接下来，让我们看看更复杂的数据类型，比如数组。\n数组 #  _数组_是元素的有序序列。数组的容量在创建时定义。一旦数组分配了它的大小，它的大小就不能再改变了。因为数组的大小是静态的，这意味着它只分配一次内存。这使得数组有些僵硬，但是增加了程序的性能。因此，数组通常用于优化程序。接下来介绍的_切片_更加灵活，它与你在其他语言中认识的数组更相似。\n数组是通过声明数组的大小来定义的，然后是数据类型和定义在花括号 { }之间的值。\n字符串数组如下所示：\n[3]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;} 我们可以把数组保存在变量中并打印出来：\ncoral := [3]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;} fmt.Println(coral) Output [blue coral staghorn coral pillar coral] 上面提到过，切片和数组类似，但更加的灵活。让我们看下这个可变的数据类型。\n切片 #  一个_切片_是一个可以改变长度的有序元素序列。切片可以动态地增加它们的大小。当你向一个切片添加新元素时，如果该切片没有足够的内存来存储新元素，那么它将根据需要从系统中申请更多的内存。由于可以根据需要扩展切片以添加更多的元素，因此它们比数组更常用。\n切片的定义是通过声明前面有开方括号和闭方括号 [] 的数据类型，并且在花括号 {} 之间有值。\n整数切片如下所示：\n[]int{-3, -2, -1, 0, 1, 2, 3} 浮点数的切片如下所示：\n[]float64{3.14, 9.23, 111.11, 312.12, 1.05} 字符串的切片如下所示：\n[]string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;} 我们定义一个字符切片叫做 seaCreatures：\nseaCreatures := []string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;} 我们可以通过调用变量打印出来：\nfmt.Println(seaCreatures) 输出将和我们创建的列表完全一样：\nOutput [shark cuttlefish squid mantis shrimp] We can use the append keyword to add an item to our slice. The following command will add the string value of seahorse to the slice: 我们可以使用 append 关键字，在切片中添加一个元素。下面的命令将在切片中增加字符串值 seahorse：\nseaCreatures = append(seaCreatures, \u0026#34;seahorse\u0026#34;) 你可以通过打印来验证确实添加了这个元素：\nfmt.Println(seaCreatures) Output [shark cuttlefish squid mantis shrimp seahorse] 如你所见，若你需要管理一个未知长度的元素，切片将比数据更加适合。\nMaps #  _map_是 Go 内建的哈希或字典类型。 Map 使用 键 _值_对来存储数据。在编程中快速通过索引或在 Go 中通过键来查找值时非常有用。比如，你可能会用 map 按用户 ID 为索引来保存用户。键可以是用户 ID，用户对象可以是值。map 可以用 map 关键字，接着把键的数据类型放在 [] 中括号里，后面是值的数据类型，且键值对放在大括号中。\nmap[key]value{} 一般用于保存相关的数据，比如包含 ID 的信息，map 如下所示：\nmap[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} 你将注意到，除了大括号之外，整个 map 中还有冒号。冒号左边的字是键。键可以是 Go 中的任何_可比较的_类型。可比较的类型是一些基本类型，如 strings、ints 等。基本类型是由语言定义的，而不是通过组合任何其他类型构建的。虽然它们可以是用户定义的类型，但为了避免编程错误，保持它们简单被认为是最佳实践。上面字典中的键是: name、animal、color 和 location。\n冒号右边的单词是值。值可以由任何数据类型组成。上面字典中的值是: Sammy，shark，blue 和 ocean。\n让我们把 map 存储在一个变量中，然后打印出来:\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(sammy) Output map[animal:shark color:blue location:ocean name:Sammy] 如果我们只想打印 Sammy 的颜色，可以通过调用 sammy[\u0026quot;color\u0026quot;] 的方式完成。我们把它打印出来：\nfmt.Println(sammy[\u0026#34;color\u0026#34;]) Output blue 因为 map 提供了以键-值的方式来存储值，在你的 Go 程序中它们会是重要的元素。\n结论 #  此时，你应该对 Go 中可用的一些主要数据类型有了更好的理解。当你使用 Go 语言开发编程项目时，这些数据类型中的每一种都将变得非常重要。\n一旦掌握了 Go 中可用的数据类型，就可以学习如何转换数据类型，以便根据具体情况更改数据类型。\n"},{"id":7,"href":"/docs/08-An_Introduction_to_Working_with_Strings_in_Go/","title":"08 an Introduction to Working With Strings in Go","section":"Docs","content":"Go 中处理字符串的介绍 #  _字符串_是由一个或多个字符(字母、数字、符号)组成的序列，这些字符可以是常量，也可以是变量。字符串由 Unicode 组成，是不可变的序列，这意味着它们是不变的。\n因为文本是我们日常生活中使用的常见数据形式，所以字符串数据类型是编程中一个非常重要的基石。\n本 Go 教程将介绍如何创建和打印字符串，如何连接和复制字符串，以及如何在变量中存储字符串。\n字符串文字 #  在 Go 中，字符串存在于反引号 `（有时叫做反勾号）或双引号 \u0026quot; 中。根据使用的引号不同，字符串将具有不同的特征。\n使用反引号，如 ` bar `，将创建一个_原始_字符串。在原始字符串中，除了反引号之外，任何字符都可以出现在引号之间。下面是一个原始字符串的例子:\n`Say \u0026#34;hello\u0026#34; to Go!` 反斜杠在原始字符串中没有特殊含义。例如，\\n 表示的是实际字符，以反斜杠 \\ 和字母 n 的形式出现。不像解释的字符串文字，\\n 会插入一个实际的新行。\n原始字符串也可用于创建多行字符串:\n`Go is expressive, concise, clean, and efficient. Its concurrency mechanisms make it easy to write programs that get the most out of multi-core and networked machines, while its novel type system enables flexible and modular program construction. Go compiles quickly to machine code yet has the convenience of garbage collection and the power of run-time reflection. It\u0026#39;s a fast, statically typed, compiled language that feels like a dynamically typed, interpreted language.` 解释字符串是双引号之间的字符序列，如 \u0026quot;bar\u0026quot; 中所示。在引号中，除了换行符和非转义双引号之外，可以出现任何字符。\n\u0026#34;Say \\\u0026#34;hello\\\u0026#34; to Go!\u0026#34; 您几乎总是使用解释字符串，因为它们允许使用转义字符。\n现在你已经了解了 Go 中字符串是如何格式化的，接下来让我们看看如何在程序中打印字符串。\n打印字符串 #  你可以使用系统库中的 fmt 包并调用 Println() 函数来打印字符串：\nfmt.Println(\u0026#34;Let\u0026#39;s print out this string.\u0026#34;) Output Let\u0026#39;s print out this string. 当你使用系统库时需要 import 它们，因此一个简单打印字符串的程序如下所示：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;Let\u0026#39;s print out this string.\u0026#34;) } 字符串拼接 #  _拼接_意味着把字符串收尾连接起来，创建一个新的字符串。你可以使用 + 号连接字符串。注意当你处理数字时，+ 将是一个加和的操作符，但在用于字符串时是一个连接符。\n让我们通过一个 fmt.Println() 声明语句把 \u0026quot;Sammy\u0026quot; 和 \u0026quot;Shark\u0026quot; 字符串连接到一起：\nfmt.Println(\u0026#34;Sammy\u0026#34; + \u0026#34;Shark\u0026#34;) Output SammyShark 如果希望两个字符串之间有空格，只需在字符串中包含空格即可。在这个例子中，在 Sammy 之后的引号中添加空格:\nfmt.Println(\u0026#34;Sammy \u0026#34; + \u0026#34;Shark\u0026#34;) Output Sammy Shark 不能在两种不同的数据类型之间使用 + 运算符。例如，你不能将字符串和整数连接在一起。如果你试着写下面的代码:\nfmt.Println(\u0026#34;Sammy\u0026#34; + 27) 你将会收到下面的错误：\nOutput cannot convert \u0026#34;Sammy\u0026#34; (type untyped string) to type int invalid operation: \u0026#34;Sammy\u0026#34; + 27 (mismatched types string and int) 如果希望创建字符串 \u0026quot;Sammy27\u0026quot;，可以将数字 27 放在引号中（\u0026quot;27\u0026quot;）中 ，这样它就不再是一个整数，而是一个字符串。在处理邮政编码或电话号码时，将数字转换为字符串以进行连接非常有用。例如，你不希望在国家代码和地区代码之间执行添加操作，但是您希望它们可以放在一起。\n当通过连接将两个或多个字符串组合在一起时，就创建了一个可以在整个程序中使用的新字符串。\n在变量中保存字符串 #  **变量**是在程序中可以用来保存数据的符号。你可以将它们看作是一个可以在其中填充一些数据或值的空盒子。字符串是数据，因此你可以使用它们来填充变量。将字符串声明为变量可以使得在 Go 程序中处理字符串更加容易。\n要在变量中存储字符串，只需将一个变量分配给字符串。在下面的例子中，s 被声明为变量:\ns := \u0026#34;Sammy likes declaring strings.\u0026#34;  注意: 如果你熟悉其他的编程语言，你可以把变量写成 sammy。但是，Go 倾向于使用较短的变量名。在这种情况下，选择 s 作为变量名被认为更适合编写 Go 的样式。\n 现在你有了设置为特定字符串的变量 s，你可以像下面的代码一样打印变量：\nfmt.Println(s) 你将获得下面的输出：\nOutput Sammy likes declaring strings. 通过使用变量来替代字符串，你不必每次都要重新键入字符串，从而使您在程序中处理和操作字符串更加简单。\n结论 #  本教程介绍了使用 Go 编程语言处理字符串数据类型的基本知识。创建并打印字符串、连接和复制字符串以及将字符串存储在变量中，它们将为你提供在 Go 程序中使用字符串的基础知识。\n"},{"id":8,"href":"/docs/09-How_To_Format_Strings_in_Go/","title":"09 How to Format Strings in Go","section":"Docs","content":"How To Format Strings in Go #  As strings are often made up of written text, there are many instances when we may want to have greater control over how strings look to make them more readable for humans through punctuation, line breaks, and indentation.\nIn this tutorial, we’ll go over some of the ways we can work with Go strings to make sure that all output text is formatted correctly.\nString Literals #  Let’s first differentiate between a string literal and a string value. A string literal is what we see in the source code of a computer program, including the quotation marks. A string value is what we see when we call the fmt.Println function and run the program.\nIn the “Hello, World!” program, the string literal is \u0026quot;Hello, World!\u0026quot; while the string value is Hello, World! without the quotation marks. The string value is what we see as the output in a terminal window when we run a Go program.\nBut some string values may need to include quotation marks, like when we are quoting a source. Because string literals and string values are not equivalent, it is often necessary to add additional formatting to string literals to ensure that string values are displayed the way in which we intend.\nQuotes #  Because we can use back quotes (`` ) or double quotes (\u0026quot;`) within Go, it is simple to embed quotes within a string by using double quotes within a string enclosed by back quotes:\n`Sammy says, \u0026#34;Hello!\u0026#34;` Or, to use a back quote, you can enclose the string in double quotes:\n\u0026#34;Sammy likes the `fmt` package for formatting strings..\u0026#34; In the way we combine back quotes and double quotes, we can control the display of quotation marks and back quotes within our strings.\nIt’s important to remember that using back quotes in Go creates a raw string literal, and using double quotes creates an interpreted string literal. To learn more about the difference, read the An Introduction to Working with Strings in Go tutorial.\nEscape Characters #  Another way to format strings is to use an escape character. Escape characters are used to tell the code that the following character has a special meaning. Escape characters all start with the backslash key (\\) combined with another character within a string to format the given string a certain way.\nHere is a list of several of the common escape characters:\n   Escape Character How it formats     \\ Backslash   \u0026quot; Double Quote   \\n Line Break   \\t Tab (horizontal indentation)    Let’s use an escape character to add the quotation marks to the example on quotation marks above, but this time we’ll use double quotes to denote the string:\nfmt.Println(\u0026#34;Sammy says, \\\u0026#34;Hello!\\\u0026#34;\u0026#34;) Output Sammy says, \u0026#34;Hello!\u0026#34; By using the escape character \\\u0026quot; we are able to use double quotes to enclose a string that includes text quoted between double quotes.\nWe can use the \\n escape character to break lines without hitting the enter or return key:\nfmt.Println(\u0026#34;This string\\nspans multiple\\nlines.\u0026#34;) Output This string spans multiple lines. We can combine escape characters, too. Let’s print a multi-line string and include tab spacing for an itemized list, for example:\nfmt.Println(\u0026#34;1.\\tShark\\n2.\\tShrimp\\n10.\\tSquid\u0026#34;) Output 1. Shark 2. Shrimp 10. Squid The horizontal indentation provided with the \\t escape character ensures alignment within the second column in the preceding example, making the output extremely readable for humans.\nEscape characters are used to add additional formatting to strings that may be difficult or impossible to achieve. Without escape characters, you would not be able to construct the string Sammy says, \u0026quot;I like to use the fmt package\u0026quot;.\nMultiple Lines #  Printing strings on multiple lines can make text more readable to humans. With multiple lines, strings can be grouped into clean and orderly text, formatted as a letter, or used to maintain the linebreaks of a poem or song lyrics.\nTo create strings that span multiple lines, back quotes are used to enclose the string. Keep in mind that while this will preserve the line returns, it is also creating a raw string literal.\n` This string is on multiple lines within three single quotes on either side. ` You will notice if you print this that there is a leading and trailing return:\nOutput  This string is on multiple lines within three single quotes on either side. To avoid this, you need to put the first line immediately following the back quote and end the last with the back quote.\n`This string is on multiple lines within three single quotes on either side.` If you need to create an interpreted string literal, this can be done with double quotes and the + operator, but you will need to insert your own line breaks.\n\u0026#34;This string is on\\n\u0026#34; + \u0026#34;multiple lines\\n\u0026#34; + \u0026#34;within three single\\n\u0026#34; + \u0026#34;quotes on either side.\u0026#34; While back quotes can make it easier to print and read lengthy text, if you need an interpreted string literal, you will need to use double quotes.\nRaw String Literals #  What if we don’t want special formatting within our strings? For example, we may need to compare or evaluate strings of computer code that use the backslash on purpose, so we won’t want Go to use it as an escape character.\nA raw string literal tells Go to ignore all formatting within a string, including escape characters.\nWe create a raw string by using back quotes around the string:\nfmt.Println(`Sammy says,\\\u0026#34;The balloon\\\u0026#39;s color is red.\\\u0026#34;`) Output Sammy says,\\\u0026#34;The balloon\\\u0026#39;s color is red.\\\u0026#34; By constructing a raw string by using back quotes around a given string, we can retain backslashes and other characters that are used as escape characters.\nConclusion #  This tutorial went over several ways to format text in Go through working with strings. By using techniques such as escape characters or raw strings, we are able to ensure that the strings of our program are rendered correctly on-screen so that the end user is able to easily read all of the output text.\n"},{"id":9,"href":"/docs/10-An_Introduction_to_the_Strings_Package_in_Go/","title":"10 an Introduction to the Strings Package in Go","section":"Docs","content":"An Introduction to the Strings Package in Go #  Introduction #  Go’s string package has several functions available to work with the string data type. These functions let us easily modify and manipulate strings. We can think of functions as being actions that we perform on elements of our code. Built-in functions are those that are defined in the Go programming language and are readily available for us to use.\nIn this tutorial, we’ll review several different functions that we can use to work with strings in Go.\nMaking Strings Uppercase and Lowercase #  The functions strings.ToUpper and strings.ToLower will return a string with all the letters of an original string converted to uppercase or lowercase letters. Because strings are immutable data types, the returned string will be a new string. Any characters in the string that are not letters will not be changed.\nTo convert the string \u0026quot;Sammy Shark\u0026quot; to be all uppercase, you would use the strings.ToUpper function:\nss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.ToUpper(ss)) Output SAMMY SHARK To convert to lowercase:\nfmt.Println(strings.ToLower(ss)) Output sammy shark Since you are using the strings package, you first need to import it into a program. To convert the string to uppercase and lowercase the entire program would be as follows:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { ss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.ToUpper(ss)) fmt.Println(strings.ToLower(ss)) } The strings.ToUpper and strings.ToLower functions make it easier to evaluate and compare strings by making case consistent throughout. For example, if a user writes their name all lowercase, we can still determine whether their name is in our database by checking it against an all uppercase version.\nString Search Functions #  The strings package has a number of functions that help determine if a string contains a specific sequence of characters.\n   Function Use     strings.HasPrefix Searches the string from the beginning   strings.HasSuffix Searches the string from the end   strings.Contains Searches anywhere in the string   strings.Count Counts how many times the string appears    The strings.HasPrefix and strings.HasSuffix allow you to check to see if a string starts or ends with a specific set of characters.\nFor example, to check to see if the string \u0026quot;Sammy Shark\u0026quot; starts with Sammy and ends with Shark:\nss := \u0026#34;Sammy Shark\u0026#34; fmt.Println(strings.HasPrefix(ss, \u0026#34;Sammy\u0026#34;)) fmt.Println(strings.HasSuffix(ss, \u0026#34;Shark\u0026#34;)) Output true true You would use the strings.Contains function to check if \u0026quot;Sammy Shark\u0026quot; contains the sequence Sh:\nfmt.Println(strings.Contains(ss, \u0026#34;Sh\u0026#34;)) Output true Finally, to see how many times the letter S appears in the phrase Sammy Shark:\nfmt.Println(strings.Count(ss, \u0026#34;S\u0026#34;)) Output 2 Note: All strings in Go are case sensitive. This means that Sammy is not the same as sammy.\nUsing a lowercase s to get a count from Sammy Shark is not the same as using uppercase S:\nfmt.Println(strings.Count(ss, \u0026#34;s\u0026#34;)) Output 0 Because S is different than s, the count returned will be 0.\nString functions are useful when you want to compare or search strings in your program.\nDetermining String Length #  The built-in function len() returns the number of characters in a string. This function is useful for when you need to enforce minimum or maximum password lengths, or to truncate larger strings to be within certain limits for use as abbreviations.\nTo demonstrate this function, we’ll find the length of a sentence-long string:\nimport ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func main() {  openSource := \u0026#34;Sammy contributes to open source.\u0026#34;  fmt.Println(len(openSource)) } Output 33 We set the variable openSource equal to the string \u0026quot;Sammy contributes to open source.\u0026quot; and then passed that variable to the len() function with len(openSource). Finally we passed the function into the fmt.Println() function so that we could see the program’s output on the screen…\nKeep in mind that the len() function will count any character bound by double quotation marks—including letters, numbers, whitespace characters, and symbols.\nFunctions for String Manipulation #  The strings.Join, strings.Split, and strings.ReplaceAll functions are a few additional ways to manipulate strings in Go.\nThe strings.Join function is useful for combining a slice of strings into a new single string.\nTo create a comma-separated string from a slice of strings, we would use this function as per the following:\nfmt.Println(strings.Join([]string{\u0026#34;sharks\u0026#34;, \u0026#34;crustaceans\u0026#34;, \u0026#34;plankton\u0026#34;}, \u0026#34;,\u0026#34;)) Output sharks,crustaceans,plankton If we want to add a comma and a space between string values in our new string, we can simply rewrite our expression with a whitespace after the comma: strings.Join([]string{\u0026quot;sharks\u0026quot;, \u0026quot;crustaceans\u0026quot;, \u0026quot;plankton\u0026quot;}, \u0026quot;, \u0026quot;).\nJust as we can join strings together, we can also split strings up. To do this, we can use the strings.Split function and split on the spaces:\nballoon := \u0026#34;Sammy has a balloon.\u0026#34; s := strings.Split(balloon, \u0026#34; \u0026#34;) fmt.Println(s) Output [Sammy has a balloon] The output is a slice of strings. Since strings.Println was used, it is hard to tell what the output is by looking at it. To see that it is indeed a slice of strings, use the fmt.Printf function with the %q verb to quote the strings:\nfmt.Printf(\u0026#34;%q\u0026#34;, s) Output [\u0026#34;Sammy\u0026#34; \u0026#34;has\u0026#34; \u0026#34;a\u0026#34; \u0026#34;balloon.\u0026#34;] Another useful function in addition to strings.Split is strings.Fields. The difference is that strings.Fields will ignore all whitespace, and will only split out the actual fields in a string:\ndata := \u0026#34; username password email date\u0026#34; fields := strings.Fields(data) fmt.Printf(\u0026#34;%q\u0026#34;, fields) Output [\u0026#34;username\u0026#34; \u0026#34;password\u0026#34; \u0026#34;email\u0026#34; \u0026#34;date\u0026#34;] The strings.ReplaceAll function can take an original string and return an updated string with some replacement.\nLet’s say that the balloon that Sammy had is lost. Since Sammy no longer has this balloon, we would change the substring \u0026quot;has\u0026quot; from the original string balloon to \u0026quot;had\u0026quot; in a new string:\nfmt.Println(strings.ReplaceAll(balloon, \u0026#34;has\u0026#34;, \u0026#34;had\u0026#34;)) Within the parentheses, first is balloon the variable that stores the original string; the second substring \u0026quot;has\u0026quot; is what we would want to replace, and the third substring \u0026quot;had\u0026quot; is what we would replace that second substring with. Our output would look like this when we incorporate this into a program:\nOutput Sammy had a balloon. Using the string function strings.Join, strings.Split, and strings.ReplaceAll will provide you with greater control to manipulate strings in Go.\nConclusion #  This tutorial went through some of the common string package functions for the string data type that you can use to work with and manipulate strings in your Go programs.\nYou can learn more about other data types in Understanding Data Types and read more about strings in An Introduction to Working with Strings.\n "},{"id":10,"href":"/docs/11-How_To_Use_Variables_and_Constants_in_Go/","title":"11 How to Use Variables and Constants in Go","section":"Docs","content":"How To Use Variables and Constants in Go #  Variables are an important programming concept to master. They are symbols that stand in for a value you’re using in a program.\nThis tutorial will cover some variable basics and best practices for using them within the Go programs you create.\nUnderstanding Variables #  In technical terms, a variable is assigning a storage location to a value that is tied to a symbolic name or identifier. We use the variable name to reference that stored value within a computer program.\nWe can think of a variable as a label that has a name on it, which you tie onto a value.\nLet’s say we have an integer, 1032049348, and we want to store it in a variable rather than continuously retype the long number over and over again. To achieve this, we can use a name that’s easy to remember, like the variable i. To store a value in a variable, we use the following syntax:\ni := 1032049348 We can think of this variable like a label that is tied to the value.\nThe label has the variable name i written on it, and is tied to the integer value 1032049348.\nThe phrase i := 1032049348 is a declaration and assignment statement that consists of a few parts:\n the variable name (i) the short variable declaration assignment (:=) the value that is being tied to the variable name (1032049348) the data type inferred by Go (int)  We’ll see later how to explicitly set the type in the next section.\nTogether, these parts make up the statement that sets the variable i equal to the value of the integer 1032049348.\nAs soon as we set a variable equal to a value, we initialize or create that variable. Once we have done that, we are ready to use the variable instead of the value.\nOnce we’ve set i equal to the value of 1032049348, we can use i in the place of the integer, so let’s print it out:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ti := 1032049348 \tfmt.Println(i) } Output 1032049348 We can also quickly and easily do math by using variables. With i := 1032049348, we can subtract the integer value 813 with the following syntax:\nfmt.Println(i - 813) Output 1032048535 In this example, Go does the math for us, subtracting 813 from the variable i to return the sum 1032048535.\nSpeaking of math, variables can be set equal to the result of a math equation. You can also add two numbers together and store the value of the sum into the variable x:\nx := 76 + 145 You may have noticed that this example looks similar to algebra. In the same way that we use letters and other symbols to represent numbers and quantities within formulas and equations, variables are symbolic names that represent the value of a data type. For correct Go syntax, you’ll need to make sure that your variable is on the left side of any equations.\nLet’s go ahead and print x:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tx := 76 + 145 \tfmt.Println(x) } Output 221 Go returned the value 221 because the variable x was set equal to the sum of 76 and 145.\nVariables can represent any data type, not just integers:\ns := \u0026#34;Hello, World!\u0026#34; f := 45.06 b := 5 \u0026gt; 9 // A Boolean value will return either true or false array := [4]string{\u0026#34;item_1\u0026#34;, \u0026#34;item_2\u0026#34;, \u0026#34;item_3\u0026#34;, \u0026#34;item_4\u0026#34;} slice := []string{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;} m := map[string]string{\u0026#34;letter\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;number\u0026#34;: \u0026#34;seven\u0026#34;, \u0026#34;symbol\u0026#34;: \u0026#34;\u0026amp;\u0026#34;} If you print any of these variables, Go will return what that variable is equivalent to. Let’s work with the assignment statement for the string slice data type:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tslice := []string{\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;} \tfmt.Println(slice) } Output [one two three] We assigned the slice value of []string{\u0026quot;one\u0026quot;, \u0026quot;two\u0026quot;, \u0026quot;three\u0026quot;} to the variable slice, and then used the fmt.Println function to print out that value by calling slice.\nVariables work by carving out a little area of memory within your computer that accepts specified values that are then associated with that space.\nDeclaring Variables #  In Go, there are several ways to declare a variable, and in some cases, more than one way to declare the exact same variable and value.\nWe can declare a variable called i of data type int without initialization. This means we will declare a space to put a value, but not give it an initial value:\nvar i int This creates a variable declared as i of data type int.\nWe can initialize the value by using the equal (=) operator, like in the following example:\nvar i int = 1 In Go, both of these forms of declaration are called long variable declarations.\nWe can also use short variable declaration:\ni := 1 In this case, we have a variable called i, and a data type of int. When we don’t specify a data type, Go will infer the data type.\nWith the three ways to declare variables, the Go community has adopted the following idioms:\n Only use long form, var i int, when you’re not initializing the variable. Use short form, i := 1, when declaring and initializing. If you did not desire Go to infer your data type, but you still want to use short variable declaration, you can wrap your value in your desired type, with the following syntax:  i := int64(1) It’s not considered idiomatic in Go to use the long variable declaration form when we’re initializing the value:\nvar i int = 1 It’s good practice to follow how the Go community typically declares variables so that others can seamlessly read your programs.\nZero Values #  All built-in types have a zero value. Any allocated variable is usable even if it never has a value assigned. We can see the zero values for the following types:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar a int \tvar b string \tvar c float64 \tvar d bool  \tfmt.Printf(\u0026#34;var a %T = %+v\\n\u0026#34;, a, a) \tfmt.Printf(\u0026#34;var b %T = %q\\n\u0026#34;, b, b) \tfmt.Printf(\u0026#34;var c %T = %+v\\n\u0026#34;, c, c) \tfmt.Printf(\u0026#34;var d %T = %+v\\n\\n\u0026#34;, d, d) } Output var a int = 0 var b string = \u0026#34;\u0026#34; var c float64 = 0 var d bool = false We used the %T verb in the fmt.Printf statement. This tells the function to print the data type for the variable.\nIn Go, because all values have a zero value, we can’t have undefined values like some other languages. For instance, a boolean in some languages could be undefined, true, or false, which allows for three states to the variable. In Go, we can’t have more than two states for a boolean value.\nNaming Variables: Rules and Style #  The naming of variables is quite flexible, but there are some rules to keep in mind:\n Variable names must only be one word (as in no spaces). Variable names must be made up of only letters, numbers, and underscores (_). Variable names cannot begin with a number.  Following these rules, let’s look at both valid and invalid variable names:\n   Valid Invalid Why Invalid     userName user-name Hyphens are not permitted   name4 4name Cannot begin with a number   user $user Cannot use symbols   userName user name Cannot be more than one word    Furthermore, keep in mind when naming variables that they are case sensitive. These names userName, USERNAME, UserName, and uSERnAME are all completely different variables. It’s best practice to avoid using similar variable names within a program to ensure that both you and your collaborators—current and future—can keep your variables straight.\nWhile variables are case sensitive, the case of the first letter of a variable has special meaning in Go. If a variable starts with an uppercase letter, then that variable is accessible outside the package it was declared in (or exported). If a variable starts with a lowercase letter, then it is only available within the package it is declared in.\nvar Email string var password string Email starts with an uppercase letter and can be accessed by other packages. password starts with a lowercase letter, and is only accessible inside the package it is declared in.\nIt is common in Go to use very terse (or short) variable names. Given the choice between using userName and user for a variable, it would be idiomatic to choose user.\nScope also plays a role in the terseness of the variable name. The rule is that the smaller the scope the variable exists in, the smaller the variable name:\nnames := []string{\u0026#34;Mary\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;Bob\u0026#34;, \u0026#34;Anna\u0026#34;} for i, n := range names { \tfmt.Printf(\u0026#34;index: %d = %q\\n\u0026#34;, i, n) } We use the variable names in a larger scope, so it would be common to give it a more meaningful name to help remember what it means in the program. However, we use the i and n variables immediately in the next line of code, and then do not use them again… Because of this, it won’t confuse someone reading the code about where the variables are used, or what they mean.\nNext, let’s cover some notes about variable style. The style is to use MixedCaps or mixedCaps rather than underscores for multi-word names.\n   Conventional Style Unconventional Style Why Unconventional     userName user_name Underscores are not conventional   i index prefer i over index as it is shorter   serveHTTP serveHttp acronyms should be capitalized    The most important thing about style is to be consistent, and that the team you work on agrees to the style.\nReassigning Variables #  As the word “variable” implies, we can change Go variables readily. This means that we can connect a different value with a previously assigned variable through reassignment. Being able to reassign is useful because throughout the course of a program we may need to accept user-generated values into already initialized variables. We may also need to change the assignment to something previously defined.\nKnowing that we can readily reassign a variable can be useful when working on a large program that someone else wrote, and it isn’t clear what variables are already defined.\nLet’s assign the value of 76 to a variable called i of type int, then assign it a new value of 42:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \ti := 76 \tfmt.Println(i)  \ti = 42 \tfmt.Println(i) } Output 76 42 This example shows that we can first assign the variable i with the value of an integer, and then reassign the variable i assigning it this time with the value of 42.\nNote: When you declare and initialize a variable, you can use :=, however, when you want to simply change the value of an already declared variable, you only need to use the equal operator (=).\nBecause Go is a typed language, we can’t assign one type to another. For instance, we can’t assign the value \u0026quot;Sammy\u0026quot; to a variable of type int:\ni := 72 i = \u0026#34;Sammy\u0026#34; Trying to assign different types to each other will result in a compile-time error:\nOutput cannot use \u0026#34;Sammy\u0026#34; (type string) as type int in assignment Go will not allow us to use a variable name more than once:\nvar s string var s string Output s redeclared in this block If we try to use short variable declaration more than once for the same variable name we’ll also receive a compilation error. This can happen by mistake, so understanding what the error message means is helpful:\ni := 5 i := 10 Output no new variables on left side of := Similarly to variable declaration, giving consideration to the naming of your variables will improve the readability of your program for you, and others, when you revisit it in the future.\nMultiple Assignment #  Go also allows us to assign several values to several variables within the same line. Each of these values can be of a different data type:\nj, k, l := \u0026#34;shark\u0026#34;, 2.05, 15 fmt.Println(j) fmt.Println(k) fmt.Println(l) Output shark 2.05 15 In this example, the variable j was assigned to the string \u0026quot;shark\u0026quot;, the variable k was assigned to the float 2.05, and the variable l was assigned to the integer 15.\nThis approach to assigning multiple variables to multiple values in one line can keep the number of lines in your code down. However, it’s important to not compromise readability for fewer lines of code.\nGlobal and Local Variables #  When using variables within a program, it is important to keep variable scope in mind. A variable’s scope refers to the particular places it is accessible from within the code of a given program. This is to say that not all variables are accessible from all parts of a given program—some variables will be global and some will be local.\nGlobal variables exist outside of functions. Local variables exist within functions.\nLet’s take a look at global and local variables in action:\npackage main  import \u0026#34;fmt\u0026#34;   var g = \u0026#34;global\u0026#34;  func printLocal() { \tl := \u0026#34;local\u0026#34; \tfmt.Println(l) }  func main() { \tprintLocal() \tfmt.Println(g) } Output local global Here we use var g = \u0026quot;global\u0026quot; to create a global variable outside of the function. Then we define the function printLocal(). Inside of the function a local variable called l is assigned and then printed out. The program ends by calling printLocal() and then printing the global variable g.\nBecause g is a global variable, we can refer to it in printLocal(). Let’s modify the previous program to do that:\npackage main  import \u0026#34;fmt\u0026#34;   var g = \u0026#34;global\u0026#34;  func printLocal() { \tl := \u0026#34;local\u0026#34; \tfmt.Println(l) \tfmt.Println(g) }  func main() { \tprintLocal() \tfmt.Println(g) } Output local global global We start by declaring a global variable g, var g = \u0026quot;global\u0026quot;. In the main function, we call the function printLocal, which declares a local variable l and prints it out, fmt.Println(l). Then, printLocal prints out the global variable g, fmt.Println(g). Even though g wasn’t defined within printLocal, it could still be accessed because it was declared in a global scope. Finally, the main function prints out g as well.\nNow let’s try to call the local variable outside of the function:\npackage main  import \u0026#34;fmt\u0026#34;  var g = \u0026#34;global\u0026#34;  func printLocal() { \tl := \u0026#34;local\u0026#34; \tfmt.Println(l) }  func main() { \tfmt.Println(l) } Output undefined: l We can’t use a local variable outside of the function it is assigned in. If you try to do so, you’ll receive a undefined error when you compile.\nLet’s look at another example where we use the same variable name for a global variable and a local variable:\npackage main  import \u0026#34;fmt\u0026#34;  var num1 = 5  func printNumbers() { \tnum1 := 10 \tnum2 := 7  \tfmt.Println(num1) \tfmt.Println(num2) }  func main() { \tprintNumbers() \tfmt.Println(num1) } Output 10 7 5 In this program, we declared the num1 variable twice. First, we declared num1 at the global scope, var num1 = 5, and again within the local scope of the printNumbers function, num1 := 10. When we print num1 from the main program, we see the value of 5 printed out. This is because main only sees the global variable declaration. However, when we print out num1 from the printNumbers function, it sees the local declaration, and will print out the value of 10. Even though printNumbers creates a new variable called num1 and assigned it a value of 10, it does not affect the global instance of num1 with the value of 5.\nWhen working with variables, you also need to consider what parts of your program will need access to each variables; adopting a global or local variable accordingly. Across Go programs, you’ll find that local variables are typically more common.\nConstants #  Constants are like variables, except they can’t be modified once they have been declared. Constants are useful for defining a value that will be used more than once in your program, but shouldn’t be able to change.\nFor instance, if we wanted to declare the tax rate for a shopping cart system, we could use a constant and then calculate tax in different areas of our program. At some point in the future, if the tax rate changes, we only have to change that value in one spot in our program. If we used a variable, it is possible that we might accidentally change the value somewhere in our program, which would result in an improper calculation.\nTo declare a constant, we can use the following syntax:\nconst shark = \u0026#34;Sammy\u0026#34; fmt.Println(shark) Output Sammy If we try to modify a constant after it was declared, we’ll get a compile-time error:\nOutput cannot assign to shark Constants can be untyped. This can be useful when working with numbers such as integer-type data. If the constant is untyped, it is explicitly converted, where typed constants are not. Let’s see how we can use constants:\npackage main  import \u0026#34;fmt\u0026#34;  const ( \tyear = 365 \tleapYear = int32(366) )  func main() { \thours := 24 \tminutes := int32(60) \tfmt.Println(hours * year) \tfmt.Println(minutes * year) \tfmt.Println(minutes * leapYear) } Output 8760 21900 21960 If you declare a constant with a type, it will be that exact type. Here when we declare the constant leapYear, we define it as data type int32. Therefore it is a typed constant, which means it can only operate with int32 data types. The year constant we declare with no type, so it is considered untyped. Because of this, you can use it with any integer data type.\nWhen hours was defined, it inferred that it was of type int because we did not explicitly give it a type, hours := 24. When we declared minutes, we explicitly declared it as an int32, minutes := int32(60).\nNow let’s walk through each calculation and why it works:\nhours * year In this case, hours is an int, and years is untyped. When the program compiles, it explicitly converts years to an int, which allows the multiplication operation to succeed.\nminutes * year In this case, minutes is an int32, and year is untyped. When the program compiles, it explicitly converts years to an int32, which allows the multiplication operation to succeed.\nminutes * leapYear In this case, minutes is an int32, and leapYear is a typed constant of int32. There is nothing for the compiler to do this time as both variables are already of the same type.\nIf we try to multiply two types that are typed and not compatible, the program will not compile:\nfmt.Println(hours * leapYear) Output invalid operation: hours * leapYear (mismatched types int and int32) In this case, hours was inferred as an int, and leapYear was explicitly declared as an int32. Because Go is a typed language, an int and an int32 are not compatible for mathematical operations. To multiply them, you would need to convert one to a int32 or an int.\nConclusion #  In this tutorial we reviewed some of the common use cases of variables within Go. Variables are an important building block of programming, serving as symbols that stand in for the value of a data type we use in a program.\n"},{"id":11,"href":"/docs/12-How_To_Convert_Data_Types_in_Go/","title":"12 How to Convert Data Types in Go","section":"Docs","content":"How To Convert Data Types in Go #  Introduction #  In Go, data types are used to classify one particular type of data, determining the values that you can assign to the type and the operations you can perform on it. When programming, there are times when you will need to convert values between types in order to manipulate values in a different way. For example, you may need to concatenate numeric values with strings, or represent decimal places in numbers that were initialized as integer values. User-generated data is often automatically assigned the string data type, even if it consists of numbers; in order to perform mathematical operations in this input, you would have to convert the string to a numeric data type.\nSince Go is a statically typed language, data types are bound to variables rather than values. This means that, if you define a variable as an int, it can only be an int; you can’t assign a string to it without converting the data type of the variable. The static nature of data types in Go places even more importance on learning the ways to convert them.\nThis tutorial will guide you through converting numbers and strings, as well as provide examples to help familiarize yourself with different use cases.\nConverting Number Types #  Go has several numeric types to choose from. Primarily they break out into two general types: integers and floating-point numbers.\nThere are many situations in which you may want to convert between numeric types. Converting between different sizes of numeric types can help optimize performance for specific kinds of system architecture. If you have an integer from another part of your code and want to do division on it, you may want to convert the integer to a float to preserve the precision of the operation. Additionally, working with time durations usually involves integer conversion. To address these situations, Go has built-in type conversions for most numeric types.\nConverting Between Integer Types #  Go has many integer data types to pick from. When to use one over the other is typically more about performance; however, there will be times when you will need to convert from one integer type to another. For example, Go sometimes automatically generates numeric values as int, which may not match your input value. If your input value were int64, you would not be able to use the int and the int64 numbers in the same mathematical expression until you converted their data types to match.\nAssume that you have an int8 and you need to convert it to an int32. You can do this by wrapping it in the int32() type conversion:\nvar index int8 = 15  var bigIndex int32  bigIndex = int32(index)  fmt.Println(bigIndex) Output 15 This code block defines index as an int8 data type and bigIndex as an int32 data type. To store the value of index in bigIndex, it converts the data type to an int32. This is done by wrapping the int32() conversion around the index variable.\nTo verify your data types, you could use the fmt.Printf statement and the %T verb with the following syntax:\nfmt.Printf(\u0026#34;index data type: %T\\n\u0026#34;, index) fmt.Printf(\u0026#34;bigIndex data type: %T\\n\u0026#34;, bigIndex) Output index data type: int8 bigIndex data type: int32 Since this uses the %T verb, the print statement outputs the type for the variable, and not the actual value of the variable. This way, you can confirm the converted data type.\nYou can also convert from a larger bit-size integer to a smaller bit-size integer:\nvar big int64 = 64  var little int8  little = int8(big)  fmt.Println(little) Output 64 Keep in mind that when converting integers you could potentially exceed the maximum value of the data type and wraparound:\nvar big int64 = 129 var little = int8(big) fmt.Println(little) Output -127 A wraparound happens when the value is converted to a data type that is too small to hold it. In the preceding example, the 8-bit data type int8 did not have enough space to hold the 64-bit variable big. Care should always be taken when converting from a larger number data type to a smaller number data type so that you do not truncate the data by accident.\nConverting Integers to Floats #  Converting integers to floats in Go is similar to converting one integer type to another. You can use the built-in type conversions by wrapping float64() or float32() around the integer you are converting:\nvar x int64 = 57  var y float64 = float64(x)  fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, y) Output 57.00 This code declares a variable x of type int64 and initializes its value to 57.\nvar x int64 = 57 Wrapping the float64() conversion around x will convert the value of 57 to a float value of 57.00.\nvar y float64 = float64(x) The %.2f print verb tells fmt.Printf to format the float with two decimals.\nYou can also use this process on a variable. The following code declares f as equal to 57, and then prints out the new float:\nvar f float64 = 57 fmt.Printf(\u0026#34;%.2f\\n\u0026#34;, f) Output 57.00 By using either float32() or float64(), you can convert integers to floats. Next, you will learn how to convert floats to integers.\nConverting Floats to Integers #  Go can convert floats to integers, but the program will lose the precision of the float.\nWrapping floats in int(), or one of its architecture-independent data types, works similarly to when you used it to convert from one integer type to another. You can add a floating-point number inside of the parentheses to convert it to an integer:\nvar f float64 = 390.8 var i int = int(f)  fmt.Printf(\u0026#34;f = %.2f\\n\u0026#34;, f) fmt.Printf(\u0026#34;i = %d\\n\u0026#34;, i) Output f = 390.80 i = 390 This syntax would convert the float 390.8 to the integer 390, dropping the decimal place.\nYou can also use this with variables. The following code declares b as equal to 125.0 and c as equal to 390.8, then prints them out as integers. Short variable declaration (:=) shortens up the syntax:\nb := 125.0 c := 390.8  fmt.Println(int(b)) fmt.Println(int(c)) Output125 390 When converting floats to integers with the int() type, Go cuts off the decimal and remaining numbers of a float to create an integer. Note that, even though you may want to round 390.8 up to 391, Go will not do this through the int() type. Instead, it will drop the decimal.\nNumbers Converted Through Division #  When dividing integer types in Go the result will also be an integer type, with the modulus, or remainder, dropped:\na := 5 / 2 fmt.Println(a) Output 2 If, when dividing, any of the number types are a float, then all of the types will automatically be declared as a float:\n\ta := 5.0 / 2 \tfmt.Println(a) Output 2.5 This divides the float 5.0 by the integer 2, and the answer 2.5 is a float that retains the decimal precision.\nIn this section, you have converted between different number data types, including differing sizes of integers and floating-point numbers. Next, you will learn how to convert between numbers and strings.\nConverting with Strings #  A string is a sequence of one or more characters (letters, numbers, or symbols). Strings are a common form of data in computer programs, and you may need to convert strings to numbers or numbers to strings fairly often, especially when you are taking in user-generated data.\nConverting Numbers to Strings #  You can convert numbers to strings by using the strconv.Itoa method from the strconv package in the Go standard libary. If you pass either a number or a variable into the parentheses of the method, that numeric value will be converted into a string value.\nFirst, let’s look at converting integers. To convert the integer 12 to a string value, you can pass 12 into the strconv.Itoa method:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strconv\u0026#34; )  func main() { \ta := strconv.Itoa(12) \tfmt.Printf(\u0026#34;%q\\n\u0026#34;, a) } When running this program, you’ll receive the following output:\nOutput \u0026#34;12\u0026#34; The quotes around the number 12 signify that the number is no longer an integer but is now a string value.\nYou used the := assignment operator to both declare a new variable with the name of a and assign the value returned from the strconv.Itoa() function. In this case, you assigned the value 12 to your variable. You also used the %q verb in the fmt.Printf function, which tells the function to quote the string provided.\nWith variables you can begin to see how practical it can be to convert integers to strings. Say you want to keep track of a user’s daily programming progress and are inputting how many lines of code they write at a time. You would like to show this feedback to the user and will be printing out string and integer values at the same time:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tuser := \u0026#34;Sammy\u0026#34; \tlines := 50  \tfmt.Println(\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34; + lines + \u0026#34; lines of code.\u0026#34;) } When you run this code, you’ll receive the following error:\nOutput invalid operation: (\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34;) + lines (mismatched types string and int) You’re not able to concatenate strings and integers in Go, so you’ll have to convert the variable lines to be a string value:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { user := \u0026#34;Sammy\u0026#34; lines := 50 fmt.Println(\u0026#34;Congratulations, \u0026#34; + user + \u0026#34;! You just wrote \u0026#34; + strconv.Itoa(lines) + \u0026#34; lines of code.\u0026#34;) } Now, when you run the code, you’ll receive the following output that congratulates your user on their progress:\nOutput Congratulations, Sammy! You just wrote 50 lines of code. If you are looking to convert a float to a string rather than an integer to a string, you follow similar steps and format. When you pass a float into the fmt.Sprint method, from the fmt package in the Go standard library, a string value of the float will be returned. You can use either the float value itself or a variable:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tfmt.Println(fmt.Sprint(421.034))  \tf := 5524.53 \tfmt.Println(fmt.Sprint(f)) } Output 421.034 5524.53 You can test to make sure it’s right by concatenating with a string:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tf := 5524.53 \tfmt.Println(\u0026#34;Sammy has \u0026#34; + fmt.Sprint(f) + \u0026#34; points.\u0026#34;) } Output Sammy has 5524.53 points. You can be sure your float was properly converted to a string because the concatenation was performed without error.\nConverting Strings to Numbers #  Strings can be converted to numbers by using the strconv package in the Go standard library. The strconv package has functions for converting both integer and float number types. This is a very common operation when accepting input from the user. For example, if you had a program that asked for a person’s age, when they type the response in, it is captured as a string. You would then need to convert it to an int to do any math with it.\nIf your string does not have decimal places, you’ll most likely want to convert it to an integer by using the strconv.Atoi function. If you know you will use the number as a float, you would use strconv.ParseFloat.\nLet’s use the example of the user Sammy keeping track of lines of code written each day. You may want to manipulate those values with math to provide more interesting feedback for the user, but those values are currently stored in strings:\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tlines_yesterday := \u0026#34;50\u0026#34; \tlines_today := \u0026#34;108\u0026#34;  \tlines_more := lines_today - lines_yesterday  \tfmt.Println(lines_more) } Output invalid operation: lines_today - lines_yesterday (operator - not defined on string) Because the two numeric values were stored in strings, you received an error. The operand - for subtraction is not a valid operand for two string values.\nModify the code to include the strconv.Atoi() method that will convert the strings to integers, which will allow you to do math with values that were originally strings. Because there is a potential to fail when converting a string to an integer, you have to check for any errors. You can use an if statement to check if your conversion was successful.\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; ) func main() { lines_yesterday := \u0026#34;50\u0026#34; lines_today := \u0026#34;108\u0026#34; yesterday, err := strconv.Atoi(lines_yesterday) if err != nil { log.Fatal(err) } today, err := strconv.Atoi(lines_today) if err != nil { log.Fatal(err) } lines_more := today - yesterday fmt.Println(lines_more) } Because it is possible for a string to not be a number, the strconv.Atoi() method will return both the converted type, as well as a potential error. When converting from lines_yesterday with the strconv.Atoi function, you have to check the err return value to ensure that the value was converted. If the err is not nil, it means that strconv.Atoi was unable to successfully convert the string value to an integer. In this example, you used an if statement to check for the error, and if an error was returned, you used log.Fatal to log the error and exit the program.\nWhen you run the preceding code, you will get:\nOutput 58 Now try to convert a string that is not a number:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strconv\u0026#34; )  func main() { \ta := \u0026#34;not a number\u0026#34; \tb, err := strconv.Atoi(a) \tfmt.Println(b) \tfmt.Println(err) } You will get the following error:\nOutput 0 strconv.Atoi: parsing \u0026#34;not a number\u0026#34;: invalid syntax Because b was declared, but strconv.Atoi failed to make a conversion, a value was never assigned to b. Notice that b has the value of 0. This is because Go has default values, referred to as zero values in Go. strconv.Atoi provides an error describing why it failed to convert the string as well.\nConverting Strings and Bytes #  Strings in Go are stored as a slice of bytes. In Go, you can convert between a slice of bytes and a string by wrapping it in the corresponding conversions of []byte() and string():\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \ta := \u0026#34;my string\u0026#34;  \tb := []byte(a)  \tc := string(b)  \tfmt.Println(a)  \tfmt.Println(b)  \tfmt.Println(c) } Here you have stored a string value in a, then converted it to a slice of bytes b, then converted the slice of bytes back to a string as c. You then print a, b, and c to the screen:\nOutput my string [109 121 32 115 116 114 105 110 103] my string The first line of output is the original string my string. The second line printed out is the byte slice that makes up the original string. The third line shows that the byte slice can be safely converted back into a string and printed back out.\nConclusion #  This Go tutorial demonstrated how to convert several of the important native data types to other data types, primarily through built-in methods. Being able to convert data types in Go will allow you to do things like accept user input and do math across different number types. Later on, when you are using Go to write programs that accept data from many different sources like databases and APIs, you will use these conversion methods to ensure you can act on your data. You will also be able to optimize storage by converting data to smaller data types.\nIf you would like a deeper analysis of data types in Go, check out our Understanding Data Types in Go article.\n"},{"id":12,"href":"/docs/13-How_To_Do_Math_in_Go_with_Operators/","title":"13 How to Do Math in Go With Operators","section":"Docs","content":"How To Do Math in Go with Operators #  Introduction #  Numbers are common in programming. They are used to represent things such as: screen-size dimensions, geographic locations, money and points, the amount of time that passes in a video, positions of game avatars, colors through assigning numeric codes, and so on.\nEffectively performing mathematical operations in programming is an important skill to develop because of how frequently you’ll work with numbers. Though a high-level understanding of mathematics can certainly help you become a better programmer, it is not a prerequisite. If you don’t have a background in mathematics, try to think of math as a tool to accomplish what you would like to achieve, and as a way to improve your logical thinking.\nWe’ll be working with two of Go’s most used numeric data types, integers and floats:\n Integers are whole numbers that can be positive, negative, or 0 (…, -1, 0, 1, …). Floats are real numbers that contain a decimal point, like 9.0 or -2.25…  This tutorial will review operators that we can use with number data types in Go.\nOperators #  An operator is a symbol or function that indicates an operation. For example, in math the plus sign or + is the operator that indicates addition.\nIn Go, we will see some familiar operators that are brought over from math. However, other operators we will use are specific to computer programming.\nHere is a quick reference table of math-related operators in Go. We’ll be covering all of the following operations in this tutorial.\nOperation What it returns\nx + y Sum of x and y\nx - y Difference of x and y\n-x Changed sign of x\n+x Identity of x\nx * y Product of x and y\nx / y Quotient of x and y\nx % y Remainder of x / y\nWe’ll also be covering compound assignment operators, including += and *=, that combine an arithmetic operator with the = operator.\nAddition and Subtraction #  In Go, addition and subtraction operators perform just as they do in mathematics. In fact, you can use the Go programming language as a calculator.\nLet’s look at some examples, starting with integers:\nfmt.Println(1 + 5) Output 6 Instead of passing integers directly into the fmt.Println statement, we can initialize variables to stand for integer values by using syntax like the following:\na := 88 b := 103  fmt.Println(a + b) Output 191 Because integers can be both positive and negative numbers (and 0 too), we can add a negative number with a positive number:\nc := -36 d := 25  fmt.Println(c + d) Output -11 Addition will behave similarly with floats:\ne := 5.5 f := 2.5  fmt.Println(e + f) Output 8 Because we added two floats together, Go returned a float value with a decimal place. However, since the decimal place is zero in this case, fmt.Println dropped the decimal formatting. To properly format the output, we can use fmt.Printf and the verb %.2f, which will format to two decimal places, like this example:\nfmt.Printf(\u0026#34;%.2f\u0026#34;, e + f) Output 8.00 The syntax for subtraction is the same as for addition, except we change our operator from the plus sign (+) to the minus sign (-):\ng := 75.67 h := 32.0  fmt.Println(g - h) Output 43.67 In Go, we can only use operators on the same data types. We can’t add an int and a float64:\ni := 7 j := 7.0 fmt.Println(i + j) Output i + j (mismatched types int and float64) Trying to use operators on data types that are not the same will result in a compiler error.\nUnary Arithmetic Operations #  A unary mathematical expression consists of only one component or element. In Go we can use the plus and minus signs as a single element paired with a value to: return the value’s identity (+), or change the sign of the value (-).\nThough not commonly used, the plus sign indicates the identity of the value. We can use the plus sign with positive values:\ni := 3.3 fmt.Println(+i) Output 3.3 When we use the plus sign with a negative value, it will also return the identity of that value, and in this case it would be a negative value:\nj := -19 fmt.Println(+j) Output -19 With a negative value the plus sign returns the same negative value.\nThe minus sign, however, changes the sign of a value. So, when we pass a positive value we’ll find that the minus sign before the value will return a negative value:\nk := 3.3 fmt.Println(-k) Output -3.3 Alternatively, when we use the minus sign unary operator with a negative value, a positive value will be returned:\nj := -19 fmt.Println(-j) Output 19 The unary arithmetic operations indicated by the plus sign and minus sign will return either the value’s identity in the case of +i, or the opposite sign of the value as in -i.\nMultiplication and Division #  Like addition and subtraction, multiplication and division will look very similar to how they do in mathematics. The sign we’ll use in Go for multiplication is * and the sign we’ll use for division is /.\nHere’s an example of doing multiplication in Go with two float values:\nk := 100.2 l := 10.2  fmt.Println(k * l) Output 1022.04 In Go, division has different characteristics depending on the numeric type we’re dividing.\nIf we’re dividing integers, Go’s / operator performs floor division, where for the quotient x the number returned is the largest integer less than or equal to x.\nIf you run the following example of dividing 80 / 6, you’ll receive 13 as the output and the data type will be int:\npackage main  import (  \u0026#34;fmt\u0026#34; )  func main() {  m := 80  n := 6   fmt.Println(m / n) } Output 13 If the desired output is a float, you have to explicitly convert the values before dividing.\nYou can do this by wrapping your desired float type of float32() or float64() around your values:\npackage main  import (  \u0026#34;fmt\u0026#34; )  func main() {  s := 80  t := 6  r := float64(s) / float64(t)  fmt.Println(r) } Output 13.333333333333334 Modulo #  The % operator is the modulo, which returns the remainder rather than the quotient after division. This is useful for finding numbers that are multiples of the same number.\nLet’s look at an example of the modulo:\no := 85 p := 15  fmt.Println(o % p) Output 10 To break this down, 85 divided by 15 returns the quotient of 5 with a remainder of 10. Our program returns the value 10 here, because the modulo operator returns the remainder of a division expression.\nTo do modulus math with float64 data types, you’ll use the Mod function from the math package:\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;math\u0026#34; )  func main() {  q := 36.0  r := 8.0  s := math.Mod(q, r)   fmt.Println(s) } Output 4 Operator Precedence #  In Go, as in mathematics, we need to keep in mind that operators will be evaluated in order of precedence, not from left to right or right to left.\nIf we look at the following mathematical expression:\nu = 10 + 10 * 5 We may read it left to right, but multiplication will be done first, so if we were to print u, we would receive the following value:\nOutput 60 This is because 10 * 5 evaluates to 50, and then we add 10 to return 60 as the final result.\nIf instead we would like to add the value 10 to 10, then multiply that sum by 5, we use parentheses in Go just like we would in math:\nu := (10 + 10) * 5 fmt.Println(u) Output 100 One way to remember the order of operation is through the acronym PEMDAS:\nOrder Letter Stands for\n1 P Parentheses\n2 E Exponent\n3 M Multiplication\n4 D Division\n5 A Addition\n6 S Subtraction\nYou may be familiar with another acronym for the order of operations, such as BEDMAS or BODMAS. Whatever acronym works best for you, try to keep it in mind when performing math operations in Go so that the results that you expect are returned.\nAssignment Operators #  The most common assignment operator is one you have already used: the equals sign =. The = assignment operator assigns the value on the right to a variable on the left. For example, v = 23 assigns the value of the integer 23 to the variable v.\nWhen programming, it is common to use compound assignment operators that perform an operation on a variable’s value and then assign the resulting new value to that variable. These compound operators combine an arithmetic operator with the = operator. Therefore, for addition we’ll combine + with = to get the compound operator +=. Let’s see what that looks like:\nw := 5 w += 1 fmt.Println(w) Output 6 First, we set the variable w equal to the value of 5, then we use the += compound assignment operator to add the right number to the value of the left variable, and then assign the result to w.\nCompound assignment operators are used frequently in the case of for loops, which you’ll use when you want to repeat a process several times:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {   values := []int{0, 1, 2, 3, 4, 5, 6}   for _, x := range values {   w := x   w *= 2   fmt.Println(w)  }  } Output0 2 4 6 8 10 12 By using a for loop to iterate over the slice called values, you were able to automate the process of the *= operator that multiplied the variable w by the number 2 and then assigned the result back into the variable w.\nGo has a compound assignment operator for each of the arithmetic operators discussed in this tutorial.\nTo add then assign the value:\ny += 1 To subtract then assign the value:\ny -= 1 To multiply then assign then value:\ny *= 2 To divide then assign the value:\ny /= 3 To return the remainder then assign the value:\ny %= 3 Compound assignment operators can be useful when things need to be incrementally increased or decreased, or when you need to automate certain processes in your program.\nConclusion #  This tutorial covered many of the operators you’ll use with the integer and float numeric data types. You can learn more about different data types in Understanding Data Types in Go and How To Convert Data Types.\n"},{"id":13,"href":"/docs/14-Understanding_Boolean_Logic_in_Go/","title":"14 Understanding Boolean Logic in Go","section":"Docs","content":"Understanding Boolean Logic in Go #  The Boolean data type (bool) can be one of two values, either true or false. Booleans are used in programming to make comparisons and to control the flow of the program.\nBooleans represent the truth values that are associated with the logic branch of mathematics, which informs algorithms in computer science. Named for the mathematician George Boole, the word Boolean always begins with a capitalized B.\nThe data type in Go for Boolean is bool, all lowercase. The values true and false will always be with a lowercase t and f respectively, as they are special values in Go.\nThis tutorial will cover the basics you’ll need to understand how the bool data type works, including Boolean comparison, logical operators, and truth tables.\nComparison Operators #  In programming, comparison operators are used to compare values and evaluate down to a single Boolean value of either true or false.\nThe table below shows Boolean comparison operators.\nOperator What it means\n== Equal to\n!= Not equal to\n\u0026lt; Less than\n\u0026gt; Greater than\n\u0026lt;= Less than or equal to\n\u0026gt;= Greater than or equal to\nTo understand how these operators work, let’s assign two integers to two variables in a Go program:\nx := 5 y := 8 In this example, since x has the value of 5, it is less than y which has the value of 8.\nUsing those two variables and their associated values, let’s go through the operators from the preceding table. In this program, you’ll ask Go to print out whether each comparison operator evaluates to either true or false. To help better understand this output, you’ll have Go also print a string to show you what it’s evaluating:\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  x := 5  y := 8   fmt.Println(\u0026#34;x == y:\u0026#34;, x == y)  fmt.Println(\u0026#34;x != y:\u0026#34;, x != y)  fmt.Println(\u0026#34;x \u0026lt; y:\u0026#34;, x \u0026lt; y)  fmt.Println(\u0026#34;x \u0026gt; y:\u0026#34;, x \u0026gt; y)  fmt.Println(\u0026#34;x \u0026lt;= y:\u0026#34;, x \u0026lt;= y)  fmt.Println(\u0026#34;x \u0026gt;= y:\u0026#34;, x \u0026gt;= y) } Output x == y: false x != y: true x \u0026lt; y: true x \u0026gt; y: false x \u0026lt;= y: true x \u0026gt;= y: false Following mathematical logic, Go has evaluated the following from the expressions:\n Is 5 (x) equal to 8 (y)? false Is 5 not equal to 8? true Is 5 less than 8? true Is 5 greater than 8? false Is 5 less than or equal to 8? true Is 5 not less than or equal to 8? false  Although integers were used here, you could substitute them with float values.\nStrings can also be used with Boolean operators. They are case-sensitive unless you use an additional string method.\nYou can look at how strings are compared in practice:\nSammy := \u0026#34;Sammy\u0026#34; sammy := \u0026#34;sammy\u0026#34;  fmt.Println(\u0026#34;Sammy == sammy: \u0026#34;, Sammy == sammy) Output Sammy == sammy: false The string Sammy is not equal to the string sammy, because they are not exactly the same; one starts with an uppercase S and the other with a lowercase s. But, if you add another variable that is assigned the value of Sammy, then they will evaluate to equal:\nSammy := \u0026#34;Sammy\u0026#34; sammy := \u0026#34;sammy\u0026#34; alsoSammy := \u0026#34;Sammy\u0026#34;  fmt.Println(\u0026#34;Sammy == sammy: \u0026#34;, Sammy == sammy) fmt.Println(\u0026#34;Sammy == alsoSammy\u0026#34;, Sammy == alsoSammy) Output Sammy == sammy: false Sammy == alsoSammy true You can also use the other comparison operators including \u0026gt; and \u0026lt; to compare two strings. Go will compare these strings lexicographically using the ASCII values of the characters.\nYou can also evaluate Boolean values with comparison operators:\nt := true f := false  fmt.Println(\u0026#34;t != f: \u0026#34;, t != f) Output t != f: true The preceding code block evaluated that true is not equal to false.\nNote the difference between the two operators = and ==.\nx = y // Sets x equal to y x == y // Evaluates whether x is equal to y The first = is the assignment operator, which will set one value equal to another. The second, ==, is a comparison operator and will evaluate whether two values are equal.\nLogical Operators #  There are two logical operators that are used to compare values. They evaluate expressions down to Boolean values, returning either true or false. These operators are \u0026amp;\u0026amp;, ||, and !, and are defined in the list below:\n \u0026amp;\u0026amp; (x \u0026amp;\u0026amp; y) is the and operator. It is true if both statements are true. || (x || y) is the or operator. It is true if at least one statement is true. ! (!x) is the not operator. It is true only if the statement is false.  Logical operators are typically used to evaluate whether two or more expressions are true or not true. For example, they can be used to determine if the grade is passing and that the student is registered in the course, and if both cases are true, then the student will be assigned a grade in the system. Another example would be to determine whether a user is a valid active customer of an online shop based on whether they have store credit or have made a purchase in the past 6 months.\nTo understand how logical operators work, let’s evaluate three expressions:\nfmt.Println((9 \u0026gt; 7) \u0026amp;\u0026amp; (2 \u0026lt; 4)) // Both original expressions are true fmt.Println((8 == 8) || (6 != 6)) // One original expression is true fmt.Println(!(3 \u0026lt;= 1)) // The original expression is false Output true true true In the first case, fmt.Println((9 \u0026gt; 7) \u0026amp;\u0026amp; (2 \u0026lt; 4)), both 9 \u0026gt; 7 and 2 \u0026lt; 4 needed to evaluate to true since the and operator was used.\nIn the second case, fmt.Println((8 == 8) || (6 != 6)), since 8 == 8 evaluated to true, it did not make a difference that 6 != 6 evaluates to false because the or operator was used. If you had used the and operator, this would evaluate to false.\nIn the third case, fmt.Println(!(3 \u0026lt;= 1)), the not operator negates the false value that 3 \u0026lt;=1 returns.\nLet’s substitute floats for integers and aim for false evaluations:\nfmt.Println((-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; (0.8 \u0026lt; 3.1)) // One original expression is false fmt.Println((7.5 == 8.9) || (9.2 != 9.2)) // Both original expressions are false fmt.Println(!(-5.7 \u0026lt;= 0.3)) // The original expression is true In this example:\n and must have at least one false expression evaluate to false. or must have both expressions evaluate to false. ! must have its inner expression be true for the new expression to evaluate to false.  If these results seem unclear to you, go through some truth tables for further clarification.\nYou can also write compound statements using \u0026amp;\u0026amp;, ||, and !:\n!((-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; ((0.8 \u0026lt; 3.1) || (0.1 == 0.1))) Take a look at the inner-most expression first: (0.8 \u0026lt; 3.1) || (0.1 == 0.1). This expression evaluates to true because both mathematical statements are true.\nNext, Go takes the returned value true and combines it with the next inner expression: (-0.2 \u0026gt; 1.4) \u0026amp;\u0026amp; (true). This example returns false because the mathematical statement -0.2 \u0026gt; 1.4 is false, and (false) and (true) returns false.\nFinally, we have the outer expression: !(false), which evaluates to true, so the final returned value if we print this statement out is:\nOutput true The logical operators \u0026amp;\u0026amp;, ||, and ! evaluate expressions and return Boolean values.\nTruth Tables #  There is a lot to learn about the logic branch of mathematics, but you can selectively learn some of it to improve your algorithmic thinking when programming.\nThe following are truth tables for the comparison operator ==, and each of the logic operators \u0026amp;\u0026amp;, || and !. While you may be able to reason them out, it can also be helpful to memorize them as that can make your programming decision-making process quicker.\n== (equal) Truth Table\nx == y Returns\ntrue == true true\ntrue == false false\nfalse == true false\nfalse == false true\n\u0026amp;\u0026amp; (and) Truth Table\nx and y Returns\ntrue and true true\ntrue and false false\nfalse and true false\nfalse and false false\n|| (or) Truth Table\nx or y Returns\ntrue or true true\ntrue or false true\nfalse or true true\nfalse or false false\n! (not) Truth Table\n| not | x | Returns | | — | — | — | — | | not | true | false | | not | false | true |\nTruth tables are common mathematical tables used in logic, and are useful to keep in mind when constructing algorithms (instructions) in computer programming.\nUsing Boolean Operators for Flow Control #  To control the stream and outcomes of a program in the form of flow control statements, you can use a condition followed by a clause.\nA condition evaluates down to a Boolean value of true or false, presenting a point where a decision is made in the program. That is, a condition would tell you if something evaluates to true or false.\nThe clause is the block of code that follows the condition and dictates the outcome of the program. That is, it is the “do this” part of the construction “If x is true, then do this.”\nThe code block below shows an example of comparison operators working in tandem with conditional statements to control the flow of a Go program:\nif grade \u0026gt;= 65 { // Condition  fmt.Println(\u0026#34;Passing grade\u0026#34;) // Clause } else {  fmt.Println(\u0026#34;Failing grade\u0026#34;) } This program will evaluate whether each student’s grade is passing or failing. In the case of a student with a grade of 83, the first statement will evaluate to true, and the print statement of Passing grade will be triggered. In the case of a student with a grade of 59, the first statement will evaluate to false, so the program will move on to execute the print statement tied to the else expression: Failing grade.\nBoolean operators present conditions that can be used to decide the eventual outcome of a program through flow control statements.\nConclusion #  This tutorial went through comparison and logical operators belonging to the Boolean type, as well as truth tables and using Booleans for program flow control.\n"},{"id":14,"href":"/docs/15-Understanding_Maps_in_Go/","title":"15 Understanding Maps in Go","section":"Docs","content":"Understanding Maps in Go #  Most modern programming languages have the concept of a dictionary or a hash type. These types are commonly used to store data in pairs with a key that maps to a value.\nIn Go, the map data type is what most programmers would think of as the dictionary type. It maps keys to values, making key-value pairs that are a useful way to store data in Go. A map is constructed by using the keyword map followed by the key data type in square brackets [ ], followed by the value data type. The key-value pairs are then placed inside curly braces on either side { }:\nmap[key]value{} You typically use maps in Go to hold related data, such as the information contained in an ID. A map with data looks like this:\nmap[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} In addition to the curly braces, there are also colons throughout the map that connect the key-value pairs. The words to the left of the colons are the keys. Keys can be any comparable type in Go, like strings, ints, and so on.\nThe keys in the example map are:\n \u0026quot;name\u0026quot; \u0026quot;animal\u0026quot; \u0026quot;color\u0026quot; \u0026quot;location\u0026quot;  The words to the right of the colons are the values. Values can be any data type. The values in the example map are:\n \u0026quot;Sammy\u0026quot; \u0026quot;shark\u0026quot; \u0026quot;blue\u0026quot; \u0026quot;ocean\u0026quot;  Like the other data types, you can store the map inside a variable, and print it out:\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(sammy) This would be your output:\nOutput map[animal:shark color:blue location:ocean name:Sammy] The order of the key-value pairs may have shifted. In Go, the map data type is unordered. Regardless of the order, the key-value pairs will remain intact, enabling you to access data based on their relational meaning.\nAccessing Map Items #  You can call the values of a map by referencing the related keys. Since maps offer key-value pairs for storing data, they can be important and useful items in your Go program.\nIf you want to isolate Sammy’s username, you can do so by calling sammy[\u0026quot;name\u0026quot;]; the variable holding your map and the related key. Let’s print that out:\nfmt.Println(sammy[\u0026#34;name\u0026#34;]) And receive the value as output:\nOutput Sammy Maps behave like a database; instead of calling an integer to get a particular index value as you would with a slice, you assign a value to a key and call that key to get its related value.\nBy invoking the key \u0026quot;name\u0026quot; you receive the value of that key, which is \u0026quot;Sammy\u0026quot;.\nSimilarly you can call the remaining values in the sammy map using the same format:\nfmt.Println(sammy[\u0026#34;animal\u0026#34;]) // returns shark  fmt.Println(sammy[\u0026#34;color\u0026#34;]) // returns blue  fmt.Println(sammy[\u0026#34;location\u0026#34;]) // returns ocean By making use of the key-value pairs in map data types, you can reference keys to retrieve values.\nKeys and Values #  Unlike some programming languages, Go does not have any convenience functions to list out the keys or values of a map. An example of this would be Python’s .keys() method for dictionaries. It does, however, allow for iteration by using the range operator:\nfor key, value := range sammy {  fmt.Printf(\u0026#34;%q is the key for the value %q\\n\u0026#34;, key, value) } When ranging through a map in Go, it’ll return two values. The first value will be the key, and the second value will be the value. Go will create these variables with the correct data type. In this case, the map key was a string so key will also be a string. The value is also a string:\nOutput animal\u0026#34; is the key for the value \u0026#34;shark\u0026#34; \u0026#34;color\u0026#34; is the key for the value \u0026#34;blue\u0026#34; \u0026#34;location\u0026#34; is the key for the value \u0026#34;ocean\u0026#34; \u0026#34;name\u0026#34; is the key for the value \u0026#34;Sammy\u0026#34; To get a list of just the keys, you can use the range operator again. You can declare just one variable to only access the keys:\nkeys := []string{}  for key := range sammy {  keys = append(keys, key) } fmt.Printf(\u0026#34;%q\u0026#34;, keys) The program begins by declaring a slice to store your keys in.\nThe output will show only the keys of your map:\nOutput [\u0026#34;color\u0026#34; \u0026#34;location\u0026#34; \u0026#34;name\u0026#34; \u0026#34;animal\u0026#34;] Again, the keys are not sorted. If you want to sort them, you use the sort.Strings function from the sort package:\nsort.Strings(keys) With this function, you’ll receive the following output:\nOutput [\u0026#34;animal\u0026#34; \u0026#34;color\u0026#34; \u0026#34;location\u0026#34; \u0026#34;name\u0026#34;] You can use the same pattern to retrieve just the values in a map. In the next example, you pre-allocate the slice to avoid allocations, thus making the program more efficient:\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;}  items := make([]string, len(sammy))  var i int  for _, v := range sammy {  items[i] = v  i++ } fmt.Printf(\u0026#34;%q\u0026#34;, items) First you declare a slice to store your keys in; since you know how many items you need, you can avoid potential memory allocations by defining the slice at the exact same size. You then declare your index variable. As you don’t want the key, you use the _ operator, when starting your loop, to ignore the key’s value. Your output would be the following:\nOutput [\u0026#34;ocean\u0026#34; \u0026#34;Sammy\u0026#34; \u0026#34;shark\u0026#34; \u0026#34;blue\u0026#34;] To determine the number of items in a map, you can use the built-in len function:\nsammy := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;} fmt.Println(len(sammy)) The output displays the number of items in your map:\nOutput 4 Even though Go doesn’t ship with convenience functions to get keys and values, it only takes a few lines of code to retrieve the keys and values when needed.\nChecking Existence #  Maps in Go will return the zero value for the value type of the map when the requested key is missing. Because of this, you need an alternative way to differentiate a stored zero, versus a missing key.\nLet’s look up a value in a map that you know doesn’t exist and look at the value returned:\ncounts := map[string]int{} fmt.Println(counts[\u0026#34;sammy\u0026#34;]) You’ll see the following output:\nOutput 0 Even though the key sammy was not in the map, Go still returned the value of 0. This is because the value data type is an int, and because Go has a zero value for all variables, it returns the zero value of 0.\nIn many cases, this is undesirable and would lead to a bug in your program. When looking up the value in a map, Go can return a second, optional value. This second value is a bool and will be true if the key was found, or false if the key was not found. In Go, this is referred to as the ok idiom. Even though you could name the variable that captures the second argument anything you want, in Go, you always name it ok:\ncount, ok := counts[\u0026#34;sammy\u0026#34;] If the key sammy exists in the counts map, then ok will be true. Otherwise ok will be false.\nYou can use the ok variable to decide what to do in your program:\nif ok {  fmt.Printf(\u0026#34;Sammy has a count of %d\\n\u0026#34;, count) } else {  fmt.Println(\u0026#34;Sammy was not found\u0026#34;) } This would result in the following output:\nOutput Sammy was not found In Go, you can combine variable declaration and conditional checking with an if/else block. This allows you to use a single statement for this check:\nif count, ok := counts[\u0026#34;sammy\u0026#34;]; ok {  fmt.Printf(\u0026#34;Sammy has a count of %d\\n\u0026#34;, count) } else {  fmt.Println(\u0026#34;Sammy was not found\u0026#34;) } When retrieving a value from a map in Go, it’s always good practice to check for its existence as well to avoid bugs in your program.\nModifying Maps #  Maps are a mutable data structure, so you can modify them. Let’s look at adding and deleting map items in this section.\nAdding and Changing Map Items #  Without using a method or function, you can add key-value pairs to maps. You do this using the maps variable name, followed by the key value in square brackets [ ], and using the equal = operator to set a new value:\nmap[key] = value In practice, you can see this work by adding a key-value pair to a map called usernames:\nusernames := map[string]string{\u0026#34;Sammy\u0026#34;: \u0026#34;sammy-shark\u0026#34;, \u0026#34;Jamie\u0026#34;: \u0026#34;mantisshrimp54\u0026#34;}  usernames[\u0026#34;Drew\u0026#34;] = \u0026#34;squidly\u0026#34; fmt.Println(usernames) The output will display the new Drew:squidly key-value pair in the map:\nOutput map[Drew:squidly Jamie:mantisshrimp54 Sammy:sammy-shark] Because maps are returned unordered, this pair may occur anywhere in the map output. If you use the usernames map later in your program file, it will include the additional key-value pair.\nYou can also use this syntax for modifying the value assigned to a key. In this case, you reference an existing key and pass a different value to it.\nConsider a map called followers that tracks followers of users on a given network. The user \u0026quot;drew\u0026quot; had a bump in followers today, so you need to update the integer value passed to the \u0026quot;drew\u0026quot; key. You’ll use the Println() function to check that the map was modified:\nfollowers := map[string]int{\u0026#34;drew\u0026#34;: 305, \u0026#34;mary\u0026#34;: 428, \u0026#34;cindy\u0026#34;: 918} followers[\u0026#34;drew\u0026#34;] = 342 fmt.Println(followers) Your output will show the updated value for drew:\nOutput map[cindy:918 drew:342 mary:428] You see that the number of followers jumped from the integer value of 305 to 342.\nYou can use this method for adding key-value pairs to maps with user input. Let’s write a quick program called usernames.go that runs on the command line and allows input from the user to add more names and associated usernames:\nusernames.go\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;strings\u0026#34; )  func main() {  usernames := map[string]string{\u0026#34;Sammy\u0026#34;: \u0026#34;sammy-shark\u0026#34;, \u0026#34;Jamie\u0026#34;: \u0026#34;mantisshrimp54\u0026#34;}   for {  fmt.Println(\u0026#34;Enter a name:\u0026#34;)   var name string  _, err := fmt.Scanln(\u0026amp;name)   if err != nil {  panic(err)  }   name = strings.TrimSpace(name)   if u, ok := usernames[name]; ok {  fmt.Printf(\u0026#34;%q is the username of %q\\n\u0026#34;, u, name)  continue  }   fmt.Printf(\u0026#34;I don\u0026#39;t have %v\u0026#39;s username, what is it?\\n\u0026#34;, name)   var username string  _, err = fmt.Scanln(\u0026amp;username)   if err != nil {  panic(err)  }   username = strings.TrimSpace(username)   usernames[name] = username   fmt.Println(\u0026#34;Data updated.\u0026#34;)  } } In usernames.go you first define the original map. You then set up a loop to iterate over the names. You request your user to enter a name and declare a variable to store it in. Next, you check to see if you had an error; if so, the program will exit with a panic. Because Scanln captures the entire input, including the carriage return, you need to remove any space from the input; you do this with the strings.TrimSpace function.\nThe if block checks whether the name is present in the map and prints feedback. If the name is present it then continues back to the top of the loop. If the name is not in the map, it provides feedback to the user and then will ask for a new username for the associated name. The program checks again to see if there is an error. With no error, it trims off the carriage return, assigns the username value to the name key, and then prints feedback that the data was updated.\nLet’s run the program on the command line:\ngo run usernames.go You’ll see the following output:\nOutput Enter a name: Sammy \u0026#34;sammy-shark\u0026#34; is the username of \u0026#34;Sammy\u0026#34; Enter a name: Jesse I don\u0026#39;t have Jesse\u0026#39;s username, what is it? JOctopus Data updated. Enter a name: When you’re done testing, press CTRL + C to escape the program.\nThis shows how you can modify maps interactively. With this particular program, as soon as you exit the program with CTRL + C you’ll lose all your data unless you implement a way to handle reading and writing files.\nTo summarize, you can add items to maps or modify values with the map[key] = value syntax.\nDeleting Map Items #  Just as you can add key-value pairs and change values within the map data type, you can also delete items within a map.\nTo remove a key-value pair from a map, you can use the built-in function delete(). The first argument is the map you are deleting from. The second argument is the key you are deleting:\ndelete(map, key) Let’s define a map of permissions:\npermissions := map[int]string{1: \u0026#34;read\u0026#34;, 2: \u0026#34;write\u0026#34;, 4: \u0026#34;delete\u0026#34;, 8: \u0026#34;create\u0026#34;, 16:\u0026#34;modify\u0026#34;} You no longer need the modify permission, so you’ll remove it from your map. Then you’ll print out the map to confirm it was removed:\npermissions := map[int]string{1: \u0026#34;read\u0026#34;, 2: \u0026#34;write\u0026#34;, 4: \u0026#34;delete\u0026#34;, 8: \u0026#34;create\u0026#34;, 16: \u0026#34;modify\u0026#34;} delete(permissions, 16) fmt.Println(permissions) The output will confirm the deletion:\nOutput map[1:read 2:write 4:delete 8:create] The line delete(permissions, 16) removes the key-value pair 16:\u0026quot;modify\u0026quot; from the permissions map.\nIf you would like to clear a map of all of its values, you can do so by setting it equal to an empty map of the same type. This will create a new empty map to use, and the old map will be cleared from memory by the garbage collector.\nLet’s remove all the items within the permissions map:\npermissions = map[int]string{} fmt.Println(permissions) The output shows that you now have an empty map devoid of key-value pairs:\nOutput map[] Because maps are mutable data types, they can be added to, modified, and have items removed and cleared.\nConclusion #  This tutorial explored the map data structure in Go. Maps are made up of key-value pairs and provide a way to store data without relying on indexing. This allows us to retrieve values based on their meaning and relation to other data types.\n"},{"id":15,"href":"/docs/16-Understanding_Arrays_and_Slices_in_Go/","title":"16 Understanding Arrays and Slices in Go","section":"Docs","content":"Understanding Arrays and Slices in Go #  Introduction #  In Go, arrays and slices are data structures that consist of an ordered sequence of elements. These data collections are great to use when you want to work with many related values. They enable you to keep data together that belongs together, condense your code, and perform the same methods and operations on multiple values at once.\nAlthough arrays and slices in Go are both ordered sequences of elements, there are significant differences between the two. An array in Go is a data structure that consists of an ordered sequence of elements that has its capacity defined at creation time. Once an array has allocated its size, the size can no longer be changed. A slice, on the other hand, is a variable length version of an array, providing more flexibility for developers using these data structures. Slices constitute what you would think of as arrays in other languages.\nGiven these differences, there are specific situations when you would use one over the other. If you are new to Go, determining when to use them can be confusing: Although the versatility of slices make them a more appropriate choice in most situations, there are specific instances in which arrays can optimize the performance of your program.\nThis article will cover arrays and slices in detail, which will provide you with the necessary information to make the appropriate choice when choosing between these data types. Furthermore, you’ll review the most common ways to declare and work with both arrays and slices. The tutorial will first provide a description of arrays and how to manipulate them, followed by an explanation of slices and how they differ.\nArrays #  Arrays are collection data structures with a set number of elements. Because the size of an array is static, the data structure only needs to allocate memory once, as opposed to a variable length data structure that must dynamically allocate memory so that it can become larger or smaller in the future. Although the fixed length of arrays can make them somewhat rigid to work with, the one-time memory allocation can increase the speed and performance of your program. Because of this, developers typically use arrays when optimizing programs in instances where the data structure will never need a variable amount of elements.\nDefining an Array #  Arrays are defined by declaring the size of the array in brackets [ ], followed by the data type of the elements. An array in Go must have all its elements be the same data type. After the data type, you can declare the individual values of the array elements in curly brackets { }.\nThe following is the general schema for declaring an array:\n[capacity]data_type{element_values} Note: It is important to remember that every declaration of a new array creates a distinct type. So, although [2]int and [3]int both have integer elements, their differing lengths make their data types incompatible.\nIf you do not declare the values of the array’s elements, the default is zero-valued, which means that the elements of the array will be empty. For integers, this is represented by 0, and for strings this is represented by an empty string.\nFor example, the following array numbers has three integer elements that do not yet have a value:\nvar numbers [3]int If you printed numbers, you would receive the following output:\nOutput [0 0 0] If you would like to assign the values of the elements when you create the array, place the values in curly brackets. An array of strings with set values looks like this:\n[4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} You can store an array in a variable and print it out:\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;staghorn coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} fmt.Println(coral) Running a program with the preceding lines would give you the following output:\nOutput [blue coral staghorn coral pillar coral elkhorn coral] Notice that there is no delineation between the elements in the array when it is printed, making it difficult to tell where one element ends and another begins. Because of this, it is sometimes helpful to use the fmt.Printf function instead, which can format strings before printing them to the screen. Provide the %q verb with this command to instruct the function to put quotation marks around the values:\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, coral) This will result in the following:\nOutput [\u0026#34;blue coral\u0026#34; \u0026#34;staghorn coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34;] Now each item is quoted. The \\n verb instructs to the formatter to add a line return at the end.\nWith a general idea of how to declare arrays and what they consist of, you can now move on to learning how to specify elements in an array with an index number.\nIndexing Arrays (and Slices) #  Each element in an array (and also a slice) can be called individually through indexing. Each element corresponds to an index number, which is an int value starting from the index number 0 and counting up.\nWe will use an array in the following examples, but you could use a slice as well, since they are identical in how you index both of them.\nFor the array coral, the index breakdown looks like this:\n“blue coral” “staghorn coral” “pillar coral” “elkhorn coral”\n0 1 2 3\nThe first element, the string \u0026quot;blue coral\u0026quot;, starts at index 0, and the slice ends at index 3 with the element \u0026quot;elkhorn coral\u0026quot;.\nBecause each element in a slice or array has a corresponding index number, we’re able to access and manipulate them in the same ways we can with other sequential data types.\nNow we can call a discrete element of the slice by referring to its index number:\nfmt.Println(coral[1]) Output staghorn coral The index numbers for this slice range from 0-3, as shown in the previous table. So to call any of the elements individually, we would refer to the index numbers like this:\ncoral[0] = \u0026#34;blue coral\u0026#34; coral[1] = \u0026#34;staghorn coral\u0026#34; coral[2] = \u0026#34;pillar coral\u0026#34; coral[3] = \u0026#34;elkhorn coral\u0026#34; If we call the array coral with an index number of any that is greater than 3, it will be out of range as it will not be valid:\nfmt.Println(coral[18]) Output panic: runtime error: index out of range When indexing an array or slice, you must always use a positive number. Unlike some languages that let you index backwards with a negative number, doing that in Go will result in an error:\nfmt.Println(coral[-1]) Output invalid array index -1 (index must be non-negative) We can concatenate string elements in an array or slice with other strings using the + operator:\nfmt.Println(\u0026#34;Sammy loves \u0026#34; + coral[0]) Output Sammy loves blue coral We were able to concatenate the string element at index number 0 with the string \u0026quot;Sammy loves \u0026quot;.\nWith index numbers that correspond to elements within an array or a slice, we’re able to access each element discretely and work with those elements. To demonstrate this, we will next look at how to modify an element at a certain index.\nModifying Elements #  We can use indexing to change elements within an array or slice by setting an index numbered element equal to a different value. This gives us greater control over the data in our slices and arrays, and will allow us to programmatically manipulate individual elements.\nIf we want to change the string value of the element at index 1 of the array coral from \u0026quot;staghorn coral\u0026quot; to \u0026quot;foliose coral\u0026quot;, we can do so like this:\ncoral[1] = \u0026#34;foliose coral\u0026#34; Now when we print coral, the array will be different:\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, coral) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34;] Now that you know how to manipulate individual elements of an array or a slice, let’s look at a couple of functions that will give you more flexibility when working with collection data types.\nCounting Elements with len() #  In Go, len() is a built-in function made to help you work with arrays and slices. Like with strings, you can calculate the length of an array or slice by using len() and passing in the array or slice as a parameter.\nFor example, to find how many elements are in the coral array, you would use:\nlen(coral) If you print out the length for the array coral, you’ll receive the following output:\nOutput 4 This gives the length of the array 4 in the int data type, which is correct because the array coral has four items:\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} If you create an array of integers with more elements, you could use the len() function on this as well:\nnumbers := [13]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12} fmt.Println(len(numbers)) This would result in the following output:\nOutput 13 Although these example arrays have relatively few items, the len() function is especially useful when determining how many elements are in very large arrays.\nNext, we will cover how to add an element to a collection data type, and demonstrate how, because of the fixed length of arrays, appending these static data types will result in an error.\nAppending Elements with append() #  append() is a built-in method in Go that adds elements to a collection data type. However, this method will not work when used with an array. As mentioned before, the primary way in which arrays are different from slices is that the size of an array cannot be modified. This means that while you can change the values of elements in an array, you can’t make the array larger or smaller after it has been defined.\nLet’s consider your coral array:\ncoral := [4]string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;} Say you want to add the item \u0026quot;black coral\u0026quot; to this array. If you try to use the append() function with the array by typing:\ncoral = append(coral, \u0026#34;black coral\u0026#34;) You will receive an error as your output:\nOutput first argument to append must be slice; have [4]string To fix this, let’s learn more about the slice data type, how to define a slice, and how to convert from an array to a slice.\nSlices #  A slice is a data type in Go that is a mutable, or changeable, ordered sequence of elements. Since the size of a slice is variable, there is a lot more flexibility when using them; when working with data collections that may need to expand or contract in the future, using a slice will ensure that your code does not run into errors when trying to manipulate the length of the collection. In most cases, this mutability is worth the possible memory re-allocation sometimes required by slices when compared to arrays. When you need to store a lot of elements or iterate over elements and you want to be able to readily modify those elements, you’ll likely want to work with the slice data type.\nDefining a Slice #  Slices are defined by declaring the data type preceded by an empty set of square brackets ([]) and a list of elements between curly brackets ({}). You’ll notice that, as opposed to arrays that require an int in between the brackets to declare a specific length, a slice has nothing between the brackets, representing its variable length.\nLet’s create a slice that contains elements of the string data type:\nseaCreatures := []string{\u0026#34;shark\u0026#34;, \u0026#34;cuttlefish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;, \u0026#34;anemone\u0026#34;} When we print out the slice, we can see the elements that are in the slice:\nfmt.Printf(\u0026#34;%q\\n\u0026#34;, seaCreatures) This will result in the following:\nOutput [\u0026#34;shark\u0026#34; \u0026#34;cuttlefish\u0026#34; \u0026#34;squid\u0026#34; \u0026#34;mantis shrimp\u0026#34; \u0026#34;anemone\u0026#34;] If you would like to create a slice of a certain length without populating the elements of the collection yet, you can use the built-in make() function:\noceans := make([]string, 3) If you printed this slice, you would get:\nOutput [\u0026#34;\u0026#34; \u0026#34;\u0026#34; \u0026#34;\u0026#34;] If you want to pre-allocate the memory for a certain capacity, you can pass in a third argument to make():\noceans := make([]string, 3, 5) This would make a zeroed slice with a length of 3 and a pre-allocated capacity of 5 elements.\nYou now know how to declare a slice. However, this does not yet solve the error we had with the coral array earlier. To use the append() function with coral, you will first have to learn how to slice out sections of an array.\nSlicing Arrays into Slices #  By using index numbers to determine beginning and endpoints, you can call a subsection of the values within an array. This is called slicing the array, and you can do this by creating a range of index numbers separated by a colon, in the form of [first_index:second_index]. It is important to note however, that when slicing an array, the result is a slice, not an array.\nLet’s say you would like to just print the middle items of the coral array, without the first and last element. You can do this by creating a slice starting at index 1 and ending just before index 3:\nfmt.Println(coral[1:3]) Running a program with this line would yield the following:\nOutput [foliose coral pillar coral] When creating a slice, as in [1:3], the first number is where the slice starts (inclusive), and the second number is the sum of the first number and the total number of elements you would like to retrieve:\narray[starting_index : (starting_index + length_of_slice)] In this instance, you called the second element (or index 1) as the starting point, and called two elements in total. This is how the calculation would look:\narray[1 : (1 + 2)] Which is how you arrived at this notation:\ncoral[1:3] If you want to set the beginning or end of the array as a starting or end point of the slice, you can omit one of the numbers in the array[first_index:second_index] syntax. For example, if you want to print the first three items of the array coral — which would be \u0026quot;blue coral\u0026quot;, \u0026quot;foliose coral\u0026quot;, and \u0026quot;pillar coral\u0026quot; — you can do so by typing:\nfmt.Println(coral[:3]) This will print:\nOutput [blue coral foliose coral pillar coral] This printed the beginning of the array, stopping right before index 3.\nTo include all the items at the end of an array, you would reverse the syntax:\nfmt.Println(coral[1:]) This would give the following slice:\nOutput [foliose coral pillar coral elkhorn coral] This section discussed calling individual parts of an array by slicing out subsections. Next, you’ll learn how to use slicing to convert entire arrays into slices.\nConverting from an Array to a Slice #  If you create an array and decide that you need it to have a variable length, you can convert it to a slice. To convert an array to a slice, use the slicing process you learned in the Slicing Arrays into Slices step of this tutorial, except this time select the entire slice by omitting both of the index numbers that would determine the endpoints:\ncoral[:] Keep in mind that you can’t convert the variable coral to a slice itself, since once a variable is defined in Go, its type can’t be changed. To work around this, you can copy the entire contents of the array into a new variable as a slice:\ncoralSlice := coral[:] If you printed coralSlice, you would receive the following output:\nOutput [blue coral foliose coral pillar coral elkhorn coral] Now, try to add the black coral element like in the array section, using append() with the newly converted slice:\ncoralSlice = append(coralSlice, \u0026#34;black coral\u0026#34;) fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) This will output the slice with the added element:\nOutput [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34;] We can also add more than one element in a single append() statement:\ncoralSlice = append(coralSlice, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34;] To combine two slices together, you can use append(), but you must expand the second argument to append using the ... expansion syntax:\nmoreCoral := []string{\u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;} coralSlice = append(coralSlice, moreCoral...) Output [\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;elkhorn coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] Now that you have learned how to append an element to your slice, we will take a look at how to remove one.\nRemoving an Element from a Slice #  Unlike other languages, Go does not provide any built-in functions to remove an element from a slice. Items need to be removed from a slice by slicing them out.\nTo remove an element, you must slice out the items before that element, slice out the items after that element, then append these two new slices together without the element that you wanted to remove.\nIf i is the index of the element to be removed, then the format of this process would look like the following:\nslice = append(slice[:i], slice[i+1:]...) From coralSlice, let’s remove the item \u0026quot;elkhorn coral\u0026quot;. This item is located at the index position of 3.\ncoralSlice := []string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;, \u0026#34;black coral\u0026#34;, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;, \u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;}  coralSlice = append(coralSlice[:3], coralSlice[4:]...)  fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) Output[\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;black coral\u0026#34; \u0026#34;antipathes\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] Now the element at index position 3, the string \u0026quot;elkhorn coral\u0026quot;, is no longer in our slice coralSlice.\nWe can also delete a range with the same approach. Say we wanted to remove not only the item \u0026quot;elkhorn coral\u0026quot;, but \u0026quot;black coral\u0026quot; and \u0026quot;antipathes\u0026quot; as well. We can use a range in the expression to accomplish this:\ncoralSlice := []string{\u0026#34;blue coral\u0026#34;, \u0026#34;foliose coral\u0026#34;, \u0026#34;pillar coral\u0026#34;, \u0026#34;elkhorn coral\u0026#34;, \u0026#34;black coral\u0026#34;, \u0026#34;antipathes\u0026#34;, \u0026#34;leptopsammia\u0026#34;, \u0026#34;massive coral\u0026#34;, \u0026#34;soft coral\u0026#34;}  coralSlice = append(coralSlice[:3], coralSlice[6:]...)  fmt.Printf(\u0026#34;%q\\n\u0026#34;, coralSlice) This code will take out index 3, 4, and 5 from the slice:\nOutput[\u0026#34;blue coral\u0026#34; \u0026#34;foliose coral\u0026#34; \u0026#34;pillar coral\u0026#34; \u0026#34;leptopsammia\u0026#34; \u0026#34;massive coral\u0026#34; \u0026#34;soft coral\u0026#34;] Now that you know how to add and remove elements from a slice, let’s look at how to measure the amount of data a slice can hold at any given time.\nMeasuring the Capacity of a Slice with cap() #  Since slices have a variable length, the len()method is not the best option to determine the size of this data type. Instead, you can use the cap() function to learn the capacity of a slice. This will show you how many elements a slice can hold, which is determined by how much memory has already been allocated for the slice.\nNote: Because the length and capacity of an array are always the same, the cap() function will not work on arrays.\nA common use for cap() is to create a slice with a preset number of elements and then fill in those elements programmatically. This avoids potential unnecessary allocations that could occur by using append() to add elements beyond the capacity currently allocated for.\nLet’s take the scenario where we want to make a list of numbers, 0 through 3. We can use append() in a loop to do so, or we can pre-allocate the slice first and use cap() to loop through to fill the values.\nFirst, we can look at using append():\nnumbers := []int{} for i := 0; i \u0026lt; 4; i++ {  numbers = append(numbers, i) } fmt.Println(numbers) Output [0 1 2 3] In this example, we created a slice, and then created a for loop that would iterate four times. Each iteration appended the current value of the loop variable i into the index of the numbers slice. However, this could lead to unnecessary memory allocations that could slow down your program. When adding to an empty slice, each time you make a call to append, the program checks the capacity of the slice. If the added element makes the slice exceed this capacity, the program will allocate additional memory to account for it. This creates additional overhead in your program and can result in a slower execution.\nNow let’s populate the slice without using append() by pre-allocating a certain length/capacity:\nnumbers := make([]int, 4) for i := 0; i \u0026lt; cap(numbers); i++ {  numbers[i] = i }  fmt.Println(numbers) Output [0 1 2 3] In this example, we used make() to create a slice and had it pre-allocate 4 elements. We then used the cap() function in the loop to iterate through each zeroed element, filling each until it reached the pre-allocated capacity. In each loop, we placed the current value of the loop variable i into the index of the numbers slice.\nWhile the append() and the cap() strategies are both functionally equivalent, the cap() example avoids any additional memory allocations that would have been needed using the append() function.\nConstructing Multidimensional Slices #  You can also define slices that consist of other slices as elements, with each bracketed list enclosed inside the larger brackets of the parent slice. Collections of slices like these are called multidimensional slices. These can be thought of as depicting multidimensional coordinates; for example, a collection of five slices that are each six elements long could represent a two-dimensional grid with a horizontal length of five and a vertical height of six.\nLet’s examine the following multidimensional slice:\nseaNames := [][]string{{\u0026#34;shark\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;mantis shrimp\u0026#34;}, {\u0026#34;Sammy\u0026#34;, \u0026#34;Jesse\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}} To access an element within this slice, we will have to use multiple indices, one for each dimension of the construct:\nfmt.Println(seaNames[1][0]) fmt.Println(seaNames[0][0]) In the preceding code, we first identify the element at index 0 of the slice at index 1, then we indicate the element at index 0 of the slice at index 0. This will yield the following:\nOutputSammy shark The following are the index values for the rest of the individual elements:\nseaNames[0][0] = \u0026#34;shark\u0026#34; seaNames[0][1] = \u0026#34;octopus\u0026#34; seaNames[0][2] = \u0026#34;squid\u0026#34; seaNames[0][3] = \u0026#34;mantis shrimp\u0026#34;  seaNames[1][0] = \u0026#34;Sammy\u0026#34; seaNames[1][1] = \u0026#34;Jesse\u0026#34; seaNames[1][2] = \u0026#34;Drew\u0026#34; seaNames[1][3] = \u0026#34;Jamie\u0026#34; When working with multidimensional slices, it is important to keep in mind that you’ll need to refer to more than one index number in order to access specific elements within the relevant nested slice.\nConclusion #  In this tutorial, you learned the foundations of working with arrays and slices in Go. You went through multiple exercises to demonstrate how arrays are fixed in length, whereas slices are variable in length, and discovered how this difference affects the situational uses of these data structures.\nTo continue studying data structures in Go, check out our article on Understanding Maps in Go, or explore the entire How To Code in Go series.\n"},{"id":16,"href":"/docs/17-Handling_Errors_in_Go_DigitalOcean/","title":"17 Handling Errors in Go Digital Ocean","section":"Docs","content":"健壮的代码需要对用户的不正确输入、网络连接错误和磁盘错误等意外情况做出正确的反应。错误处理是识别程序处于异常状态并且采取措施去记录供后期调试诊断信息的过程。\n相比于其他编程语言, 要求开发者使用专门的语法去处理错误, 在 Go 中将错误作为 error(Go 中的一个接口类型) 类型的值, 并且和其他类型的值一样作为函数返回值的一部分返回。要处理 Go 中的错误, 我们必须检查函数返回值中是否包含了错误信息, 并采取合适的措施去保护数据并告知用户或者操作人员发生错误。\n创建错误 #  在处理错误之前，我们需要先创建一些错误。标准库提供了两个内置函数来创建错误：errors.New 和 fmt.Errorf。这两个函数都允许您指定一条自定义错误消息，这些信息可以向用户展示具体错误信息的一部分。\nerrors.New 只提供了一个字符串类型的参数, 用户在使用的时候可以自定义一个错误发生时具体需要展示的错误消息.\n尝试运行以下示例以查看由 errors.New 创建的错误并打印到标准输出：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; )  func main() {  // 使用 errors.New() 创建一个错误, 具体的错误消息是: barnacles \terr := errors.New(\u0026#34;barnacles\u0026#34;)   // 将错误直接打印到标准错误输出 \tfmt.Println(\u0026#34;Sammy says:\u0026#34;, err) } # 这里是控制台的输出 # Output Sammy says: barnacles 我们使用标准库的 errors.New 函数创建了具体的消息是 \u0026quot;barnacles\u0026quot; 的错误。这里我们遵循了 Go 程序设计风格指南 使用小写了表示错误消息。\n最后，我们使用 fmt.Println 函数将我们的错误消息与\u0026quot;Sammy says:\u0026quot;相结合并且输出到控制台。\nfmt.Errorf 函数允许用户构建动态的错误消息。它的第一个参数是一个字符串，包含包含占位符值的错误消息，例如字符串的 %s 和整数的%d。fmt.Errorf 将这个格式化字符串后面的参数按顺序插入到这些占位符中:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \t// 使用 fmt.Errorf() 来构建动态错误信息 \t// 错误内容是 error occurred at: %v \t// 其中 %v 的具体内容由 time.Now() 的具体返回值决定 \terr := fmt.Errorf(\u0026#34;error occurred at: %v\u0026#34;, time.Now())  \t// 将具体的错误信息 结合 `An error happened:` 打印到控制台 \tfmt.Println(\u0026#34;An error happened:\u0026#34;, err) } # 在控制台中输出错误信息 # Output # 输出内容中的: 2019-07-11 16:52:42.532621 -0400 EDT m=+0.000137103 是由 `time.Now()` 动态生成的 An error happened: error occurred at: 2019-07-11 16:52:42.532621 -0400 EDT m=+0.000137103 我们使用 fmt.Errorf 函数来构建一个错误消息，该消息将包括当前时间。我们提供给 fmt.Errorf 的格式字符串包含 ％v 格式指令，该指令告诉 fmt.Errorf 使用默认格式为格式化字符串后提供的第一个参数。这个参数由标准库的 time.Now 函数提供的当前时间。与较早的示例类似，我们将错误消息与简短前缀结合在一起，并使用 fmt.Println 函数将结果打印到标准输出。\n错误处理 #  一般来说, 你不会看到像上面一样直接创建错误, 然后直接打印。实际上, 在出现问题时, 错误都是由从函数中创建并且返回这种情况更加普遍。调用者使用 if 语句判断返回的错误是否为 nil(error 非初始化的值) 来判断错误是否存在。\n下面这个示例包含了一个总是返回错误的函数, 需要特别留意的时尽管这里的错误是由一个函数返回的, 当你在运行这个程序时, 它产生的输出总是与前面的示例相同。在其他位置声明错误不会改变错误的消息。\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; )  // 定义一个名为: boom 的函数, 返回值总是 errors.New(\u0026#34;barnacles\u0026#34;) func boom() error { \treturn errors.New(\u0026#34;barnacles\u0026#34;) }  func main() { \t// 调用 boom() 函数, 并将返回值赋值给 err 变量 \terr := boom()  \t// 判断 err 是否等于 nil \tif err != nil { \t// 如果 err != nil 条件成立, 输出内容, 然后返回 main.main 函数 \tfmt.Println(\u0026#34;An error occurred:\u0026#34;, err) \treturn \t}  \t// 如果 err == nil 成立, \t// 将会输出下面这一句 \tfmt.Println(\u0026#34;Anchors away!\u0026#34;) } # Output An error occurred: barnacles 这里我们先定义了一个名为 boom() 的函数并且总是返回单个使用 errors.New 构造 error 的函数。然后, 我们通过 err := boom() 这行调用 boom() 并捕捉错误(赋值给 err 变量即为捕捉错误)。在赋值 error 之后, 我们使用 if err != nil 这个条件判断语句来进行判断错误是否存在。因为 boom() 函数总是返回有效的 error 所以这里的判断条件永远为 true。\n但是情况并非总是如此(值的是 boom() 函数总是返回有效的 error 变量), 所以, 最好有逻辑去处理错误不存在和错误存在这两种情况。当错误存在时, 就像上面的示例中一样, 我们使用 fmt.Println 和前面的前缀打印错误。最后我们使用 return 语句来跳过 fmt.Println(\u0026quot;Anchors away!\u0026quot;) 语句的执行, 因为这个语句只有在 err == nil 时才会执行。\n 注意: 在 Go 中主要采用上一个示例中的 if err != nil 来进行错误处理。函数运行到哪里都有可能发生错误, 重要的是使用 if 语句来判断错误是否发生。这样, Go 代码通常就具有第一个缩进级别的 快乐路径 的逻辑, 并且所有的 \u0026ldquo;悲伤的路径\u0026rdquo; 在第二个缩进。\n if 语句有一个可选的赋值子句，可以用来帮助压缩函数调用和错误处理。\n运行下一个程序，查看与前面示例相同的输出，但这一次使用复合 if 语句来减少一些重复的代码:\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; )  func boom() error { \treturn errors.New(\u0026#34;barnacles\u0026#34;) }  func main() { \t// 将 err 变量的赋值和判断都压缩在一个语句块中执行 \tif err := boom(); err != nil { \tfmt.Println(\u0026#34;An error occurred:\u0026#34;, err) \treturn \t} \tfmt.Println(\u0026#34;Anchors away!\u0026#34;) } #Output An error occurred: barnacles 和之前的示例一样, 我们定义一个 boom() 总是返回错误的函数。我们将从 boom() 返回的错误赋值给 err 作为 if 语句的一部分。在 if 语句的第二部分语句中, err 变量变得可用。我们检查错误是否存在, 然后像以前一样使用一个简短的前缀字符串打印我们的错误。\n在本节中，我们学习了如何处理只返回错误的函数。这些函数很常见，但是能够处理可能返回多个值的函数的错误也很重要。\n同时返回错误和多个值 #  返回单个值的函数通常是影响某些状态更改的函数。 比如将行数据插入到数据库中。通常还会编写这样的函数: 如果成功则返回一个值, 如果失败则返回一个潜在的错误。Go 允许函数返回多个结果, 可以用来同时返回一个值和一个错误类型。\n为了创建一个返回多个值的函数, 我们需要在函数签名的括号中列出返回值类型。例如, 一个 capitalize 函数返回值类型是 string 和 error, 那么我们可以这么声明 func capitalize(name string)(string, error){}。其中 (string, error) 这一块的语法是告诉 Go 的编译器, 函数会按照 string 和 error 这一顺序返回值。\n运行下面的程序并且查看函数返回的 string 和 error:\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func capitalize(name string) (string, error) { \tif name == \u0026#34;\u0026#34; { \treturn \u0026#34;\u0026#34;, errors.New(\u0026#34;no name provided\u0026#34;) \t} \treturn strings.ToTitle(name), nil }  func main() { \tname, err := capitalize(\u0026#34;sammy\u0026#34;) \tif err != nil { \tfmt.Println(\u0026#34;Could not capitalize:\u0026#34;, err) \treturn \t}  \tfmt.Println(\u0026#34;Capitalized name:\u0026#34;, name) } # Output Capitalized name: SAMMY 我们定义了 capitalize() 函数, 这个函数需要传递一个字符串作为参数(完成将字符串的转为大写)并返回字符串和错误。在 main() 函数中, 我们调用 capitalize(), 然后在 := 运算符的左边将函数的返回值赋值给 name 和 err 这两个变量。之后, 我们执行 if err != nil 检查错误, 如果存在错误, 使用 fmt.Prtintln 将错误信息打印到标准输出。如果没有错误, 输出 Capitalized name: SAMMY。\n如果将 err := capitalize(\u0026quot;sammy\u0026quot;) 中的 \u0026quot;sammy\u0026quot; 更改为为空字符串 (\u0026quot;\u0026quot;)，你将收到 Could not capitalize: no name provided 这个错误。\n当函数的调用者为 name 参数提供一个空字符串时， capitalize 函数将返回错误。当 name 参数不是空字符串时，capledize() 调用 strings.ToTitle 函数将 name 参数转为大写并返回为 nil 的错误值。\n这个例子遵循一些微妙的规约，这些规约是 Go 代码的典型特征，但 GO 编译器并没有强制执行。当函数返回多个值（包括错误）时，规约我们将 error 类型作为最后一项。具有多个返回值的函数返回错误时，通常约定 GO 代码还将每个不是 error 类型的值设置为零值。比如字符串的零值空字符串，整数为 0，一个用于结构类型的空结构，以及用 nil 表示接口和指针类型的零值。我们在有关 变量和常数的教程 中更详细地介绍零值。\n简化重复的代码 #  如果函数有多个返回值时，遵守这些约定可能会变得啰嗦。我们可以使用 匿名函数 来帮助减少重复的代码。匿名函数是分配变量的过程。与我们在较早的示例中定义的函数相反，它们仅在你声明它们的函数中可用 - 这使其非常适合用作可重复使用的 helper 逻辑代码片段。\n以下程序是修改了最后一个示例，返回值增加了一个类型, 包括大写的名称的长度。由于它具有三个值可以返回的值，因此如果没有匿名函数来帮助我们，处理错误可能会变得麻烦:\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func capitalize(name string) (string, int, error) { \thandle := func(err error) (string, int, error) { \treturn \u0026#34;\u0026#34;, 0, err \t}  \tif name == \u0026#34;\u0026#34; { \treturn handle(errors.New(\u0026#34;no name provided\u0026#34;)) \t}  \treturn strings.ToTitle(name), len(name), nil }  func main() { \tname, size, err := capitalize(\u0026#34;sammy\u0026#34;) \tif err != nil { \tfmt.Println(\u0026#34;An error occurred:\u0026#34;, err) \t}  \tfmt.Printf(\u0026#34;Capitalized name: %s, length: %d\u0026#34;, name, size) } # Output Capitalized name: SAMMY, length: 5 在 main() 中，我们现在可以从 capitalize() 函数中获取转为大写的 name，size 和 err 这三个返回的参数。然后，我们检查是否通过检查错误变量不等于 nil。在尝试使用 capitalize() 返回的任何其他值之前，这一点很重要，因为匿名函数可以将它们设置为零值。由于我们提供了字符串 \u0026quot;Sammy\u0026quot;，因此没有发生错误，因此我们打印出转为大写之后的名称及其长度。\n再次，你可以尝试将 \u0026quot;Sammy\u0026quot; 更改为空字符串 (\u0026quot;\u0026quot;) 以查看已打印的错误情况 (An error occurred: no name provided)。\n在 capitalize 函数中，我们将 handle 变量定义为匿名函数。它需要传递要给错误类型的参数，并以与 capitalize 函数的返回值相同的顺序返回相同的值。handle 将这些值设置为零值，并将其作为最终返回值作为参数传递的错误转发。然后，使用 err 作为 handle 的参数，就可以返回在 capitalize 中遇到的任何错误。\n请记住，capitalize 必须一直返回三个值，因为这就是我们定义函数的方式。有时我们不想处理函数可能返回的所有值。幸运的是，我们在赋值并如何使用这些值方面具有一定的灵活性。\n处理多回报功能的错误 #  当函数返回许多值时，Go 要求我们将每个值分配给变量。在最后一个示例中，我们通过提供从 capitalize 函数返回的两个值的名称来做到这一点。这些名称应通过逗号分隔，并出现在 := 操作符的左侧。从 capitalize 返回的第一个值将分配给 name 变量，第二个值(error)将分配给 err 这个变量。有时，我们只对错误值感兴趣。您可以丢弃使用特殊 _ 变量名称返回功能的任何不需要值。\n在以下程序中，我们修改了涉及大写功能的第一个示例，以通过传递空字符串 (\u0026quot;\u0026quot;) 来产生错误。尝试运行此程序，以查看我们如何通过使用 _ 变量丢弃第一个返回的值来检查错误：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func capitalize(name string) (string, error) { \tif name == \u0026#34;\u0026#34; { \treturn \u0026#34;\u0026#34;, errors.New(\u0026#34;no name provided\u0026#34;) \t} \treturn strings.ToTitle(name), nil }  func main() { \t_, err := capitalize(\u0026#34;\u0026#34;) \tif err != nil { \tfmt.Println(\u0026#34;Could not capitalize:\u0026#34;, err) \treturn \t} \tfmt.Println(\u0026#34;Success!\u0026#34;) } # Output Could not capitalize: no name provided 这次在 main() 函数中，我们将 capitalize 的第一个返回值 (首先返回的字符串) 分配给下划线变量(_)。同时，我们分配了通过 capitalize 返回的 err 变量返回的错误。然后，我们通过 if err != nil 条件判断错误是否存在。由于我们已经对一个空字符串进行了硬编码，作为在行中大写的参数，_, err := capitalize(\u0026quot;\u0026quot;)，因此该条件始终将评估为 true。这会产生输出\u0026quot;Could not capitalize: no name provided\u0026quot;，该输出由 fmt.Println 函数在 if 语句的正文中打印出来。此后的返回将跳过 fmt.Println(\u0026quot;Success!\u0026quot;)。\n结论 #  我们已经看到了许多使用标准库创建错误的方法，以及如何构建以惯用方式返回错误的函数。在本教程中，我们设法使用标准库的 errors.New 和 fmt.Errorf 函数成功地创建了各种错误。在将来的教程中，我们将研究如何创建自己的自定义错误类型，以向用户传达更丰富的信息。\n"},{"id":17,"href":"/docs/18-Creating_Custom_Errors_in_Go_DigitalOcean/","title":"18 Creating Custom Errors in Go Digital Ocean","section":"Docs","content":"介绍 #  GO 标准库提供了errors.New and fmt.Errorf 这两种方法来在创建错误。但是这两种方法并不能满足你的用户或者后期调试时提供更加复杂的错误信息或者报告发生了什么。为了传递这种更复杂的错误信息并获得更多功能，我们可以实现标准库 error 接口类型。\nerror 接口定义如下：\ntype error interface {  Error() string } 内置 软件包将 error 定义为具有单个 Error() 方法的接口，该接口将错误消息字符串作为返回。通过实现此方法，我们可以将定义的任何类型转换为自己的错误。\n让我们尝试运行以下示例以查看 error 接口的实现：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;os\u0026#34; )  // 定义一个 MyError 的接口体 type MyError struct{}  // 实现 error 接口的 Error 方法 func (m *MyError) Error() string { \treturn \u0026#34;boom\u0026#34; }  // 定义 sayHello 函数 // 函数返回类型为 string 和 error func sayHello() (string, error) {  // 由于 *MyError 实现了 error 接口  // 所以 \u0026amp;MyError{} 可以作为 error 对象返回 \treturn \u0026#34;\u0026#34;, \u0026amp;MyError{} }  func main() { \ts, err := sayHello() \tif err != nil { \tfmt.Println(\u0026#34;unexpected error: err:\u0026#34;, err) \tos.Exit(1) \t} \tfmt.Println(\u0026#34;The string:\u0026#34;, s) } 我们将看到以下输出：\n# Output unexpected error: err: boom exit status 1 在这里，我们创建了一个新的空结构类型 MyError，并在其上定义了 Error() 方法。Error() 方法返回字符串 \u0026quot;Boom\u0026quot;。\n在 main() 中，我们调用 sayhello 函数，该函数返回一个空字符串和一个新 MyError 实例。由于 sayhello 将始终返回错误，因此在main() 中的 if 语句主体内的 fmt.Println 调用将始终执行。我们使用 fmt.Println 来打印短前缀字符串 \u0026quot;unexpected error:\u0026quot;以及在保存MyError 实例中的在 err 变量。\n 值得注意的是，我们不必直接调用 Error()，因为 fmt 包能够自动检测到已经实现了 error 接口。它 透明 地调用 Error() 来获取字符串 \u0026quot;hoom\u0026quot;，并将其与前缀字符串 \u0026quot;unexpected error: err:\u0026quot; 相连。\n 自定义错误收集详细信息 #  有时，自定义错误是捕获详细错误信息的最有效的方式。例如，假设我们要捕获 HTTP 请求产生的错误的状态代码；运行以下程序以查看 error 的实现，使我们能够清晰捕获该信息：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;os\u0026#34; )  type RequestError struct { \tStatusCode int  \tErr error }  func (r *RequestError) Error() string { \treturn fmt.Sprintf(\u0026#34;status %d: err %v\u0026#34;, r.StatusCode, r.Err) }  func doRequest() error { \treturn \u0026amp;RequestError{ \tStatusCode: 503, \tErr: errors.New(\u0026#34;unavailable\u0026#34;), \t} }  func main() { \terr := doRequest() \tif err != nil { \tfmt.Println(err) \tos.Exit(1) \t} \tfmt.Println(\u0026#34;success!\u0026#34;) } 我们将看到以下输出：\n# Output status 503: err unavailable exit status 1 在此示例中，我们创建了创建一个错误的 RequestError 的新实例, 其中包含一个状态码和使用标准库提供的 errors.New 函数创建的 err。之后，如前所述，我们使用 fmt.Println 打印了错误信息。\n在 RequestError 的 Error() 方法中，我们使用创建 error 对象时提供的信息和 fmt.Sprintf 函数构造字符串。\n类型断言和自定义错误 #  error 接口仅公开一种方法，但是为了正确处理错误, 我们可能需要访问 error 实现类型的其他方法。例如，我们可能有几个暂时的自定义错误实现，可以通过 Temporary() 方法的存在来重述。\n接口为类型提供的更广泛的方法集提中供了一个狭窄的视图，因此，我们必须使用类型断言来更改视图正在显示的方法，或完全删除它。\n下面的示例增加了前面显示的 RequestError 具有 Temporary() 方法，该方法将指示调用者是否应重试请求：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;net/http\u0026#34; \t\u0026#34;os\u0026#34; )  type RequestError struct { \tStatusCode int  \tErr error }  func (r *RequestError) Error() string { \treturn r.Err.Error() }  func (r *RequestError) Temporary() bool {  // 如果状态码是 503 返回 true \treturn r.StatusCode == http.StatusServiceUnavailable // 503 }  func doRequest() error { \treturn \u0026amp;RequestError{ \tStatusCode: 503, \tErr: errors.New(\u0026#34;unavailable\u0026#34;), \t} }  func main() { \terr := doRequest() \tif err != nil { \tfmt.Println(err)  // 进行类型断言 \tre, ok := err.(*RequestError)  // 如果类型断言成功 \tif ok {  \tif re.Temporary() { \tfmt.Println(\u0026#34;This request can be tried again\u0026#34;) \t} else { \tfmt.Println(\u0026#34;This request cannot be tried again\u0026#34;) \t} \t} \tos.Exit(1) \t}  \tfmt.Println(\u0026#34;success!\u0026#34;) } 我们将看到以下输出：\n# Output unavailable This request can be tried again exit status 1 在 main() 中，我们调用 doRequest() 将错误接口返回给我们。我们首先打印由 Error() 方法返回的错误消息。接下来，我们尝试通过使用类型的断言 re, ok := err.(*RequestError)。如果类型断言成功，我们然后使用 Temporary() 方法来查看此错误是否是临时错误。由于doRequest() 设置的状态代码为 503，它匹配 HTTP.Statusserviceunavailable，因此将返回 true，并且要打印\u0026quot;This request can be tried again\u0026quot; 的原因。实际上，我们将提出另一个请求，而不是打印消息。\n包装错误 #  通常，错误是从程序的外部产生(例如：数据库，网络连接等)。这些错误提供的错误消息不能够帮助任何人找到错误的根源。有必要在错误消息开始时，将错误与额外信息包装，将为成功调试提供一些必要的上下文。\n下面的示例说明了我们如何将一些上下文信息附加到从其他功能中返回的其他隐性错误：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;fmt\u0026#34; )  // 定义一个错误的包装类型 type WrappedError struct {  // 上下文信息 \tContext string  // 具体错误内容 \tErr error }  func (w *WrappedError) Error() string { \treturn fmt.Sprintf(\u0026#34;%s: %v\u0026#34;, w.Context, w.Err) }  func Wrap(err error, info string) *WrappedError { \treturn \u0026amp;WrappedError{ \tContext: info, \tErr: err, \t} }  func main() { \terr := errors.New(\u0026#34;boom!\u0026#34;) \terr = Wrap(err, \u0026#34;main\u0026#34;)  \tfmt.Println(err) } 我们将看到以下输出\n# Output main: boom! WrappedError 是一个具有两个字段的结构：字符串类型的 context 字段和 error, 这让 WrappedError 提供了更多信息。当调用 Error() 方法时，我们再次使用 fmt.Sprintf 打印上下文消息和 error(fmt.Sprintf 也会隐式调用 err 的 Error() 方法)。\n在 main() 中，我们使用 errors.New 创建一个错误，然后我们使用定义的 Wrap 函数包装该错误。这使我们可以指出此错误是在 \u0026quot;main\u0026quot; 中生成的。另外，由于我们的 WrappedError 也是一个 error，因此我们也可以包装其它的WrappedError - 这将使我们看到链条来帮助我们追踪错误源。在标准库的一点帮助下，我们甚至可以在错误中嵌入完整的堆栈跟踪。\n总结 #  由于 error 接口只提供一种方法，我们已经看到，在为不同情况提供不同类型的错误方面，我们有很大的灵活性。这可以包含所有内容，从传达多个信息作为错误的一部分到实现 指数退回。尽管表面上的错误处理机制似乎很简单，但我们可以使用这些自定义错误来处理常见和不常见情况。\nGO 有另一种传达意外行为的机制，panic。在错误处理系列的下一篇文章中，我们将检查恐慌 - 它们是什么以及如何处理它们。\n"},{"id":18,"href":"/docs/19-Handling_Panics_in_Go-_DigitalOcean/","title":"19 Handling Panics in Go Digital Ocean","section":"Docs","content":"介绍 #  程序遇到的错误分为两个广泛的类别：程序员已经预料到的错误和程序员没有预料到的错误。我们在前两篇关于 错误处理 的文章中介绍过的 error 接口主要用于处理我们在编写 Go 程序时可能遇到的错误。error 接口甚至允许我们去确认在调用一个函数时发生罕见性错误的可能性，因此我们可以在这些情况下进行适当的响应。\nPanics 属于第二类错误，这些错误是程序员意料之外的。这些意料之外的错误导致一个 GO 程序自发终止并退出运行。常见的错误通常是造成 panic 的原因。在本教程中，我们将研究哪些常见操作可以引起 panic ，我们还将看到避免这些 panic 的方法。我们还将使用 defer 语句与 recover 函数一起捕获 panic，以免 panic 有机会意外终止我们正在运行的 GO 程序。\n了解 panics #  GO 中的某些操作会自动返回 panic 并停止程序的运行。常见的操作包括索引超出 数组 的容量，执行类型的断言，空指针上的调用方法，错误地使用互斥锁以及尝试使用已经关闭的 chanel 等等。这些情况中的大多数是由于编程时犯错而导致的，再加上编译器在编译程序时没有检测到这些错误。\n由于 panic 包含了有助于解决问题的细节，所以开发者通常会使用 panic 来标记在开发过程中犯了一个错误。\n由于越界引发的 panic #  当你尝试访问超出切片长度或数组容量之外的索引时，GO 运行时会产生 panic。\n下面的示例是尝试使用内置的 len 函数返回的切片的长度, 然后访问切片的最后一个元素时常见错误。尝试运行此代码以了解为什么这可能会引起panic：\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  func main() { \tnames := []string{ \t\u0026#34;lobster\u0026#34;, \t\u0026#34;sea urchin\u0026#34;, \t\u0026#34;sea cucumber\u0026#34;, \t} \tfmt.Println(\u0026#34;My favorite sea creature is:\u0026#34;, names[len(names)]) } 这将会有有以下输出：\n# Output panic: runtime error: index out of range [3] with length 3  goroutine 1 [running]: main.main() # 备注这一块信息可能会有不一样的输出 /tmp/sandbox879828148/prog.go:13 +0x20 panic 输出的名称提供了一个提示：panic: runtime error: index out of range。我们用三个海洋生物创建了一个切片。然后，我们尝试通过使用内置的 len 函数将切片的长度作为索引来获取切片的最后一个元素。请记住，切片和数组的第一个元素的下标都是 0; 因此，第一个元素的索引是 0，此切片中的最后一个元素在索引2。由于我们尝试在第三个索引，3 时，因此切片中没有元素要返回并且超出了切片的边界。运行时别无选择，只能终止和退出，因为我们要求它做一些不可能的事情。Go在编译过程中也无法证明此代码将尝试执行此操作，因此编译器无法捕获到这种操作。\n 还请注意，后续代码还没被执行。这是因为 panic 是一个完全阻止执行你的 GO 程序的事件。其中产生的消息中包含多个有助于诊断 panic 的原因。\n 剖析 panic #  panics 由指示 panic 的原因和一个 堆栈跟踪 信息组成，这些可帮助你在代码中找到 panic 的位置。\n任何 panic 的第一部分都是消息。它始终将以字符串 panic: 开始, 紧接着是引发 panic 的具体原因的字符串。在上一个练习中有一个 panic 的消息：\npanic: runtime error: index out of range [3] with length 3 紧接着 panic: 的是 runtime error: 这告诉我们这个 panic 是由语言的运行时引起的。这个 panic 告诉我们, 我们尝试使用下标 [3]已经超出了切片的长度 3 了。\n消息后面的是堆栈跟踪。堆栈跟踪形成一个映射，我们可以根据映射信息，以准确地定位生成 panic 时正在执行的代码所在的行，和代码的调用链关系。\ngoroutine 1 [running]: main.main() /tmp/sandbox879828148/prog.go:13 +0x20 上一个示例的堆栈跟踪表示，我们的程序从 /tmp/sandbox879828148/prog.go 文件的第 13 行中生成了 panic。这些信息还告诉我们 panic 在 main 包中的 main() 函数产生。\n堆栈跟踪分为单独的块 - 对于你程序中的每个 goroutine一个块。每个 GO 程序的执行都是通过一个或多个 goroutines 来完成的，它们可以独立并同时执行GO代码的一部分。每个块从标头 goroutine x [state]: (其中 x: 表示 goroutine 的 id, [state] 表示 goroutine 当前的状态)开头。标头给出了 goroutine 的 ID 号，以及发生 panic 时所处的状态。标头后，堆栈跟踪显示了发生 panic 时程序执行的函数，以及执行函数所在的文件名和行号。\n上一个示例中的 panic 是通过对切片的越界访问而产生的。当使用空指针去调用方法时，也可以生成 panic。\nNil Receivers #  nil 指针调用方法 #  GO编程语言在运行时具有指向计算机内存中存在的某种类型的特定实例的指针。指针可以是 nil 值, 这表明他们没有指向任何东西。当我们尝试在零指针上调用方法时，GO 运行时会产生 panic。同样，当调用方法时，是接口类型的变量也会产生 panic。要查看这些情况下产生的 panic，请尝试以下示例：\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  type Shark struct { \tName string }  func (s *Shark) SayHello() { \tfmt.Println(\u0026#34;Hi! My name is\u0026#34;, s.Name) }  func main() { \ts := \u0026amp;Shark{\u0026#34;Sammy\u0026#34;} \ts = nil \ts.SayHello() } The panics produced will look like this:\n由此产生的 panic 将是这样的:\n# Output panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0xffffffff addr=0x0 pc=0xdfeba]  goroutine 1 [running]: main.(*Shark).SayHello(...) /tmp/sandbox160713813/prog.go:12 main.main() /tmp/sandbox160713813/prog.go:18 +0x1a 在此示例中，我们定义了一个称为 Shark 的结构体。Shark 在其指针接收器上定义了一个叫做 Sayhello 的方法，这个方法将在被调用时在标准输出中打印出问候信息。在我们的 main 函数主体中，我们创建了 Shark 结构体的新实例，并使用 \u0026amp; 操作符取变量的指针并将指针分配给 S 变量。然后，我们使用语句 s = nil 将 s 变量重新赋值为 nil。最后，我们尝试在变量 s 上调用 SayHello 方法。我们没有收到 Sammy 的友好消息，而是收到 panic，因为我们试图访问无效的内存地址。因为 s 变量为 nil，所以当调用 SayHello 函数时，它试图访问 *Shark 类型上的 Name 字段。因为这是一个指针接收者，并且在这种情况下的接收者是 nil 的，所以无法解引用零值指针而引起的 panic。\n虽然我们在本例中显式地将 s 设置为nil，但实际上，这种情况却不明显。当你看到有关解引用 nil 指针而引发的 panic 时，请确保你已正确分配了你可能创建的任何指针变量。\n 备注, 通过使用指针作为接收者时, 使用零值取调用时没有不会发生 panic 的, 真正发生 panic 的时, 解引用 nil 指针。\n \t// 这种定义时, 使用零值的 `* Shark` 对象去调用 SayHello 方法是没有问题的 func (s *Shark) SayHello() { \tif s == nil { \treturn \t} \tfmt.Println(\u0026#34;Hi! My name is\u0026#34;, s.Name) } 解引用 nil 指针和越界访问产生的 panic 是两种在运行时产生的 panic 常见的场景。也可以使用内置函数手动产生 panic。\n使用内置的 panic 函数 #  我们还可以使用内置的 panic 函数来产生自己的 panic。它使用单个字符串作为参数，这是 panic 产生的信息。一般这条消息比重写 error 代码中的消息简单得多。此外，我们可以在我们自己的软件包中使用它向开发者指出，他们在使用包装代码时可能犯了一个错误。但是，最佳实践就是尝试在我们提供的软件包中将 error 值返回给开发者。\n运行此代码以查看从 main 函数调用 foo 函数产生的 panic：\npackage main  func main() { \tfoo() }  func foo() { \tpanic(\u0026#34;oh no!\u0026#34;) } 产生的 panic 输出看起来像：\n# Output panic: oh no!  goroutine 1 [running]: main.foo(...) /tmp/sandbox494710869/prog.go:8 main.main() /tmp/sandbox494710869/prog.go:4 +0x40 在这里，我们定义了一个 foo 函数，里面会使用 \u0026quot;oh no!\u0026quot; 这个字符串调用 panic 这个内置函数。foo 函数由我们的 main 函数调用。请注意输出如何输出 panic: oh no! 和堆栈跟踪, 在堆栈跟踪中展示一个 goroutine 和两行堆栈跟踪: 一行是 main() 函数，另一行是 foo() 函数。\n我们已经看到，panic 产生时似乎终止了我们的程序的运行。当需要正确关闭的开放资源时, 这可能会产生一些问题。GO 提供了一种机制，即使在panic 的情况下，也可以始终执行一些代码。\nderfer 函数 #  你的程序即使在运行时处理 panic 也必须能够正确清理的资源。GO 允许使用 defer 来调用延迟执行函数，直到调用它的函数完成时才会执行。延迟函数即使在出现 panic 的情况下也会运行，并被用作一种安全机制，用来防范 panic 的混乱本质。通过调用普通一样调用函数, 使用关键字 defer 作为调用整个函数调用语句的前缀，比如像调用 defer sayHello() 一样。运行此示例以查看即使产生 panic 时也可以打印消息：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tdefer func() { \tfmt.Println(\u0026#34;hello from the deferred function!\u0026#34;) \t}()  \tpanic(\u0026#34;oh no!\u0026#34;)  } 此示例产生的输出看起来像：\n# Output hello from the deferred function! panic: oh no!  goroutine 1 [running]: main.main() /Users/gopherguides/learn/src/github.com/gopherguides/learn//handle-panics/src/main.go:10 +0x55 在此示例的 main() 函数中，我们首先使用 defer 调用到打印消息 \u0026quot;hello from the deferred function!\u0026quot; 的匿名函数。然后，main 函数立即使用 panic 函数产生 panic。在此程序的输出中，我们首先看到执行递延函数并打印其消息。在此之后是，我们在 main 中产生 panic 消息。\n延迟函数提供了防范 panic 的保护。在递延函数中，GO 提供另一个内置函数来阻止 panic 终止 GO 程序的机会。\n处理 panic #  go 内置的 recover 函数提供了一个恢复 panic 的机制。这个函数通过拦截函数的调用栈并且阻止程序的意外退出。它具有严格的使用规则，但是在编写应用代码时非常有用。\n因为 recover 是内置包的一部分, 所以我们可以在不导包的情况下使用这个函数:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; )  func main() { \tdivideByZero() \tfmt.Println(\u0026#34;we survived dividing by zero!\u0026#34;)  }  func divideByZero() { \tdefer func() { \tif err := recover(); err != nil { \tlog.Println(\u0026#34;panic occurred:\u0026#34;, err) \t} \t}() \tfmt.Println(divide(1, 0)) }  func divide(a, b int) int { \treturn a / b } 此示例将输出：\n# Output 2009/11/10 23:00:00 panic occurred: runtime error: integer divide by zero we survived dividing by zero! 在此示例中，我们在 main 函数调用了我们定义的 DivideByZero 函数。在 DivideByZero 中，我们使用 defer 关键字调用匿名函数。这个匿名函数负责处理在 divideByZero 中出现的任何 panic。在匿名函数中, 我们调用内置的 recover 函数并且将错误信息赋值给 err, 如果 DivideByZero感处于 panic 状态，那么 err 将会被设置值，否则为 nil。通过将 err 与 nil 进行比较，我们可以检测到是否发生了 panic，在这种情况下，我们处理 panic 就像处理其他错误一样, 使用 log.Println 函数记录了 panic。\n在延迟执行匿名函数之后, 我们调用了另外一个我们定义的另一个函数, 并且尝试使用 fmt.Println 打印这个函数的返回值。所提供的参数将导致除法执行除数为零的操作，这将引起 panic。\n在此示例的输出中，我们首先从匿名函数中恢复 panic 的日志消息，接下来是 we survived dividing by zero! 的消息。我们真的做到了这一点，这要归功于内置的 recover 函数, 它成功阻止有可能终止 GO 程序运行的灾难性 panic。\n从 recover() 函数中返回的 err 值正是调用 panic 的值。因此，在没有发生 panic 时，确保 err 值仅为 nil 至关重要。\n使用 recover 检测 panic #  recover 函数依赖于错误的值来确定是否发生了 panic。因为 panic 函数的参数是空接口，所以它可以是任何类型。任何接口类型 (包括空接口) 的零值为 nil。必须注意避免使用 nil作为 panic 的参数，如本示例所证明的：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; )  func main() { \tdivideByZero() \tfmt.Println(\u0026#34;we survived dividing by zero!\u0026#34;)  }  func divideByZero() { \tdefer func() { \tif err := recover(); err != nil { \tlog.Println(\u0026#34;panic occurred:\u0026#34;, err) \t} \t}() \tfmt.Println(divide(1, 0)) }  func divide(a, b int) int { \tif b == 0 { \tpanic(nil) \t} \treturn a / b } 这将输出：\n# Output we survived dividing by zero! 此示例与以前的示例相同，该示例涉及 recover 并进行一些小的修改。已更改了 divide 函数判断 b 是否为 0。如果是, 它将使用带有 nil 作为参数调用 panic 函数来产生 panic。这次的输出不包括 defer 调用匿名函数的日志消息，即使通过 Divide 创建了panic，也会出现 panic。这种沉默行为是为什么确保调用 panic 的参数不是 nil 很重要的原因。\nConclusion #  总结 #  我们已经看到了多种可以在 GO 中造成 panic 的方法，以及如何使用恢复的内置的 recover 来恢复它们。虽然您不一定会自己使用 panic，但适当的 panic 的恢复机制是使 Go 代码达到生产级别应用程序的重要步骤。\n"},{"id":19,"href":"/docs/20-Importing_Packages_in_Go_DigitalOcean/","title":"20 Importing Packages in Go Digital Ocean","section":"Docs","content":"介绍 #  有时，你的代码需要当前程序的基础上增加更多的功能。在这些情况下，你可以使用软件包来丰富你的程序。在 Go 中, 一个包表示磁盘上单个目录中的所有文件。包可以定义可以在其他 Go 文件或包中引用的函数、类型和接口。\n本教程将带你来完成软件包的安装, 导入和重命名。\n标准库包 #  标准库是 Go 附带的一组软件包。这些软件包包含许多用于编写现代软件的基本模块。例如， fmt 软件包包含用于格式和打印字符串的基本功能。 net/http 软件包包含允许开发人员创建 Web 服务，通过HTTP 协议发送和检索数据的功能，等等。\n为了利用软件包中的功能，你需要使用 import 语句访问软件包。import 语句由 import 关键字以及软件包的名称组成。\n例如，在 GO 程序中 random.go 文件。你可以导入 math/rand 包来生成随机数：\nimport \u0026#34;math/rand\u0026#34; 当我们导入一个包时，我们把它在当前程序中作为一个单独namespace命名空间来使用。这意味着我们必须像 package.function 调用其中的函数。\n实际上，math/rand 软件包的功能看起来像这些示例：\n rand.Int() 调用函数返回随机整数。 rand.Intn() 调用函数将随机元素从 0 返回到所提供的指定数字。  让我们创建一个 for 循环，以显示我们如何在随机过程中调用 math/rand 软件包的函数。\nrandom.go\npackage main  import \u0026#34;math/rand\u0026#34;  func main() {  for i := 0; i \u0026lt; 10; i++ {  println(rand.Intn(25))  } } 该程序首先在第三行中导入 math/rand 软件包，然后移至将运行10次的循环中。在循环中，程序将打印一个在 0 到 25 范围内的随机整数。其中, 整数 25 是作为其参数传递给 rand.Intn()。\n当我们使用 go run random.go 来运行程序时，我们将收到 10 个随机整数作为输出。因为这些是随机的，所以每次运行程序时，你都可能会获得不同的整数。输出看起来像这样：\n# Output 6 12 22 9 6 18 0 15 6 0 整数永远不会低于 0 或 24 以上。\n当需要导入多个包时，你可以使用 () 来创建一个块。通过使用块，可以避免在每行上重复 import 关键字。这将使你的代码看起来更整洁\nrandom.go\nimport (  \u0026#34;fmt\u0026#34;  \u0026#34;math/rand\u0026#34; ) 为了利用新增的软件包，我们现在可以格式化输出并打印出循环中每次迭代生成的随机数：\nrandom.go\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;math/rand\u0026#34; )  func main() {  for i := 0; i \u0026lt; 10; i++ {  fmt.Printf(\u0026#34;%d) %d\\n\u0026#34;, i, rand.Intn(25))  } } 现在，当我们运行程序时，我们将收到看起来像这样的输出：\n# Output 0) 6 1) 12 2) 22 3) 9 4) 6 5) 18 6) 0 7) 15 8) 6 9) 0 在本节中，我们学会了如何导入软件包并使用它们来编写更复杂的程序。到目前为止，我们只使用了标准库中的软件包。接下来，让我们看看如何安装和使用其他开发人员编写的软件包。\n安装软件包 #  虽然标准库包含了许多出色且有用的软件包，但它们的设计是通用的，本质上不是特定的。这使开发者可以根据自己的特定需求在标准库之上构建自己的软件包。\nGO 工具链带有 go get 命令。此命令使你可以将第三方软件包安装到本地开发环境中，并且将这些软件包应用到你的程序中。\n使用 go get 来安装第三方软件包时，通常可以通过其规范路径引用软件包。这个路径也可能是通往公共项目的途径，该项目托管在诸如 GitHub 之类的代码存储库中。因此，如果要导入 flect 软件包，则将使用完整的规范路径：\ngo get github.com/gobuffalo/flect 在这种情况下，使用 go get 工具将在 GitHub 上找到软件包，并将其安装到你的 $Gopath 中。\n对于此示例，代码将安装在此目录中：\n$GOPATH/src/github.com/gobuffalo/flect 原始作者通常会更新软件包，以解决 bug 或添加新功能。发生这种情况时，你可能需要使用该软件包的最新版本来利用新功能或已解决的 bug。要更新软件包，你可以使用 go get 命令使用 -u 标志：\ngo get -u github.com/gobuffalo/flect 如果在本地找不到该软件包，此命令也将安装该软件包。如果已经安装了它，Go 将尝试将软件包更新为最新版本。\ngo get 命令始终检索可用的包装的最新版本。但是，可能还会对该软件包的之前的版本进行更新，这些版本仍然比你使用的更新，并且对你的程序中的更新非常有用。要检索包装的特定版本，你需要使用一个软件包管理工具，例如Go Modules。\n从 GO 1.11 开始，使用 Go Modules 来管理要导入的软件包的哪个版本。软件包管理的主题超出了本文的范围，但是你可以在on the Go Modules GitHub page上阅读有关它的更多信息。\n使用别名的方式导入软件包 #  如果你的本地软件包已经命名为与你正在使用的第三方软件包相同的包名时，则可能需要更改软件包名称。当发生这种情况时，使别名导入的方式是处理软件包名冲突的最佳方法。你可以通过将 alias 名称放在导入的软件包的前面来修改包装及其功能的名称及其功能。\n该声明的结构看起来像这样：\nimport another_name \u0026#34;package\u0026#34; 在此示例中，在 random.go 程序文件中修改 fmt 软件包的名称。我们将 fmt 的包名称更改为 f，以缩写它。我们的修改程序看起来像这样：\nrandom.go\npackage main  import (  f \u0026#34;fmt\u0026#34;  \u0026#34;math/rand\u0026#34; )  func main() {  for i := 0; i \u0026lt; 10; i++ {  f.Printf(\u0026#34;%d) %d\\n\u0026#34;, i, rand.Intn(25))  } } 在程序中，我们现在将 Printf 函数称为 f.Printf，而不是 fmt.Printf。\n虽然其他语言喜欢以别名的方式命名包以便于在程序中更加容易使用，但 GO 却不是。例如，与 fmt 软件包与 f 相反， style guide 更加倾向于一致。\n在重命名导入包以避免命名冲突时，你应该重命名本地导入的软件包或特定的项目中导入的包。例如，如果你有一个名为 Strings 的本地软件包，并且还需要导入称为 strings 的系统软件包，你应该重命名本地软件包而不是系统软件包。只要有可能，最好避免完全命名冲突。\n在本节中，我们了解了如何以别名的方式导入软件包以避免与我们计划中的其他导入冲突。重要的是要记住，程序的可读性和清晰度很重要，因此你只能使用别名使代码更可读或何时需要避免命名冲突。\n格式化导入 #  通过格式化导入，你可以将软件包分为特定的顺序，以使你的代码更加一致。此外，当惟一改变的是导入的排序顺序时，这将防止发生随机提交。由于格式化导入将防止随机提交，因此这将防止不必要的代码混乱和混淆代码审查。\n大多数编辑器将自动为你格式化导入，或者让你配置编辑器以使用 goimports 工具。在编辑器中使用 goimports 被认为是标准实践，因为尝试手动维护导入的排序顺序可能是乏味的，而且容易出错。此外，如果进行了任何样式更改，则将更新 goimports 以反映这些样式更改。这样可以确保你和任何在代码上工作的人都将在你的 import 块中具有一致的样式。\n这是格式化之前的示例导入块可能的样子：\nimport (  \u0026#34;fmt\u0026#34;  \u0026#34;os\u0026#34;  \u0026#34;github.com/digital/ocean/godo\u0026#34;  \u0026#34;github.com/sammy/foo\u0026#34;  \u0026#34;math/rand\u0026#34;  \u0026#34;github.com/sammy/bar\u0026#34; ) 运行 goimport 工具(或使用已安装它的大多数编辑器，保存文件将为你运行)，现在你将具有以下格式：\nimport (  \u0026#34;fmt\u0026#34;  \u0026#34;math/rand\u0026#34;  \u0026#34;os\u0026#34;   \u0026#34;github.com/sammy/foo\u0026#34;  \u0026#34;github.com/sammy/bar\u0026#34;   \u0026#34;github.com/digital/ocean/godo\u0026#34; ) 请注意，它首先将所有标准库软件包分组，然后将第三方软件包与空白行分组。这使得更容易阅读和了解正在使用哪些软件包。\n在本节中，我们了解到，使用 goimports 将保持我们所有导入块的正确格式，并防止在处理相同文件在开发人员之间产生不必要的代码混乱。\n总结 #  当我们导入软件包时，我们可以调用未内置的功能。有些软件包是随着 GO 安装的标准库的一部分，有些软件包将通过 go get 来安装。\n使用软件包可以使我们在利用现有代码时使程序更加健壮和强大。我们还可以为自己和其他程序员 创建自己的软件包，以便将来使用。\n"},{"id":20,"href":"/docs/21-How_To_Write_Packages_in_Go/","title":"21 How to Write Packages in Go","section":"Docs","content":"如何在 Go 中编写包 #  一个包由同一目录下的 Go 文件组成的，并且在文件开头有相同的包声明。你可以从包中加入额外的功能，使你的程序更加复杂。有些包可以通过 Go 标准库获得，因此在安装 Go 时就已经安装了。其他的可以用 Go 的go get命令来安装。你也可以通过在同一目录下创建Go文件来建立你自己的Go包，你可以通过使用必要的包声明来分享代码。\n本教程将指导你如何编写Go包，以便在其他编程文件中使用。\n前提条件 #   按照如何安装和设置Go的本地编程环境系列教程中的一个教程设置Go编程环境。按照本地编程环境教程中的步骤5创建你的Go工作区。要遵循本文的例子和命名规则，请阅读第一节「编写和导入软件包」。 为了加深你对GOPATH的了解，请阅读文章了解GOPATH。  编写和导入软件包 #  编写包就像编写任何其他Go文件一样，包可以包含函数、类型和变量的定义，然后可以在其他Go程序中使用。\n在我们创建一个新的包之前，我们需要进入我们的Go工作区。这通常是在我们的gopath下。对于这个例子，本教程中我们将把包称为greet。为了做到这一点，在我们的项目空间下的gopath中创建了一个名为greet的目录。当使用Github作为代码库，组织名称为gopherguides，想在此组织下创建greet包，那么我们的目录会是这样的：\n└── $GOPATH └── src └── github.com └── gopherguides greet目录在gopherguides目录中：\n└── $GOPATH └── src └── github.com └── gopherguides └── greet 最后，我们可以添加我们目录中的第一个文件。通常的做法是，包中的 主要或 入口 文件是以目录名来命名的。在这种情况下，将在greet目录下创建一个名为greet.go的文件：\n└── $GOPATH └── src └── github.com └── gopherguides └── greet └── greet.go 创建了文件后，我们就可以开始编写我们想要重复使用或在不同项目中共享的代码。在本例中，我们将创建一个打印出 Hello World的 Hello 的函数。\n在文本编辑器中打开 greet.go 文件，增加如下代码：\npackage greet  import \u0026#34;fmt\u0026#34;  func Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 让我们把这个文件分解一下，每个文件中第一行需要是所处的包名称。因为你在greet包里，所以通过使用package关键字，后面加包的名称：\npackage greet 这将告诉编译器把文件中的所有内容作为greet包的一部分。\n接下来，你用 import 语句声明你需要使用的任何其他包。在这个文件中你只使用一个包，fmt包：\nimport \u0026#34;fmt\u0026#34; 最后，你创建函数Hello，它将使用fmt包来打印出Hello, World!。\nfunc Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在已经编写了greet包，可以在你创建的任何其他包中使用它。让我们创建一个新的包，在其中使用greet包。\n接下来创建一个名为example的包，这意味着需要一个名为example的目录。在gopherguides中创建这个包，所以目录结构看起来像这样：\n└── $GOPATH └── src └── github.com └── gopherguides └── example 现在你有了新包的目录，可以创建入口文件。因为这将是一个可执行的程序，最好的做法是将入口文件命名为main.go：\n└── $GOPATH └── src └── github.com └── gopherguides └── example └── main.go 在文本编辑器中，打开main.go，添加以下代码来调用greet包：\npackage main  import \u0026#34;github.com/gopherguides/greet\u0026#34;  func main() { \tgreet.Hello() } 因为正在导入一个包，通过用点符号来调用指定包的函数。点符号是指在使用的包的名称和想使用的包中资源之间加一个句号.。例如，在greet包中，有Hello函数作为一个资源。如果想调用该资源，可以使用 greet.Hello() 的形式。\n现在，可以打开终端，在命令行上运行该程序：\ngo run main.go 完成后，你将收到以下输出：\nHello, World! 为了解如何在包中使用变量，让我们在greet.go文件中添加一个变量定义：\npackage greet  import \u0026#34;fmt\u0026#34;  var Shark = \u0026#34;Sammy\u0026#34;  func Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 接下来，打开main.go文件，添加以下高亮行，在fmt.Println()函数中调用greet.go中的变量:\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/greet\u0026#34; )  func main() { \tgreet.Hello()  \tfmt.Println(greet.Shark) } 再次运行此程序：\ngo run main.go 你会收到以下输出：\nHello, World! Sammy 最后，让我们也在greet.go文件中定义一个类型。创建一个带有 name 和 color字段的 Octopus 类型，以及一个在调用时将打印出字段的函数：\npackage greet  import \u0026#34;fmt\u0026#34;  var Shark = \u0026#34;Sammy\u0026#34;  type Octopus struct { \tName string \tColor string }  func (o Octopus) String() string { \treturn fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) }  func Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 打开main.go，在文件的末尾创建一个该类型的实例:\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/greet\u0026#34; )  func main() { \tgreet.Hello()  \tfmt.Println(greet.Shark)  \toct := greet.Octopus{ \tName: \u0026#34;Jesse\u0026#34;, \tColor: \u0026#34;orange\u0026#34;, \t}  \tfmt.Println(oct.String()) } 一旦你用oct := greet.Octopus创建了一个Octopus类型的实例，就可以在main.go文件的命名空间中访问该类型的函数和字段。这使得在最后一行直接写oct.String()，而不用调用greet。同样的，也可以在不引用greet包的名字的情况下调用oct.Color等类型字段。\nOctopus类型上的String方法使用fmt.Sprintf函数来输出一段文本，并将结果即一个字符串，返回给调用者（在这里是指主程序）。\n当你运行该程序时，你会收到以下输出：\ngo run main.go Hello, World! Sammy The octopus\u0026#39;s name is \u0026#34;Jesse\u0026#34; and is the color orange. 通过在Octopus上创建String方法，你现在有一个可重复使用的方法来打印出自定义类型的信息。如果想在将来改变这个方法的行为，只需要编辑这一个方法。\n可导出代码 #  你可能已经注意到，调用的greet.go文件中所有的声明都是大写的。Go没有像其他语言那样有public、private或protected修饰符的概念。外部可见性是由大写字母控制的。以大写字母开头的类型、变量、函数等等，在当前包之外是可以公开使用的。一个在其包外可见的符号被认为是 可导出 的。\n如果你给Octopus添加了一个名为reset的新方法，可以在greet包内调用它，但是不能在main.go文件中调用，因为调用者在greet包之外：\npackage greet  import \u0026#34;fmt\u0026#34;  var Shark = \u0026#34;Sammy\u0026#34;  type Octopus struct { \tName string \tColor string }  func (o Octopus) String() string { \treturn fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) }  func (o *Octopus) reset() { \to.Name = \u0026#34;\u0026#34; \to.Color = \u0026#34;\u0026#34; }  func Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 如果你试图从main.go文件中调用reset：\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/greet\u0026#34; )  func main() { \tgreet.Hello()  \tfmt.Println(greet.Shark)  \toct := greet.Octopus{ \tName: \u0026#34;Jesse\u0026#34;, \tColor: \u0026#34;orange\u0026#34;, \t}  \tfmt.Println(oct.String())  \toct.reset() } 你会收到以下编译错误：\noct.reset undefined (cannot refer to unexported field or method greet.Octopus.reset) 要从 Octopus 中导出 reset 功能，请将reset 中的R 大写：\npackage greet  import \u0026#34;fmt\u0026#34;  var Shark = \u0026#34;Sammy\u0026#34;  type Octopus struct { \tName string \tColor string }  func (o Octopus) String() string { \treturn fmt.Sprintf(\u0026#34;The octopus\u0026#39;s name is %q and is the color %s.\u0026#34;, o.Name, o.Color) }  func (o *Octopus) Reset() { \to.Name = \u0026#34;\u0026#34; \to.Color = \u0026#34;\u0026#34; }  func Hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 如此一来，可以从其他包中调用`Reset\u0026rsquo;而不会得到错误：\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/greet\u0026#34; )  func main() { \tgreet.Hello()  \tfmt.Println(greet.Shark)  \toct := greet.Octopus{ \tName: \u0026#34;Jesse\u0026#34;, \tColor: \u0026#34;orange\u0026#34;, \t}  \tfmt.Println(oct.String())  \toct.Reset()  \tfmt.Println(oct.String()) } 现在，如果你运行这个程序：\ngo run main.go 你将收到以下输出：\nHello, World! Sammy The octopus\u0026#39;s name is \u0026#34;Jesse\u0026#34; and is the color orange The octopus\u0026#39;s name is \u0026#34;\u0026#34; and is the color . 通过调用Reset，清除了Name和Color字段中的所有信息。当调用String方法时，Name和Color打印为空，因为这些字段现在是空的。\n总结 #  编写Go包与编写其他Go文件是一样的，但把它放在另一个目录中可以隔离代码，以便在其他地方重复使用。本教程介绍了如何在包中编写定义，演示了如何在另一个Go文件中使用这些定义，并解释了控制包是否可访问的选项。\n"},{"id":21,"href":"/docs/22-Understanding_Package_Visibility_in_Go/","title":"22 Understanding Package Visibility in Go","section":"Docs","content":"理解Go中包的可见性 #  介绍 #  当创建一个Go中的包时，最终的目标通常是让其他开发者可以使用这个包，无论是高阶包还是整个程序。通过导入包，你的这段代码可以作为其他更复杂的工具的构建模块。然而，只有某些包是可以导入的。这是由包的可见性决定的。\n这里的可见性是指一个包或其他构造可以被引用的文件空间。例如，如果我们在一个函数中定义一个变量，那么这个变量的可见性（范围）只在定义它的那个函数中。同样，如果你在一个包中定义了一个变量，你可以让它只在该包中可见，或允许它在包外也可见。\n在编写符合人体工程学的代码时，仔细控制包的可见性是很重要的，特别是在考虑到将来可能要对你的包进行修改时。如果你需要修复一个错误，提高性能，或改变功能，你会希望以一种不会破坏使用你的包的人的代码的方式进行改变。尽量减少破坏性修改的一个方法是只允许访问你的包中需要正常使用的部分。通过限制访问，你可以在内部对包进行修改，而减少影响其他开发者使用你的包的机会。\n在这篇文章中，将学习如何控制包的可见性，以及如何保护代码中只应在包内使用的部分。为了做到这一点，我们将创建一个基本的记录器来记录和调试信息，使用具有不同程度的项目可见性的包。\n前提条件 #  要遵循本文中的示例，你将需要：\n 按照如何安装 Go 并设置本地编程环境设置的 Go 工作区。 本教程将使用以下文件结构：  . ├── bin │ └── src └── github.com └── gopherguides 可导出与不可导出 #  不同于其他程序语言，如Java和Python使用访问修饰符如public、private或protected来指定范围不同，Go通过其声明方式来决定一个项目是否exported和unxported。在这种情况下，导出一个项目会使它在当前包之外是 \u0026ldquo;可见的\u0026rdquo;。如果它没有被导出，它只能在它被定义的包内可见和使用。\n这种外部可见性是通过将声明的项目的第一个字母大写来控制的。所有以大写字母开头的声明，如 \u0026ldquo;类型\u0026rdquo;、\u0026ldquo;变量\u0026rdquo;、\u0026ldquo;常量\u0026rdquo;、\u0026ldquo;函数\u0026quot;等，在当前包外是可见的。\n让我们看看下面的代码，仔细注意一下大写字母。\npackage greet  import \u0026#34;fmt\u0026#34;  var Greeting string  func Hello(name string) string { \treturn fmt.Sprintf(Greeting, name) } 这段代码声明它是在greet包中。然后声明了两个符号，一个叫做 Greeting 的变量和一个叫做 Hello 的函数。因为它们都以大写字母开头，所以它们都被 \u0026ldquo;可导出\u0026rdquo; 的，可供任何外部程序使用。如前所述，精心设计一个限制访问的包将允许更好的API设计，并使内部更新你的包更容易，而不会破坏任何依赖此包的代码。\n定义包的可见性 #  为了仔细看看包的可见性在程序中是如何工作的，让我们创建一个logging包，记住哪些信息我们希望包外可见，哪些我们不希望它可见。这个日志包将负责把我们程序的任何信息记录到控制台。它还将查看我们在什么级别上进行的日志记录，一个级别描述了日志的类型，它将是三种状态之一：信息、警告或错误。\n首先，在你的 src 目录下，创建一个名为 logging 的目录来放置日志文件：\nmkdir logging 进入目录：\ncd logging 然后，使用nano这样的编辑器，创建一个名为logging.go的文件：\nnano logging.go 在刚刚创建的logging.go文件中写入以下代码：\npackage logging  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  var debug bool  func Debug(b bool) { \tdebug = b }  func Log(statement string) { \tif !debug { \treturn \t}  \tfmt.Printf(\u0026#34;%s %s\\n\u0026#34;, time.Now().Format(time.RFC3339), statement) } 这段代码的第一行声明了一个名为 logging 的包。在这个包中，有两个 \u0026ldquo;导出 \u0026ldquo;的函数。Debug和Log。这些函数可以被任何其他导入logging的包所调用。还有一个名为debug的私有变量。这个变量只能从logging包内访问。值得注意的是，虽然函数Debug和变量debug的拼写相同，但函数是大写的，变量不是。这使得它们成为具有不同作用域的不同声明。\n保存并退出该文件。\n为了在我们代码的其他地方使用这个包，我们可以import它到一个新的包。我们将创建这个新的包，但需要一个新的目录来首先存储这些源文件。\n让我们离开logging目录，创建一个名为cmd的新目录，然后进入这个新目录：\ncd .. mkdir cmd cd cmd 在刚刚创建的cmd目录下创建一个名为main.go的文件：\nnano main.go 现在我们可以添加以下代码：\npackage main  import \u0026#34;github.com/gopherguides/logging\u0026#34;  func main() { \tlogging.Debug(true)  \tlogging.Log(\u0026#34;This is a debug statement...\u0026#34;) } 现在整个程序已经写好了。然而，在运行这个程序之前，我们还需要创建几个配置文件，以便我们的代码能够正常工作。Go使用Go模块来配置导入资源的软件包依赖性。Go模块是放置在你的包目录中的配置文件，它告诉编译器从哪里导入包。虽然对模块的学习超出了本文的范围，但我们可以只写几行配置来使这个例子在本地工作。\n在cmd目录下打开以下go.mod文件：\nnano go.mod 然后在文件中放置以下内容：\nmodule github.com/gopherguides/cmd replace github.com/gopherguides/logging =\u0026gt; ../logging 这个文件的第一行告诉编译器，cmd包的文件路径是github.com/gopherguides/cmd。第二行告诉编译器，github.com/gopherguides/logging包可以在磁盘上的.../logging目录下找到。\n我们还需要一个go.mod文件用于我们的logging包。让我们回到logging目录中，创建一个go.mod文件。\ncd ../logging nano go.mod 在文件中加入以下内容：\nmodule github.com/gopherguides/logging 这告诉编译器，我们创建的logging包实际上是github.com/gopherguides/logging包。这使得在 main 包中导入该包成为可能，之前写了以下这一行：\npackage main  import \u0026#34;github.com/gopherguides/logging\u0026#34;  func main() { \tlogging.Debug(true)  \tlogging.Log(\u0026#34;This is a debug statement...\u0026#34;) } 你现在应该有以下目录结构和文件布局：\n├── cmd │ ├── go.mod │ └── main.go └── logging ├── go.mod └── logging.go 现在我们已经完成了所有的配置，可以用以下命令运行cmd包中的main程序：\ncd ../cmd go run main.go 你将得到类似以下的输出：\n2019-08-28T11:36:09-05:00 This is a debug statement... 该程序将以RFC 3339格式打印出当前时间，后面是我们发送给记录器的任何语句。RFC 3339是一种时间格式，被设计用来表示互联网上的时间，通常用于日志文件。\n因为Debug和Log函数是从日志包中导出的，我们可以在main包中使用它们。然而，logging包中的debug变量没有被导出。试图引用一个未导出的声明将导致一个编译时错误。\n在main.go中添加错误操作的一行fmt.Println(logging.debug)：\npackage main  import \u0026#34;github.com/gopherguides/logging\u0026#34;  func main() { \tlogging.Debug(true)  \tlogging.Log(\u0026#34;This is a debug statement...\u0026#34;)  \tfmt.Println(logging.debug) } 保存并运行该文件，你将收到一个类似于以下的错误：\n. . . ./main.go:10:14: cannot refer to unexported name logging.debug 现在我们已经了解了包中的 exported 和 unexported 项的行为，接下来我们将看看如何从 structs 中导出 fields 和 methods。\n结构内的可见性 #  虽然在上一节中构建的记录器中的可见性方案可能对简单的程序有效，但它分享了太多的状态，在多个包中都是有用的。这是因为导出的变量可以被多个包所访问，这些包可以将变量修改成相互矛盾的状态。允许你的包的状态以这种方式被改变，使得你很难预测你的程序将如何表现。例如，在目前的设计中，一个包可以将Debug变量设置为true，而另一个包可以在同一实例中将其设置为false。这将产生一个问题，因为导入logging包的两个包都会受到影响。\n我们可以通过创建一个结构，然后把方法挂在它上面，使日志记录器隔离。这将允许我们创建一个日志记录器的instance实例，在每个使用它的包中独立使用。\n将logging包改为以下内容，以重构代码并隔离记录器：\npackage logging  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  type Logger struct { \ttimeFormat string \tdebug bool }  func New(timeFormat string, debug bool) *Logger { \treturn \u0026amp;Logger{ \ttimeFormat: timeFormat, \tdebug: debug, \t} }  func (l *Logger) Log(s string) { \tif !l.debug { \treturn \t} \tfmt.Printf(\u0026#34;%s %s\\n\u0026#34;, time.Now().Format(l.timeFormat), s) } 在这段代码中，我们创建了一个Logger结构。这个结构将存放未导出的状态，包括要打印出来的时间格式和debug变量设置为true或false。New函数设置初始状态来创建记录器，例如时间格式和调试状态。然后，它将内部给它的值存储到未导出的变量timeFormat和debug中。我们还在Logger类型上创建了一个名为Log的方法，该方法接收我们想要打印出来的语句。在Log方法内有一个对其本地方法变量l的引用，以获得对其内部字段的访问，如l.timeFormat和l.debug。\n这种方法将允许在许多不同的包中创建一个Logger，并独立于其他包的使用方式而使用它。\n为了在其他软件包中使用它，让我们把cmd/main.go改成下面的样子：\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/gopherguides/logging\u0026#34; )  func main() { \tlogger := logging.New(time.RFC3339, true)  \tlogger.Log(\u0026#34;This is a debug statement...\u0026#34;) } 运行这个程序将给你带来以下输出：\nOutput 2019-08-28T11:56:49-05:00 This is a debug statement... 在这段代码中，我们通过调用导出的函数New创建了一个记录器的实例。将这个实例的引用存储在logger变量中。现在可以调用logging.Log来打印出语句。\n如果试图从logger中引用一个未导出的字段，如timeFormat字段，将收到一个编译时错误。尝试添加以下高亮行，并运行cmd/main.go。\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/gopherguides/logging\u0026#34; )  func main() { \tlogger := logging.New(time.RFC3339, true)  \tlogger.Log(\u0026#34;This is a debug statement...\u0026#34;)  \tfmt.Println(logger.timeFormat) } 这将给出如下错误信息：\n. . . cmd/main.go:14:20: logger.timeFormat undefined (cannot refer to unexported field or method timeFormat) 编译器认识到logger.timeFormat没有被导出，因此不能从logging包中检索到。\n方法中的可见性 #  与结构字段相同，方法也可以被导出或未导出。\n为了说明这一点，让我们为日志器添加级别的日志记录。分级日志是一种对日志进行分类的方法，这样就可以在日志中搜索特定类型的事件。我们将在记录器中加入的级别是。\n info级别，代表信息类型的事件，通知用户一个动作，如 \u0026ldquo;程序开始\u0026rdquo;，或 \u0026ldquo;电子邮件发送\u0026rdquo;。这些帮助我们调试和跟踪我们程序的一部分，看看是否有预期的行为发生。 warning 级别。这些类型的事件可以识别出一些不属于错误的意外情况，如 \u0026ldquo;邮件发送失败，重试\u0026rdquo;。它们帮助我们看到我们的程序中没有像我们预期的那样顺利进行的部分。 error级别，意味着程序遇到了问题，如 \u0026ldquo;未找到文件\u0026rdquo;。这往往会导致程序的运行失败。  你也可能希望打开和关闭某些级别的日志记录，特别是当你的程序没有按照预期执行，你想调试程序的时候。我们将通过改变程序来增加这个功能，当debug被设置为true时，它将打印所有级别的信息。否则，如果它是false，它将只打印错误信息。\n通过对logging/logging.go进行以下修改来增加分级日志：\npackage logging  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; \t\u0026#34;time\u0026#34; )  type Logger struct { \ttimeFormat string \tdebug bool }  func New(timeFormat string, debug bool) *Logger { \treturn \u0026amp;Logger{ \ttimeFormat: timeFormat, \tdebug: debug, \t} }  func (l *Logger) Log(level string, s string) { \tlevel = strings.ToLower(level) \tswitch level { \tcase \u0026#34;info\u0026#34;, \u0026#34;warning\u0026#34;: \tif l.debug { \tl.write(level, s) \t} \tdefault: \tl.write(level, s) \t} }  func (l *Logger) write(level string, s string) { \tfmt.Printf(\u0026#34;[%s] %s %s\\n\u0026#34;, level, time.Now().Format(l.timeFormat), s) } 在这个例子中，我们为Log方法引入了一个新的参数。我们现在可以传入日志信息的级别。Log方法决定了它是什么级别的消息。如果是 info 或 warning 消息，并且 debug 字段是 true,，那么它就会写下该消息。否则，它将忽略该消息。如果是其他级别的信息，比如 error，它将写出该信息。\n大多数确定消息是否被打印出来的逻辑存在于Log方法中。我们还引入了一个未导出的方法，叫做 write。write方法是实际输出日志信息的方法。\n现在我们可以在其他软件包中使用这种分级日志，方法是将cmd/main.go改成下面的样子：\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/gopherguides/logging\u0026#34; )  func main() { \tlogger := logging.New(time.RFC3339, true)  \tlogger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) \tlogger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) \tlogger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;)  } 运行这个将返回：\n[info] 2019-09-23T20:53:38Z starting up service [warning] 2019-09-23T20:53:38Z no tasks found [error] 2019-09-23T20:53:38Z exiting: no work performed 在这个例子中，cmd/main.go成功使用了导出的Log方法。\n现在我们可以通过将debug切换为false来传递每个消息的`level\u0026rsquo;：\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/gopherguides/logging\u0026#34; )  func main() { \tlogger := logging.New(time.RFC3339, false)  \tlogger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) \tlogger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) \tlogger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;)  } 现在我们将看到，只有 error 级别的信息会被打印出来：\n[error] 2019-08-28T13:58:52-05:00 exiting: no work performed 如果我们试图从logging包之外调用write方法，我们将收到一个编译时错误：\npackage main  import ( \t\u0026#34;time\u0026#34;  \t\u0026#34;github.com/gopherguides/logging\u0026#34; )  func main() { \tlogger := logging.New(time.RFC3339, true)  \tlogger.Log(\u0026#34;info\u0026#34;, \u0026#34;starting up service\u0026#34;) \tlogger.Log(\u0026#34;warning\u0026#34;, \u0026#34;no tasks found\u0026#34;) \tlogger.Log(\u0026#34;error\u0026#34;, \u0026#34;exiting: no work performed\u0026#34;)  \tlogger.write(\u0026#34;error\u0026#34;, \u0026#34;log this message...\u0026#34;) } cmd/main.go:16:8: logger.write undefined (cannot refer to unexported field or method logging.(*Logger).write) 当编译器看到你试图引用另一个包中以小写字母开头的东西时，它知道这个东西没有被导出，因此抛出一个编译器错误。\n本教程中的记录器说明了如何编写代码，只暴露出希望其他包消费的部分。因为我们控制了包的哪些部分在包外是可见的，所以现在能够在未来进行修改而不影响任何依赖包的代码。例如，如果想只在debug为false时关闭info级别的消息，你可以在不影响你的API的任何其他部分的情况下做出这个改变。我们也可以安全地对日志信息进行修改，以包括更多的信息，如程序运行的目录。\n总结 #  这篇文章展示了如何在包之间共享代码，同时也保护你的包的实现细节。这允许你输出一个简单的API，为了向后兼容而很少改变，但允许在你的包中根据需要私下改变，使其在未来更好地工作。这被认为是创建包和它们相应的API时的最佳做法。\n要了解更多关于Go中的包，请查看我们的在Go中导入包和如何在Go中编写包文章，或者探索我们整个如何在Go中编码系列。\n"},{"id":22,"href":"/docs/23-How_To_Write_Conditional_Statements_in_Go/","title":"23 How to Write Conditional Statements in Go","section":"Docs","content":"如何在Go中编写条件语句 #  介绍 #  条件性语句是每一种编程语言的组成部分。通过条件语句，我们可以让代码有时运行，有时不运行，这取决于当时程序的条件。\n当我们完全执行程序的每个语句时，我们并没有要求程序评估特定的条件。通过使用条件语句，程序可以确定某些条件是否被满足，然后被告知下一步该做什么。\n让我们来看看一些使用条件语句的例子。\n 如果学生的考试成绩超过65%，报告她的成绩通过；如果没有，报告她的成绩不合格。 如果他的账户里有钱，就计算利息；如果没有，就收取罚款。 如果他们买了10个或更多的橙子，计算5%的折扣；如果他们买的少，就不买。  通过评估条件，并根据是否满足这些条件来分配代码运行，我们就是在写条件代码。\n本教程将带你了解在Go编程语言中编写条件语句。\nIf 语句 #  我们将从 if 语句开始，它将评估一个语句是真的还是假的，并且只在该语句为真的情况下运行代码。\n在一个纯文本编辑器中，打开一个文件，写入以下代码：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tgrade := 70  \tif grade \u0026gt;= 65 { \tfmt.Println(\u0026#34;Passing grade\u0026#34;) \t} } 在这段代码中，我们有一个变量grade，并给它一个整数值70。然后我们使用if语句来评估变量grade是否大于或等于（\u0026gt;=）65。如果它确实满足这个条件，我们告诉程序打印出字符串 Passing grade。\n将程序保存为grade.go，并在终端窗口中用go run grade.go命令运行它。\n在这种情况下，70分的成绩*符合大于或等于65分的条件，因此，一旦你运行该程序，你将收到以下输出：\nPassing grade 现在让我们改变这个程序的结果，把grade变量的值改为60：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tgrade := 60  \tif grade \u0026gt;= 65 { \tfmt.Println(\u0026#34;Passing grade\u0026#34;) \t} } 当我们保存并运行这个代码时，我们不会收到任何输出，因为条件*没有得到满足，我们也没有告诉程序执行另一条语句。\n再举一个例子，让我们计算一个银行账户余额是否低于0。让我们创建一个名为account.go的文件，并编写以下程序：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tbalance := -5  \tif balance \u0026lt; 0 { \tfmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) \t} } 当我们用go run account.go运行该程序时，我们会收到以下输出：\nBalance is below 0, add funds now or you will be charged a penalty. 在程序中，我们将变量balance初始化为5，即小于0。由于balance符合if语句的条件（balance\u0026lt;0），一旦我们保存并运行代码，我们将收到字符串的输出。同样，如果我们把余额改为0或一个正数，我们将不会收到任何输出。\nElse 语句 #  我们很可能希望程序在 if语句评估为假时也能有所作为。在我们的成绩例子中，我们希望输出成绩是合格还是不合格。\n要做到这一点，我们将在上面的成绩条件中添加一个 else 语句，其结构如下：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tgrade := 60  \tif grade \u0026gt;= 65 { \tfmt.Println(\u0026#34;Passing grade\u0026#34;) \t} else { \tfmt.Println(\u0026#34;Failing grade\u0026#34;) \t} } 由于成绩变量的值是60，if语句评估为假，所以程序不会打印出Passing grade。接下来的 else 语句告诉程序无论如何都要做一些事情。\n当我们保存并运行该程序时，我们将收到以下输出：\nFailing grade 如果我们重写程序，给成绩一个65或更高的值，我们将收到Passing grade的输出。\n为了给银行账户的例子增加一个 else 语句，我们这样改写代码:\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tbalance := 522  \tif balance \u0026lt; 0 { \tfmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) \t} else { \tfmt.Println(\u0026#34;Your balance is 0 or above.\u0026#34;) \t} } Your balance is 0 or above. 在这里，我们把balance变量的值改为正数，这样else语句就会打印出来。为了让第一个if语句打印出来，我们可以把这个值改写成一个负数。\n通过将if语句和else语句结合起来，你就构建了一个由两部分组成的条件语句，无论if条件是否满足，都会告诉计算机执行某些代码。\nElse if 语句 #  到目前为止，我们已经为条件语句提出了一个布尔选项，每个if语句的评估结果为真或假。在许多情况下，我们会希望一个程序能评估出两个以上的可能结果。为此，我们将使用else if语句，在Go中写成else if。else if或else if语句看起来和if语句一样，将评估另一个条件。\n在银行账户程序中，我们可能希望在三种不同的情况下有三个离散的输出。\n 余额低于0 余额等于0 余额高于0  else if语句将被放在 if 语句和 else 语句之间，如下所示：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tbalance := 522  \tif balance \u0026lt; 0 { \tfmt.Println(\u0026#34;Balance is below 0, add funds now or you will be charged a penalty.\u0026#34;) \t} else if balance == 0 { \tfmt.Println(\u0026#34;Balance is equal to 0, add funds soon.\u0026#34;) \t} else { \tfmt.Println(\u0026#34;Your balance is 0 or above.\u0026#34;) \t} } 现在，一旦我们运行该程序，有三种可能的输出：\n 如果变量余额等于0，我们将收到else if语句的输出（`余额等于0，尽快添加资金。） 如果变量balance被设置为一个正数，我们将收到else语句的输出（你的余额为0或以上）。 如果变量balance被设置为一个负数，输出将是if语句的字符串（余额低于0，现在添加资金，否则将被收取罚款）。  如果我们想有三个以上的可能性呢？我们可以通过在代码中写一个以上的else if语句来实现。\n在grade.go程序中，让我们重写代码，以便有几个字母等级对应于数字等级的范围。\n 90分或以上相当于A级 80-89相当于B级 70-79相当于C级 65-69相当于D级 64分或以下相当于F级  要运行这段代码，我们将需要一个if语句，三个else if语句，以及一个处理所有失败情况的else语句。\n让我们重写前面的例子中的代码，让字符串打印出每个字母等级。我们可以保持我们的else语句不变。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tgrade := 60  \tif grade \u0026gt;= 90 { \tfmt.Println(\u0026#34;A grade\u0026#34;) \t} else if grade \u0026gt;= 80 { \tfmt.Println(\u0026#34;B grade\u0026#34;) \t} else if grade \u0026gt;= 70 { \tfmt.Println(\u0026#34;C grade\u0026#34;) \t} else if grade \u0026gt;= 65 { \tfmt.Println(\u0026#34;D grade\u0026#34;) \t} else { \tfmt.Println(\u0026#34;Failing grade\u0026#34;) \t} } 由于else if语句将按顺序评估，我们可以保持我们的语句相当基本。这个程序正在完成以下步骤。\n 如果成绩大于90，程序将打印 \u0026ldquo;A级\u0026rdquo;，如果成绩小于90，程序将继续下一个语句\u0026hellip;。 如果成绩大于或等于80，程序将打印 \u0026ldquo;B级\u0026rdquo;，如果成绩在79或以下，程序将继续下一个语句\u0026hellip;\u0026hellip; 如果成绩大于或等于70，程序将打印 \u0026ldquo;C级\u0026rdquo;，如果成绩是69或更少，程序将继续下一个语句\u0026hellip;\u0026hellip; 如果成绩大于或等于65，程序将打印 \u0026ldquo;D级\u0026rdquo;，如果成绩是64或更少，程序将继续下一个语句\u0026hellip;\u0026hellip; 程序将打印 \u0026ldquo;成绩不合格\u0026rdquo;，因为上述所有的条件都没有满足。  嵌套的If语句 #  一旦你对 if, else if, 和 else语句感到满意，你就可以转到嵌套条件语句。我们可以使用嵌套的if语句来处理这样的情况：如果第一个条件执行为真，我们想检查第二个条件。为此，我们可以在另一个if-else 语句中设置一个if-else 语句。让我们来看看嵌套的if语句的语法。\nif statement1 { // outer if statement \tfmt.Println(\u0026#34;true\u0026#34;)  \tif nested_statement { // nested if statement \tfmt.Println(\u0026#34;yes\u0026#34;) \t} else { // nested else statement \tfmt.Println(\u0026#34;no\u0026#34;) \t}  } else { // outer else statement \tfmt.Println(\u0026#34;false\u0026#34;) } 这段代码可以产生一些可能的输出。\n 如果statement1评估为真，程序将评估nested_statement是否也评估为真。如果这两种情况都是真的，那么输出将是：   true yes   然而，如果statement1评估为真，但nested_statement评估为假，那么输出将是：   true no   而如果statement1评估为false，嵌套的if-else语句将不会运行，所以else语句将单独运行，输出结果为：   false  我们也可以在代码中嵌套多个if语句：\nif statement1 { // outer if \tfmt.Println(\u0026#34;hello world\u0026#34;)  \tif nested_statement1 { // first nested if \tfmt.Println(\u0026#34;yes\u0026#34;)  \t} else if nested_statement2 { // first nested else if \tfmt.Println(\u0026#34;maybe\u0026#34;)  \t} else { // first nested else \tfmt.Println(\u0026#34;no\u0026#34;) \t}  } else if statement2 { // outer else if \tfmt.Println(\u0026#34;hello galaxy\u0026#34;)  \tif nested_statement3 { // second nested if \tfmt.Println(\u0026#34;yes\u0026#34;) \t} else if nested_statement4 { // second nested else if \tfmt.Println(\u0026#34;maybe\u0026#34;) \t} else { // second nested else \tfmt.Println(\u0026#34;no\u0026#34;) \t}  } else { // outer else \tstatement(\u0026#34;hello universe\u0026#34;) } 在这段代码中，除了 else if 语句外，每个 if 语句内都有一个嵌套的 if 语句。这将使每个条件内有更多的选项。\n让我们用grade.go程序来看一个嵌套if语句的例子。可以首先检查一个成绩是否合格（大于或等于65%），然后评估数字成绩应该相当于哪个字母等级。如果成绩不合格，我们就不需要运行字母等级，而可以让程序报告该成绩不合格。修改后的代码和嵌套的 if 语句看起来是这样的：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tgrade := 92 \tif grade \u0026gt;= 65 { \tfmt.Print(\u0026#34;Passing grade of: \u0026#34;)  \tif grade \u0026gt;= 90 { \tfmt.Println(\u0026#34;A\u0026#34;)  \t} else if grade \u0026gt;= 80 { \tfmt.Println(\u0026#34;B\u0026#34;)  \t} else if grade \u0026gt;= 70 { \tfmt.Println(\u0026#34;C\u0026#34;)  \t} else if grade \u0026gt;= 65 { \tfmt.Println(\u0026#34;D\u0026#34;) \t}  \t} else { \tfmt.Println(\u0026#34;Failing grade\u0026#34;) \t} } 如果我们在运行代码时将变量grade设置为整数值92，那么第一个条件就得到了满足，程序将打印出Passing grade of:。接下来，它将检查成绩是否大于或等于90，由于这个条件也被满足，它将打印出A。\n如果我们在运行代码时将grade变量设置为60，那么第一个条件就没有得到满足，所以程序将跳过嵌套的if语句，向下移动到else语句，程序将打印出Failing grade。\n当然，我们可以在此基础上增加更多的选项，并使用第二层嵌套的if语句。也许我们想对A+、A和A-的成绩分别进行评估。我们可以这样做，首先检查成绩是否合格，然后检查成绩是否在90分或以上，然后检查成绩是否在96分以上为A+：\n... if grade \u0026gt;= 65 { \tfmt.Print(\u0026#34;Passing grade of: \u0026#34;)  \tif grade \u0026gt;= 90 { \tif grade \u0026gt; 96 { \tfmt.Println(\u0026#34;A+\u0026#34;)  \t} else if grade \u0026gt; 93 \u0026amp;\u0026amp; grade \u0026lt;= 96 { \tfmt.Println(\u0026#34;A\u0026#34;)  \t} else { \tfmt.Println(\u0026#34;A-\u0026#34;) \t} ... 在这段代码中，对于设置为96的 grade 变量，程序将运行以下程序。\n 检查该等级是否大于或等于65（真）。 打印出 Passing grade of: 检查成绩是否大于或等于90（真）。 检查成绩是否大于96（假）。 检查等级是否大于93，同时小于或等于96（真）。 打印 \u0026ldquo;A\u0026rdquo;。 离开这些嵌套的条件语句，继续执行剩余的代码  因此，成绩为96的程序的输出看起来是这样的：\nPassing grade of: A 嵌套的if语句可以提供机会，在你的代码中添加几个特定级别的条件。\n总结 #  通过使用像 if 语句这样的条件语句，你将对你的程序执行内容有更大的控制。条件性语句告诉程序要评估是否满足某个条件。如果满足条件，它将执行特定的代码，但如果不满足条件，程序将继续执行其他代码。\n要继续练习条件语句，请尝试使用不同的运算符来获得对条件语句的更多熟悉。\n"},{"id":23,"href":"/docs/24-How_To_Write_Switch_Statements_in_Go/","title":"24 How to Write Switch Statements in Go","section":"Docs","content":"如何在Go中编写Switch语句 #  介绍 #  条件语句使程序员有能力指导他们的程序在某个条件为真时采取某些行动，在条件为假时采取另一种行动。经常，我们想把一些变量与多个可能的值进行比较，在每种情况下采取不同的行动。仅仅使用if语句就可以做到这一点。然而，编写软件不仅是为了让事情顺利进行，也是为了向未来的自己和其他开发者传达你的意图。switch是一个替代性的条件语句，对于传达你的Go程序在遇到不同选项时采取的行动很有用。\n我们可以用switch语句编写的所有内容也可以用if语句编写。在本教程中，我们将看几个例子，看看switch语句能做什么，它所取代的if语句，以及它最合适的应用场合。\nSwitch语句的结构 #  Switch通常用于描述当一个变量被分配到特定值时程序所采取的行动。下面的例子演示了我们如何使用 if 语句来完成这个任务。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tflavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;}  \tfor _, flav := range flavors { \tif flav == \u0026#34;strawberry\u0026#34; { \tfmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) \tcontinue \t}  \tif flav == \u0026#34;vanilla\u0026#34; { \tfmt.Println(flav, \u0026#34;is great!\u0026#34;) \tcontinue \t}  \tif flav == \u0026#34;chocolate\u0026#34; { \tfmt.Println(flav, \u0026#34;is great!\u0026#34;) \tcontinue \t}  \tfmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) \t} } 这将输出如下信息：\nchocolate is great! vanilla is great! strawberry is my favorite! I\u0026#39;ve never tried banana before 在main中，我们定义了一个slice的冰激凌口味。然后我们使用一个for loop来迭代它们。我们使用三个if语句来打印不同的信息，表明对不同冰淇淋口味的偏好。每个if语句必须使用continue语句来停止for循环的执行，这样就不会在最后打印出首选冰淇淋口味的默认信息。\n当我们添加新的偏好时，我们必须不断添加if语句来处理新的情况。重复的信息，如 \u0026ldquo;香草\u0026quot;和 \u0026ldquo;巧克力\u0026quot;的情况，必须有重复的if语句。对于我们代码的未来读者（包括我们自己）来说，if语句的重复性掩盖了它们所做的重要部分\u0026ndash;将变量与多个值进行比较并采取不同的行动。另外，我们的回退信息与条件语句分开，使得它看起来不相关。转换器 \u0026ldquo;语句可以帮助我们更好地组织这个逻辑。\nswitch 语句以 switch 关键字开始，在其最基本的形式下，后面是一些要进行比较的变量。之后是一对大括号（{}），其中可以出现多个case子句。case子句描述了当提供给switch语句的变量等于case子句所引用的值时，Go程序应该采取的行动。下面的例子将先前的例子转换为使用一个switch而不是多个if语句：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tflavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;}  \tfor _, flav := range flavors { \tswitch flav { \tcase \u0026#34;strawberry\u0026#34;: \tfmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) \tcase \u0026#34;vanilla\u0026#34;, \u0026#34;chocolate\u0026#34;: \tfmt.Println(flav, \u0026#34;is great!\u0026#34;) \tdefault: \tfmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) \t} \t} } 输出与之前相同：\nchocolate is great! vanilla is great! strawberry is my favorite! I\u0026#39;ve never tried banana before 我们再次在main中定义了一片冰淇淋的口味，并使用range语句来遍历每个口味。但是这一次，我们使用了一个switch语句来检查flav变量。我们使用两个case'子句来表示偏好。我们不再需要继续\u0026rsquo;语句，因为只有一个case子句将被switch语句执行。我们还可以将\u0026quot;巧克力\u0026quot;和 \u0026ldquo;香草\u0026quot;条件的重复逻辑结合起来，在 case子句的声明中用逗号将其分开。default子句是我们的万能子句。它将对我们在 switch 语句中没有考虑到的任何口味运行。在这种情况下，\u0026ldquo;香蕉\u0026quot;将导致 default 的执行，打印出 \u0026ldquo;I\u0026rsquo;ve never tried banana before\u0026quot;的信息。\n这种简化形式的switch语句解决了它们最常见的用途：将一个变量与多个替代品进行比较。它还为我们提供了便利，当我们想对多个不同的值采取相同的行动，以及在没有满足所列的条件时，通过使用所提供的default关键字采取一些其他行动。\n当这种简化的switch形式被证明太有局限性时，我们可以使用一种更通用的switch语句形式。\n通常的 Switch 语句 #  switch语句对于将更复杂的条件集合在一起以显示它们之间有某种联系是很有用的。这在将某些变量与一定范围的值进行比较时最常用，而不是像前面的例子中的特定值。下面的例子使用if语句实现了一个猜谜游戏，可以从switch语句中受益：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;math/rand\u0026#34; \t\u0026#34;time\u0026#34; )  func main() { \trand.Seed(time.Now().UnixNano()) \ttarget := rand.Intn(100)  \tfor { \tvar guess int \tfmt.Print(\u0026#34;Enter a guess: \u0026#34;) \t_, err := fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess) \tif err != nil { \tfmt.Println(\u0026#34;Invalid guess: err:\u0026#34;, err) \tcontinue \t}  \tif guess \u0026gt; target { \tfmt.Println(\u0026#34;Too high!\u0026#34;) \tcontinue \t}  \tif guess \u0026lt; target { \tfmt.Println(\u0026#34;Too low!\u0026#34;) \tcontinue \t}  \tfmt.Println(\u0026#34;You win!\u0026#34;) \tbreak \t} } 输出将取决于所选择的随机数和你玩游戏的程度。下面是一个例子会话的输出：\nEnter a guess: 10 Too low! Enter a guess: 15 Too low! Enter a guess: 18 Too high! Enter a guess: 17 You win! 我们的猜谜游戏需要一个随机数来比较猜测的结果，所以我们使用math/rand包中的rand.Intn函数。为了确保我们每次玩游戏都能得到不同的target值，我们使用rand.Seed来根据当前时间随机化随机数发生器。rand.Intn的参数100将给我们一个0-100范围内的数字。然后我们使用for循环来开始收集玩家的猜测。\nfmt.Scanf函数为我们提供了一种方法来读取用户的输入到我们选择的变量中。它接受一个格式化的字符串动词，将用户的输入转换为我们期望的类型。这里的%d意味着我们期望一个 int，我们传递 guess 变量的地址，这样 fmt.Scanf 就能够设置该变量。在处理任何解析错误之后，我们使用两个if语句来比较用户的猜测和target值。它们返回的string和bool一起控制显示给玩家的信息，以及游戏是否会退出。\n这些 if 语句掩盖了一个事实，即变量被比较的数值范围都有某种联系。一眼就能看出我们是否遗漏了该范围的某些部分，这也是很困难的。下一个例子重构了前面的例子，用switch语句代替：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;math/rand\u0026#34; )  func main() { \ttarget := rand.Intn(100)  \tfor { \tvar guess int \tfmt.Print(\u0026#34;Enter a guess: \u0026#34;) \t_, err := fmt.Scanf(\u0026#34;%d\u0026#34;, \u0026amp;guess) \tif err != nil { \tfmt.Println(\u0026#34;Invalid guess: err:\u0026#34;, err) \tcontinue \t}  \tswitch { \tcase guess \u0026gt; target: \tfmt.Println(\u0026#34;Too high!\u0026#34;) \tcase guess \u0026lt; target: \tfmt.Println(\u0026#34;Too low!\u0026#34;) \tdefault: \tfmt.Println(\u0026#34;You win!\u0026#34;) \treturn \t} \t} } 这将产生类似以下的输出:\nEnter a guess: 25 Too low! Enter a guess: 28 Too high! Enter a guess: 27 You win! 在这个版本的猜谜游戏中，我们用一个switch语句代替了if语句块。我们省略了switch的表达式参数，因为我们只对使用switch来收集条件语句感兴趣。每个case子句包含一个不同的表达式，将guess与target进行比较。与第一次用switch代替if语句类似，我们不再需要continue语句，因为只有一个case子句会被执行。最后，default子句处理guess == target的情况，因为我们已经用另外两个case子句覆盖了所有其他可能的值。\n在我们目前看到的例子中，正好有一个case语句将被执行。偶尔，你可能希望结合多个case子句的行为。switch语句提供了另一个实现这种行为的关键字。\nFallthrough #  有时你想重复使用另一个 case 子句包含的代码。在这种情况下，可以使用 fallthrough 关键字要求Go运行下一个 case 子句的主体。下面这个例子修改了我们之前的冰淇淋口味的例子，以更准确地反映我们对草莓冰淇淋的热情：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tflavors := []string{\u0026#34;chocolate\u0026#34;, \u0026#34;vanilla\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;banana\u0026#34;}  \tfor _, flav := range flavors { \tswitch flav { \tcase \u0026#34;strawberry\u0026#34;: \tfmt.Println(flav, \u0026#34;is my favorite!\u0026#34;) \tfallthrough \tcase \u0026#34;vanilla\u0026#34;, \u0026#34;chocolate\u0026#34;: \tfmt.Println(flav, \u0026#34;is great!\u0026#34;) \tdefault: \tfmt.Println(\u0026#34;I\u0026#39;ve never tried\u0026#34;, flav, \u0026#34;before\u0026#34;) \t} \t} } 将得到如下输出：\nchocolate is great! vanilla is great! strawberry is my favorite! strawberry is great! I\u0026#39;ve never tried banana before 正如我们之前看到的，我们定义了一个 string 片段来表示口味，并使用 for 循环来迭代。这里的 switch 语句与我们之前看到的语句相同，但是在 case 子句的末尾添加了 fallthrough 关键字，即 strawberry。这将使Go运行case \u0026quot;strawberry\u0026quot;:的主体，首先打印出字符串strawberry is my favorite!。当它遇到fallthrough时，它将运行下一个case子句的主体。这将导致case \u0026quot;vanilla\u0026quot;, \u0026quot;chocolate\u0026quot;:的主体运行，打印出strawberry is great!。\nGo开发人员不经常使用fallthrough关键字。通常情况下，通过使用fallthrough实现的代码重用，可以通过定义一个具有公共代码的函数来更好地获得。由于这些原因，一般不鼓励使用fallthrough。\n总结 #  switch语句帮助我们向阅读代码的其他开发者传达出彼此有某种联系。使我们在将来添加新的情况时更容易添加不同的行为，并有可能确保任何忘记的事情也能通过default子句得到正确处理。下次你发现自己写的多个if语句都涉及同一个变量时，试着用switch语句重写它\u0026ndash;你会发现当需要考虑其他值时，它将更容易重写。\n如果你想了解更多关于Go编程语言的信息，请查看整个How To Code in Go系列\n"},{"id":24,"href":"/docs/25_How_To_Construct_For_Loops_in_Go/","title":"25 How to Construct for Loops in Go","section":"Docs","content":"如何在 Go 中构造 for 循环 #  介绍 #  在计算机编程中，循环 是在满足某些条件之前循环重复执行一段代码的代码结构。在计算机编程中使用循环可以让您自动并重复地执行类似的任务。想象一下，如果您有一个需要处理的文件列表，或者您想计算一篇文章的行数。您就可以在代码中使用循环来解决这样的问题。\n在 Go 中，for 循环是基于循环计数器或循环变量实现代码的重复执行。与其他具有多个循环结构（例如 while ， do 等 ）的编程语言不同，Go 只有 for 循环。这有助于使您的代码更清晰和更具可读性，因为您不必担心会有多种策略来实现相同的循环结构。在开发过程中，这种强可读性和低认知负担也将使您的代码比其他语言更不容易出错。\n在本教程中，您将了解 Go 中 for 循环是如何工作的，包括其使用的三个主要变体。我们将首先展示如何创建不同类型的 for 循环，然后介绍如何在 Go 中遍历顺序数据类型。最后，我们将解释如何使用嵌套循环。\n声明 ForClause 和 Condition 循环 #  为了适应各种用例，在 Go 中创建 for 循环有三种不同的方法，每种方法都有自己的功能。这些是使用 Condition、ForClause 或 RangeClause 创建 for 循环。在本节中，我们将解释如何声明和使用 ForClause 和 Condition 变体。\n让我们先看看如何在 ForClause 中使用 for 循环。\nForClause循环 被定义为有一个 初始语句，后跟一个 条件，然后是一个 后置语句。它们按以下语法排列：\nfor [ Initial Statement ] ; [ Condition ] ; [ Post Statement ] {  [Action] } 为了解释前面组成元素的作用，让我们看一个使用 ForClause 语法在指定值范围内递增的 for 循环：\nfor i := 0; i \u0026lt; 5; i++ { \tfmt.Println(i) } 让我们分解这个循环并识别每个部分\n循环的第一部分是 i := 0 ，这是初始语句：\nfor i := 0; i \u0026lt; 5; i++ { \tfmt.Println(i) } 它表明我们正在声明一个名为 i 的变量，并将初始值设置为 0。\n接下来是条件：\nfor i := 0; i \u0026lt; 5; i++ { \tfmt.Println(i) } 在这种情况下，我们声明当 i 小于 5 时，循环应该继续。\n最后，是一个后置语句：\nfor i := 0; i \u0026lt; 5; i++ { \tfmt.Println(i) } 在后置语句中，循环遍历 i 以 i++ 增量运算符进行迭代加一。\n当我们运行这个程序时，输出如下所示：\nOutput 0 1 2 3 4 循环运行了 5 次。最初，设置 i 为 0，然后检查是否 i 小于5。由于 i 的值小于 5 ，因此执行了循环并执行了 fmt.Println(i) 的动作。循环结束时， 调用 i++ 语句，使 i 的值加 1。\n注意： 请记住，在编程中我们倾向于从索引 0 开始，这就是为什么虽然打印了 5 个数字，但它们的范围是 0-4。\n我们不会限制必须从 0 开始或者以某个特定值结束。我们可以为我们的初始语句分配任何值，也可以在我们的后置语句中赋予任何值。这允许我们创建任何所需的范围来循环：\nfor i := 20; i \u0026lt; 25; i++ { \tfmt.Println(i) } 在这里，迭代会从 20（包括）到 25（不包括），所以输出如下所示：\nOutput 20 21 22 23 24 我们还可以使用我们的后置语句以不同的值递增。这类似于其他语言中的 step：\n首先，让我们使用正值递增的后置语句：\nfor i := 0; i \u0026lt; 15; i += 3 { \tfmt.Println(i) } 在这种情况下，设置 for 循环以便打印出从 0 到 15 的数字，但增量为 3，因此每三个数字打印一次，如下所示：\nOutput 0 3 6 9 12 我们也可以为我们的后置语句使用负值来向后迭代，但我们必须相应地调整我们的初始语句和条件参数：\nfor i := 100; i \u0026gt; 0; i -= 10 { \tfmt.Println(i) } 在这里，我们将 i 初始值设置为100，使用 i \u0026lt; 0 的条件在处停止，并且后置语句使用 -= 运算符将值减 10。循环开始于 100 并结束于 0，每次迭代减少 10。我们可以在输出中看到这种情况：\nOutput 100 90 80 70 60 50 40 30 20 10 您也可以从语法中不使用初始语句和后置语句，而只使用条件。这就是所谓的 Condition循环：\ni := 0 for i \u0026lt; 5 { \tfmt.Println(i) \ti++ } 这一次，我们在前面的代码行中将变量声明为 i 与循环分开。该循环只有一个条件子句，用于检查 i 是否小于5。只要条件为 true，循环就会继续迭代。\n有时您可能不知道完成某项任务所需的迭代次数。在这种情况下，您可以省略所有语句，并使用 break 关键字退出执行：\nfor { \tif someCondition { \tbreak \t} \t// do action here } 这方面的一个例子可能是，如果我们正在从一个不确定大小的结构（如缓冲区）中读取，并且我们不知道何时完成读取：\npackage main  import ( \t\u0026#34;bytes\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;io\u0026#34; )  func main() { \tbuf := bytes.NewBufferString(\u0026#34;one\\ntwo\\nthree\\nfour\\n\u0026#34;)  \tfor { \tline, err := buf.ReadString(\u0026#39;\\n\u0026#39;) \tif err != nil { \tif err == io.EOF {  \tfmt.Print(line) \tbreak \t} \tfmt.Println(err) \tbreak \t} \tfmt.Print(line) \t} } 在前面的代码中，buf :=bytes.NewBufferString(\u0026quot;one\\ntwo\\nthree\\nfour\\n\u0026quot;) 声明了一个包含一些数据的缓冲区。因为我们不知道缓冲区何时会完成读取，所以我们创建了一个没有子句的 for 循环。在 for 循环内部，我们使用 line, err := buf.ReadString('\\n') 从缓冲区读取一行并检查从缓冲区读取是否有错误。如果有，我们解决错误，并使用 break 关键字退出 for 循环。有了break，您就不需要使用停止循环的条件。\n在本节中，我们学习了如何声明 ForClause 循环并使用它来迭代已知范围的值。我们还学习了如何使用 Condition循环进行迭代，直到满足特定条件。接下来，我们将了解 RangeClause 如何用于迭代顺序数据类型。\n使用 RangeClause 循环遍历顺序数据类型 #  在 Go 中，使用 for 循环来迭代连续或集合数据类型（如切片、数组和字符串）的元素是很常见的。为了更容易做到这一点，我们可以使用带有 RangeClause 语法的 for 循环。虽然您可以使用 ForClause 语法遍历顺序数据类型，但 RangeClause 更简洁且更易于阅读。\n在我们研究使用 RangeClause 之前，让我们看看如何使用 ForClause 语法遍历切片：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \tfor i := 0; i \u0026lt; len(sharks); i++ { \tfmt.Println(sharks[i]) \t} } 运行它将给出以下输出，打印出切片的每个元素：\nOutput hammerhead great white dogfish frilled bullhead requiem 现在，让我们使用 RangeClause 执行相同的操作：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \tfor i, shark := range sharks { \tfmt.Println(i, shark) \t} } 在这种情况下，我们打印出列表中的每个项。虽然我们使用了变量 i 和 shark ，但我们可以将变量称为任何其他有效的变量名，我们会得到相同的输出：\nOutput 0 hammerhead 1 great white 2 dogfish 3 frilled 4 bullhead 5 requiem 在切片上使用 range 时，它将始终返回两个值。第一个值将是当前迭代所在的索引，第二个是该索引处的值。在这个示例中，对于第一次迭代，索引是 0，值是 hammerhead。\n有时，我们只想要切片元素内的值，而不是索引。但是，如果我们将前面的代码更改为仅打印值，我们将收到编译时错误：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \tfor i, shark := range sharks { \tfmt.Println(shark) \t} } Output src/range-error.go:8:6: i declared and not used 因为 i 在 for 循环中声明了，但从未使用过，编译器会报告 i declared and not used。每当您声明一个变量并且不使用它时，您都会在 Go 中收到相同的错误。\n因此，Go 具有空白标识符，即下划线 ( _ )。在 for 循环中，您可以使用空白标识符来忽略从 range 关键字返回的任何值。在这种情况下，我们要忽略索引，它是返回的第一个参数。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \tfor _, shark := range sharks { \tfmt.Println(shark) \t} } Output hammerhead great white dogfish frilled bullhead requiem 输出显示 for 循环遍历字符串切片，并打印切片中每个项，且不会打印索引。\n您也可以使用 range 将项目添加到列表中：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsharks := []string{\u0026#34;hammerhead\u0026#34;, \u0026#34;great white\u0026#34;, \u0026#34;dogfish\u0026#34;, \u0026#34;frilled\u0026#34;, \u0026#34;bullhead\u0026#34;, \u0026#34;requiem\u0026#34;}  \tfor range sharks { \tsharks = append(sharks, \u0026#34;shark\u0026#34;) \t}  \tfmt.Printf(\u0026#34;%q\\n\u0026#34;, sharks) } Output [\u0026#39;hammerhead\u0026#39;, \u0026#39;great white\u0026#39;, \u0026#39;dogfish\u0026#39;, \u0026#39;frilled\u0026#39;, \u0026#39;bullhead\u0026#39;, \u0026#39;requiem\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;, \u0026#39;shark\u0026#39;] 在这里，我们为切片 \u0026quot;shark\u0026quot; 添加了切片长度的占位符字符串 sharks。\n请注意，我们不必使用空白标识符 _ 来忽略 range 运算符的任何返回值。如果我们不需要使用任何一个 range 的返回值，Go 允许我们省略语句的整个声明部分。\n我们也可以使用 range 运算符来填充切片的值\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tintegers := make([]int, 10) \tfmt.Println(integers)  \tfor i := range integers { \tintegers[i] = i \t}  \tfmt.Println(integers) } 在这个例子中，切片 integers 初始化了十个空值，但 for 循环会设置列表中的所有值，如下所示：\nOutput [0 0 0 0 0 0 0 0 0 0] [0 1 2 3 4 5 6 7 8 9] 第一次打印切片 integers 的值时，我们看到全为零。然后我们遍历每个索引并将值设置为当前索引。然后当我们第二次打印值integers 时，显示它们现在都具有0 到 9 的值。\n我们也可以使用 range 运算符来遍历字符串中的每个字符：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsammy := \u0026#34;Sammy\u0026#34;  \tfor _, letter := range sammy { \tfmt.Printf(\u0026#34;%c\\n\u0026#34;, letter) \t} } Output S a m m y 当遍历 map 时，range将返回键和值：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsammyShark := map[string]string{\u0026#34;name\u0026#34;: \u0026#34;Sammy\u0026#34;, \u0026#34;animal\u0026#34;: \u0026#34;shark\u0026#34;, \u0026#34;color\u0026#34;: \u0026#34;blue\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;ocean\u0026#34;}  \tfor key, value := range sammyShark { \tfmt.Println(key + \u0026#34;: \u0026#34; + value) \t} } Output color: blue location: ocean name: Sammy animal: shark 注意：map 返回的顺序是随机的。每次运行此程序时，您可能会得到不同的结果。\n现在我们已经学会了如何使用 range for 循环来遍历数据，下面让我们看看如何在循环中使用循环。\n嵌套 For 循环 #  就像其他编程语言一样，在 Go 中循环也是可以嵌套的。嵌套 是当我们在一个结构内又使用了一个结构。在这种情况下，嵌套循环是发生在另一个循环中的循环。当您希望对数据集的每个元素执行循环操作时，这些可能很有用。\n嵌套循环在结构上类似于嵌套if语句。它的构造如下：\nfor {  [Action]  for {  [Action]  } } 程序首先遇到外循环，执行它的第一次迭代。第一次迭代触发内部嵌套循环，然后运行完成。然后程序返回到外部循环的顶部，完成第二次迭代并再次触发嵌套循环。同样，嵌套循环运行到完成，程序返回到外部循环的顶部，直到序列完成或中断或其他语句中断该过程。\n让我们实现一个嵌套 for 循环，以便我们仔细看看。在这个例子中，外层循环将遍历一个名为 numList 的整数切片，而内层循环将遍历一个名为 alphaList 的字符串切片。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tnumList := []int{1, 2, 3} \talphaList := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}  \tfor _, i := range numList { \tfmt.Println(i) \tfor _, letter := range alphaList { \tfmt.Println(letter) \t} \t} } 当我们运行这个程序时，我们将得到以下输出：\nOutput 1 a b c 2 a b c 3 a b c 输出说明程序通过打印 1 完成了外循环的第一次迭代，然后连续触发内循环打印的完成。内循环完成后，程序返回到外循环的顶部，打印 2，然后再次完整打印内循环（a, b, c）等。\n嵌套 for 循环可用于遍历由切片组成的切片中的项。在由切片组成的切片中，如果我们只使用一个 for 循环，程序会将每个内部列表作为一项输出：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tints := [][]int{ \t[]int{0, 1, 2}, \t[]int{-1, -2, -3}, \t[]int{9, 8, 7}, \t}  \tfor _, i := range ints { \tfmt.Println(i) \t} } Output [0 1 2] [-1 -2 -3] [9 8 7] 为了访问内部切片的每个单独项，我们将实现一个嵌套for循环：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tints := [][]int{ \t[]int{0, 1, 2}, \t[]int{-1, -2, -3}, \t[]int{9, 8, 7}, \t}  \tfor _, i := range ints { \tfor _, j := range i { \tfmt.Println(j) \t} \t} } Output 0 1 2 -1 -2 -3 9 8 7 当我们在这里使用嵌套 for 循环时，我们能够迭代切片中包含的各个项。\n结论 #  在本教程中，我们学习了如何声明和使用 for 循环来解决 Go 中的重复任务。我们还学习了 for 循环的三种不同变体以及何时使用它们。要了解有关 for 循环以及如何控制它们的流程的更多信息，请阅读在 Go 中使用循环时的 Break 和 Continue 语句。\n"},{"id":25,"href":"/docs/26_Using_Break_and_Continue_Statements_When_Working_with_Loops_in_Go/","title":"26 Using Break and Continue Statements When Working With Loops in Go","section":"Docs","content":"在循环中使用 Break 和 Continue #  介绍 #  在 Go 中使用 for 循环可以让您以有效的方式自动化重复任务。\n学习如何控制循环的操作和流程将允许在您的程序中自定义逻辑。您可以使用 break 和 continue 语句控制循环\nBreak 语句 #  在 Go 中， break 语句终止当前循环的执行。break几乎总是与条件if语句配对。\n让我们看一个在循环中使用break语句的示例：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfor i := 0; i \u0026lt; 10; i++ { \tif i == 5 { \tfmt.Println(\u0026#34;Breaking out of loop\u0026#34;) \tbreak // break here \t} \tfmt.Println(\u0026#34;The value of i is\u0026#34;, i) \t} \tfmt.Println(\u0026#34;Exiting program\u0026#34;) } 这个小程序创建了一个 for循环，该循环在当 i 小于 10 时进行迭代。\n在 for 循环中，有一个if语句。该 if语句会检查 i 的值是否小于 5。如果 i 的值不等于 5，则循环继续并打印出 i 的值。如果 i 的值等于 5，则循环将执行 break 语句，打印 Breaking out of loop，并停止循环。在程序结束时，我们打印出 Exiting program 表示我们已经退出了循环。\n当我们运行此代码时，输出将如下所示：\nOutput The value of i is 0 The value of i is 1 The value of i is 2 The value of i is 3 The value of i is 4 Breaking out of loop Exiting program 这表明，一旦整数 i 被检查为等于 5，循环就会中断，因为程序使用 break 语句来这样做。\n嵌套循环 #  要记住，break 语句只会停止调用它的最内层循环的执行。如果您有一组嵌套循环，如果需要的话，您将需要为每个循环设置break。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfor outer := 0; outer \u0026lt; 5; outer++ { \tif outer == 3 { \tfmt.Println(\u0026#34;Breaking out of outer loop\u0026#34;) \tbreak // break here \t} \tfmt.Println(\u0026#34;The value of outer is\u0026#34;, outer) \tfor inner := 0; inner \u0026lt; 5; inner++ { \tif inner == 2 { \tfmt.Println(\u0026#34;Breaking out of inner loop\u0026#34;) \tbreak // break here \t} \tfmt.Println(\u0026#34;The value of inner is\u0026#34;, inner) \t} \t} \tfmt.Println(\u0026#34;Exiting program\u0026#34;) } 在这个程序中，我们有两个循环。虽然两个循环都迭代 5 次，但每个循环都有一个带有 break 语句的 if 条件语句。outer 如果等于 3，外部循环将中断。如果 inner 值为 2 ，内部循环将中断。\n如果我们运行程序，可以看到输出：\nOutput The value of outer is 0 The value of inner is 0 The value of inner is 1 Breaking out of inner loop The value of outer is 1 The value of inner is 0 The value of inner is 1 Breaking out of inner loop The value of outer is 2 The value of inner is 0 The value of inner is 1 Breaking out of inner loop Breaking out of outer loop Exiting program 请注意，每次内循环中断时，外循环都不会中断。这是因为break 只会中断调用它的最内层循环。\n我们已经看到 break 是如何停止循环的。接下来，让我们看看 continue 如何继续循环的。\nContinue 语句 #  当您想要跳过循环的剩余部分并返回循环顶部继续新的迭代时，可以使用 continue 语句。\n与 break 语句一样，continue 语句通常与 if 条件语句一起使用。\n使用与前面的Break 语句部分相同的 for 循环程序，这里我们将使用 continue 语句而不是 break 语句：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfor i := 0; i \u0026lt; 10; i++ { \tif i == 5 { \tfmt.Println(\u0026#34;Continuing loop\u0026#34;) \tcontinue // break here \t} \tfmt.Println(\u0026#34;The value of i is\u0026#34;, i) \t} \tfmt.Println(\u0026#34;Exiting program\u0026#34;) } 使用 continue 语句而不是 break 语句的区别在于，当变量 i 等于 5 时，尽管出现中断，我们的代码仍将继续执行。让我们看看我们的输出：\nOutput The value of i is 0 The value of i is 1 The value of i is 2 The value of i is 3 The value of i is 4 Continuing loop The value of i is 6 The value of i is 7 The value of i is 8 The value of i is 9 Exiting program 在这里，我们看到 The value of i is 5 没有出现在输出中，但循环在该点之后继续打印数字 6-10 的行，然后结束循环。\n您可以使用 continue 语句来避免深度嵌套的条件代码，或者通过消除您想要拒绝的一些频繁发生的情况来优化循环。\ncontinue 语句能够让程序跳过循环中出现的某些情况，然后继续循环的其余部分。\n结论 #  Go 中的 break and continue 语句将允许您在代码中更高效地使用 for 循环。\n"},{"id":26,"href":"/docs/27_How_To_Define_and_Call_Functions_in_Go/","title":"27 How to Define and Call Functions in Go","section":"Docs","content":"如何在 Go 中定义并调用函数 #  介绍 #  _函数_是一段一旦定义，就可以重用的代码。函数的作用在于可以通过将在整个程序中多次使用的代码分解为更小、更可理解的任务，从而使您的代码更易于理解。\nGo 附带了强大的标准库，其中包含许多预定义的函数。您可能已经熟悉了fmt包：\n fmt.Println() 会将对象打印到标准输出（最可能在您的终端）。 fmt.Printf() 允许您将输出格式化打印。  函数名称包括括号，并且可能包括参数。\n在本教程中，我们将介绍如何定义您自己的函数以在您的项目中使用。\n定义一个函数 #  让我们从经典的“Hello, World!”程序开始理解函数。\n我们将在一个文本编辑器中创建一个新的文本文件，然后调用程序 hello.go。然后，我们将在里面定义函数。\nGo中使用 func 关键字来定义函数。然后是您选择的名称和一组括号，其中包含函数将采用的任何参数（它们可以为空）。函数代码行用大括号 {} 括起来。\n在这种情况下，我们将定义一个名为 hello() 的函数：\nfunc hello() {} 这就是用于创建函数的初始语句。\n基于此，我们将添加第二行来提供函数功能的说明。我们将打印 Hello, World! 到控制台：\nfunc hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在我们的函数已经完全定义好了，但是如果我们此时运行程序，什么都不会发生，因为我们没有调用函数。\n因此，在我们的 main() 代码块中，来调用 hello() 函数：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \thello() }  func hello() { \tfmt.Println(\u0026#34;Hello, World!\u0026#34;) } 现在，让我们运行程序：\n$ go run hello.go 您将收到以下输出：\nOutput Hello, World! 请注意，我们还引入了一个名为 main() 的函数。main() 函数是一个特殊的函数，它告诉编译器程序应该从这里开始。对于 可执行 的任何程序（可以从命令行运行的程序），都需要一个 main() 函数。main() 函数只能在 main() 包 中出现一次，并且不接收和返回任何参数。在任何 Go 程序中程序执行都是这样的。根据以下示例：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println(\u0026#34;this is the main section of the program\u0026#34;) } 函数可以比我们定义的 hello() 函数更复杂。我们可以在函数中使用for循环、条件语句等。\n例如，以下函数使用条件语句检查 name 变量的输入是否包含元音，并使用 for 循环遍历 name 字符串中的字母。\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  func main() { \tnames() }  func names() { \tfmt.Println(\u0026#34;Enter your name:\u0026#34;)  \tvar name string \tfmt.Scanln(\u0026amp;name) \t// Check whether name has a vowel \tfor _, v := range strings.ToLower(name) { \tif v == \u0026#39;a\u0026#39; || v == \u0026#39;e\u0026#39; || v == \u0026#39;i\u0026#39; || v == \u0026#39;o\u0026#39; || v == \u0026#39;u\u0026#39; { \tfmt.Println(\u0026#34;Your name contains a vowel.\u0026#34;) \treturn \t} \t} \tfmt.Println(\u0026#34;Your name does not contain a vowel.\u0026#34;) } 我们在这里定义的 names() 函数设置一个带有输入的变量 name，然后在一个 for 循环中设置一个条件语句。这显示了如何在函数定义中组织代码。但是，根据我们对程序的意图以及我们对代码的安排，我们可能希望将条件语句和循环定义为两个独立的函数。\n在程序中定义函数可使我们的代码更模块化和可重用，这样我们就可以调用相同的函数而无需重写它们。\n使用参数 #  到目前为止，我们已经研究了带有空括号且不带参数的函数，但我们是可以在函数定义中的括号内定义参数的。\n参数 是函数定义中的命名实体，指定函数可以接受的参数。在 Go 中，您必须为每个参数指定数据类型。\n让我们创建一个将单词重复指定次数的程序。它将接受一个 string 类型的 word 参数和一个用于重复单词的次数的 int 类型参数 reps。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \trepeat(\u0026#34;Sammy\u0026#34;, 5) }  func repeat(word string, reps int) { \tfor i := 0; i \u0026lt; reps; i++ { \tfmt.Print(word) \t} } 我们分别为 word 参数和 reps 参数传递了Sammy 和 5 值。这些值按照给定的顺序与每个参数相对应。repeat 函数有一个 for 循环，将循环参数 reps 指定的次数。对于每次循环，都会打印参数 word 的值。\n这是程序的输出：\nOutput SammySammySammySammySammy 如果你有一组参数都是相同的值，你可以不用每次指定类型。让我们创建一个小程序，它接受都是 int 值的参数 x, y, 和 z 这些。我们将创建一个函数，函数将打印他们的总和。下面我们将调用该函数并将数字传递给该函数。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \taddNumbers(1, 2, 3) }  func addNumbers(x, y, z int) { \ta := x + y \tb := x + z \tc := y + z \tfmt.Println(a, b, c) } 当我们创建 addNumbers 的函数签名时，我们不需要每次都指定类型，而只需要在最后指定。\n我们将数字 1 传入参数 x，2 传入参数 y，3 传入参数 z。这些值按照给定的顺序与每个参数对应。\n该程序会根据我们传递参数的值进行以下数学运算：\na = 1 + 2 b = 1 + 3 c = 2 + 3 该函数会打印 a，b， c 的值。基于这个数学运算，我们期望 a 等于 3， b 等于 4，c 等于 5。让我们运行程序：\n$ go run add_numbers.go Output 3 4 5 当我们将 1、2 和 3 作为参数传递给 addNumbers() 函数时，我们会收到预期的输出。\n在函数定义中的参数通常是作为变量使用，当您运行方法时，会将参数传递给函数，并为它们赋值。\n返回值 #  您可以将参数值传递给函数，一个函数也可以产生值。\n函数可以通过 return 语句生成一个值，return 语句将退出函数并 可选地 将表达式传递回调用者。返回的数据类型必须是指定过的。\n到目前为止，我们在函数中使用了fmt.Println() 语句而不是 return 语句。让我们创建一个程序，返回一个变量。\n在一个名为 double.go 的新文本文件中，我们将创建一个将参数 x 加倍并返回变量 y 的程序。我们将 3 作为double() 函数的参数，然后打印 result 的值。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tresult := double(3) \tfmt.Println(result) }  func double(x int) int { \ty := x * 2 \treturn y } 我们可以运行程序并查看输出：\n$ go run double.go Output 6 整数 6 将作为输出返回，这正是所期望的 3 乘以 2的结果。\n如果函数指定了返回值，则必须在代码中提供返回值。否则，将收到编译错误。\n我们可以通过用 return 语句注释掉这一行来证明这一点：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tresult := double(3) \tfmt.Println(result) }  func double(x int) int { \ty := x * 2 \t// return y } 现在，让我们再次运行程序：\n$ go run double.go Output ./double.go:13:1: missing return at end of function 如果不使用此处的 return 语句，程序将无法编译。\n函数在遇到 return 语句时立即退出，即使它们不在函数末尾：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tloopFive() }  func loopFive() { \tfor i := 0; i \u0026lt; 25; i++ { \tfmt.Print(i) \tif i == 5 { \t// Stop function at i == 5 \treturn \t} \t} \tfmt.Println(\u0026#34;This line will not execute.\u0026#34;) } 这里我们设置一个 for 循环，循环运行 25 次。但是，在 for 循环内部，我们有一个条件语句来检查 i 的值是否等于 5。如果等于，我们将 return 进行返回。因为我们在 loopFive 函数中，所以函数中的任何一个 return 都会退出函数。所以，我们永远不会到达该函数的最后一行来打印 This line will not execute.语句。\n在 for 循环内使用了 return 语句来结束函数，因此循环外的行将不会运行。相反，如果我们使用了break语句，那么此时只有循环会退出，最后 fmt.Println() 一行会被运行。\nreturn 语句能够退出一个函数，并且如果在函数签名中指定，则会返回一个值。\n返回多个值 #  一个函数可以指定多个返回值。让我们编写 repeat.go 程序并让它返回两个值。第一个返回值是得到的最终重复值，第二个返回值在参数 reps 小于等于 0 时会得到一个错误。\n package main  import \u0026#34;fmt\u0026#34;  func main() { \tval, err := repeat(\u0026#34;Sammy\u0026#34;, -1) \tif err != nil { \tfmt.Println(err) \treturn \t} \tfmt.Println(val) }  func repeat(word string, reps int) (string, error) { \tif reps \u0026lt;= 0 { \treturn \u0026#34;\u0026#34;, fmt.Errorf(\u0026#34;invalid value of %d provided for reps. value must be greater than 0.\u0026#34;, reps) \t} \tvar value string \tfor i := 0; i \u0026lt; reps; i++ { \tvalue = value + word \t} \treturn value, nil } repeat 函数首先检查 reps 参数是否为有效值。任何不大于 0 的值都会导致错误。由于我们传入了 -1，因此该代码分支将执行。请注意，当我们从函数返回时，我们必须同时提供 string 和 error 的返回值。因为提供的参数导致了错误，我们将为第一个返回值传回一个空白字符串，为第二个返回值传回错误。\n在 main() 函数中，我们可以通过声明两个新变量来接收两个返回值，value 和 err。因为返回中可能有错误，我们想在继续程序之前检查是否收到错误。在这个例子中，我们确实收到了一个错误。我们打印出错误并 return 返回退出main() 函数以退出程序。\n如果没有错误，我们将打印出函数的返回值。\n注意： 最好只返回两个或三个值。此外，您应该始终将错误作为函数的最后一个返回值返回。\n运行程序将产生以下输出：\nOutput invalid value of -1 provided for reps. value must be greater than 0. 在本节中，我们回顾了如何使用 return 语句从函数返回多个值。\n结论 #  函数是在程序中执行操作指令的代码块，有助于使我们的代码更好地可重用和模块化。\n要了解有关如何使您的代码更模块化的更多信息，您可以阅读我们关于如何在 Go 中编写包的指南。\n"},{"id":27,"href":"/docs/28_How_To_Use_Variadic_Functions_in_Go/","title":"28 How to Use Variadic Functions in Go","section":"Docs","content":"如何在 Go 中使用可变参数函数 #  介绍 #  可变参数函数 是可以接受零个、一个或多个值作为单个参数的函数。虽然可变参数函数并不常见，但它们能够使您的代码更清晰、更具可读性。\n可变参数函数其实很常见。最常见的是fmt包中的 Println。\nfunc Println(a ...interface{}) (n int, err error) 参数前面带有一组省略号 ( ... )的函数被视为可变参数函数。省略号表示提供的参数可以是零个、一个或多个。对于fmt.Println包，它声明参数a是可变参数。\n让我们创建一个使用 fmt.Println 函数并传入零个、一个或多个值的程序：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tfmt.Println() \tfmt.Println(\u0026#34;one\u0026#34;) \tfmt.Println(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;) \tfmt.Println(\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;) } 第一次调用 fmt.Println 时，我们不传递任何参数。第二次调用时，我们只传入一个参数，值为 one。 然后我们传递 one 和 two，最后是 one，two 和 three 三个值。\n让我们使用以下命令运行程序：\n$ go run print.go 我们将看到以下输出：\nOutput one one two one two three 输出的第一行为空。这是因为我们在第一次调用 fmt.Println 时没有传递任何参数。第二次打印了 one 。然后打印 one 和 two，最后打印 one，two 和 three。\n现在我们已经了解了如何调用可变参数函数，让我们看看如何定义自己的可变参数函数。\n定义可变参数函数 #  我们可以通过在参数前面使用省略号 ( ... ) 来定义可变参数函数。让我们创建一个程序，当人们的名字被发送到函数时会进行问候：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsayHello() \tsayHello(\u0026#34;Sammy\u0026#34;) \tsayHello(\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) }  func sayHello(names ...string) { \tfor _, n := range names { \tfmt.Printf(\u0026#34;Hello %s\\n\u0026#34;, n) \t} } 我们创建了一个 sayHello 函数，它只接受一个名为names，该参数是可变参数，因为我们在数据类型之前放置了一个省略号 (...)： ...string。这告诉 Go 这个函数可以接受零个、一个或多个参数。\nsayHello 函数将 names 参数作为 slice 接收。由于数据类型是 string，因此 names 可以将参数视为字符串切片 ( []string ) 。我们可以使用range运算符创建一个循环并遍历字符串切片。\n如果我们运行程序，我们将得到以下输出：\nOutput Hello Sammy Hello Sammy Hello Jessica Hello Drew Hello Jamie 请注意，我们第一次调用 sayHello 什么也没打印。这是因为可变参数是一个空的字符串切片。 由于我们会遍历切片，因此没有任何内容可以迭代，并且 fmt.Printf 永远不会被调用。\n让我们修改程序以检测接收到值的情况：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tsayHello() \tsayHello(\u0026#34;Sammy\u0026#34;) \tsayHello(\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) }  func sayHello(names ...string) { \tif len(names) == 0 { \tfmt.Println(\u0026#34;nobody to greet\u0026#34;) \treturn \t} \tfor _, n := range names { \tfmt.Printf(\u0026#34;Hello %s\\n\u0026#34;, n) \t} } 现在，通过使用if语句，如果没有传递任何值，则 names 长度将为 0，我们将打印出nobody to greet：\nOutput nobody to greet Hello Sammy Hello Sammy Hello Jessica Hello Drew Hello Jamie 使用可变参数可以使您的代码更具可读性。让我们创建一个函数，将单词通过指定的分隔符连接在一起。我们将首先创建没有可变参数函数的程序来展示它的读取方式：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tline = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;}) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;}) \tfmt.Println(line) }  func join(del string, values []string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } 在这个程序中，我们将逗号 (,) 作为分隔符传递给 join 函数，再传递一个字符串切片。输出如下：\nOutput Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 因为该函数将字符串切片作为 values 参数，所以当我们调用 join 函数时，我们必须将所有单词包装在一个切片中。这会使代码难以阅读。\n现在，让我们编写相同的函数，但我们将使用可变参数函数：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) \tfmt.Println(line) }  func join(del string, values ...string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } 如果我们运行该程序，可以看到我们得到了与之前的程序相同的输出：\nOutput Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 虽然这两个版本的 join 函数执行完全相同的操作，但可变参数函数的版本在调用时更容易阅读。\n可变参数顺序 #  一个函数中只能有一个可变参数，并且它必须是函数定义中的最后一个参数。将可变参数放在最后位置以外的任何顺序在函数定义会导致编译错误：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) \tfmt.Println(line) }  func join(values ...string, del string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } 这次我们把 values 参数放在 join 函数的首位时，将导致以下编译错误：\nOutput ./join_error.go:18:11: syntax error: cannot use ... with non-final parameter values 定义任何可变参数函数时，只有最后一个参数可以是可变参数。\n分解参数 #  到目前为止，我们已经看到我们可以将零个、一个或多个值传递给可变参数函数。但是，有时我们有一个切片并且我们希望将它们发送到可变参数函数。\n让我们用上一节中的 join 函数尝试一下，看看会发生什么：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tnames := []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}  \tline = join(\u0026#34;,\u0026#34;, names) \tfmt.Println(line) \t}  func join(del string, values ...string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } 如果我们运行这个程序，我们会收到一个编译错误：\nOutput ./join-error.go:10:14: cannot use names (type []string) as type string in argument to join 即使可变参数函数将 values ...string 参数转换为字符串切片 []string，我们也不能将字符串切片作为参数传递。这是因为编译器需要的是字符串的离散参数。\n为了解决这个问题，我们可以通过在 切片 后面加上一组省略号 (...) 来分解切片，将其转换为离散参数，然后传递给可变参数函数：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tnames := []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}  \tline = join(\u0026#34;,\u0026#34;, names...) \tfmt.Println(line) }  func join(del string, values ...string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } 这一次，当我们调用 join 函数时，我们通过附加省略号 (...)来分解 names 切片。\n这样程序就会按照预期运行：\nOutput Sammy,Jessica,Drew,Jamie 要注意，我们仍然可以传递零个、一个或多个参数，以及我们分解的切片。以下是我们迄今为止看到的所有变体的代码：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar line string  \tline = join(\u0026#34;,\u0026#34;, []string{\u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;}...) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;, \u0026#34;Drew\u0026#34;, \u0026#34;Jamie\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;, \u0026#34;Jessica\u0026#34;) \tfmt.Println(line)  \tline = join(\u0026#34;,\u0026#34;, \u0026#34;Sammy\u0026#34;) \tfmt.Println(line)  }  func join(del string, values ...string) string { \tvar line string \tfor i, v := range values { \tline = line + v \tif i != len(values)-1 { \tline = line + del \t} \t} \treturn line } Output Sammy,Jessica,Drew,Jamie Sammy,Jessica,Drew,Jamie Sammy,Jessica Sammy 现在，我们知道了如何将零个、一个或多个参数以及我们分解的切片传递给可变参数函数。\n结论 #  在本教程中，我们了解了可变参数函数如何使您的代码更简洁。虽然您并不总是需要使用它们，但您可能会发现它们很有用：\n 如果你创建了一个临时切片，只是为了传递给函数。 当输入参数的数量未知或调用时会发生变化。 使您的代码更具可读性。  要了解有关创建和调用函数的更多信息，您可以阅读如何在 Go 中定义和调用函数。\n"},{"id":28,"href":"/docs/29-Understanding_defer_in_Go/","title":"29 Understanding Defer in Go","section":"Docs","content":"了解 Go 中的 defer #  简介 #  Go 有许多其他编程语言中常见的控制流关键字，如 if、switch、for 等。有一个关键词在大多数其他编程语言中都没有，那就是 defer ，虽然它不太常见，但你很快就会发现它在你的程序中是多么有用。\ndefer 语句的主要用途之一是清理资源，如打开的文件、网络连接和数据库句柄。当你的程序使用完这些资源后，关闭它们很重要，以避免耗尽程序的限制，并允许其他程序访问这些资源。defer 通过保持关闭文件/资源的调用与打开调用保持一致，使我们的代码更加简洁，不易出错。\n在这篇文章中，我们将学习如何正确使用 defer 语句来清理资源，以及使用 defer 时常犯的几个错误。\n什么是 defer 语句 #  defer 语句将 defer 关键字后面的函数调用添加到一个栈中。当该语句所在的函数返回时，将执行堆栈中所有的函数调用。由于这些调用位于堆栈上，因此将按照后进先出的顺序进行调用。\n让我们看看 defer 是如何工作的，打印出一些文本：\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  defer fmt.Println(\u0026#34;Bye\u0026#34;)  fmt.Println(\u0026#34;Hi\u0026#34;) } 在 main 函数中，我们有两条语句。第一条语句以 defer 关键字开始，后面是 print 语句，打印出 Bye。下一行打印出 Hi。\n如果我们运行该程序，我们将看到以下输出：\nHi Bye 请注意，Hi 被首先打印出来。这是因为以 defer 为前缀的语句直到该函数结束前，都不会被调用。\n让我们再看看这个程序，这次我们将添加一些注释来帮助说明正在发生的事情：\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  // defer statement is executed, and places  // fmt.Println(\u0026#34;Bye\u0026#34;) on a list to be executed prior to the function returning  defer fmt.Println(\u0026#34;Bye\u0026#34;)   // The next line is executed immediately  fmt.Println(\u0026#34;Hi\u0026#34;)   // fmt.Println*(\u0026#34;Bye\u0026#34;) is now invoked, as we are at the end of the function scope } 理解 defer 的关键是，当 defer 语句被执行时，延迟函数的参数被立即评估。当 defer 执行时，它把后面的语句放在一个列表中，在函数返回之前被调用。\n虽然这段代码说明了 defer 的运行顺序，但这并不是编写 Go 程序时的典型使用方式。我们更可能使用 defer 来清理资源，例如文件句柄。接下来让我们看看如何做到这一点。\n使用 defer 来清理资源 #  使用 defer 来清理资源在 Go 中是非常常见的。让我们先看看一个将字符串写入文件的程序，但没有使用 defer 来处理资源清理的问题：\npackage main  import (  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;os\u0026#34; )  func main() {  if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to write file:\u0026#34;, err)  } }  func write(fileName string, text string) error {  file, err := os.Create(fileName)  if err != nil {  return err  }  _, err = io.WriteString(file, text)  if err != nil {  return err  }  file.Close()  return nil } 在这个程序中，有一个叫做 write 的函数，它将首先尝试创建一个文件。如果它有错误，它将返回错误并退出函数。接下来，它试图将字符串 This is a readme file 写到指定文件中。如果它收到一个错误，它将返回错误并退出该函数。然后，该函数将尝试关闭该文件并将资源释放回系统。最后，该函数返回 nil 以表示该函数的执行没有错误。\n虽然这段代码可以工作，但有一个细微的错误。如果对 io.WriteString 的调用失败，该函数将在没有关闭文件并将资源释放回系统的情况下返回。\n我们可以通过添加另一个 file.Close() 语句来解决这个问题，在没有 defer 的语言中，你可能会这样解决：\npackage main  import (  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;os\u0026#34; )  func main() {  if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to write file:\u0026#34;, err)  } }  func write(fileName string, text string) error {  file, err := os.Create(fileName)  if err != nil {  return err  }  _, err = io.WriteString(file, text)  if err != nil {  file.Close()  return err  }  file.Close()  return nil } 现在，即使调用 io.WriteString 失败了，我们仍然会关闭该文件。虽然这是一个相对容易发现和修复的错误，但对于一个更复杂的函数来说，它可能会被遗漏。\n我们可以使用 defer 语句来确保在执行过程中无论采取何种分支，我们都会调用 Close() ，而不是增加对 file.Close() 的第二次调用。\n下面是使用 defer 关键字的版本：\npackage main  import (  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;os\u0026#34; )  func main() {  if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to write file:\u0026#34;, err)  } }  func write(fileName string, text string) error {  file, err := os.Create(fileName)  if err != nil {  return err  }  defer file.Close()  _, err = io.WriteString(file, text)  if err != nil {  return err  }  return nil } 这一次我们添加了这行代码，defer file.Close()。这告诉编译器，它应该在退出函数 write 之前执行 file.Close。\n现在我们已经确保，即使我们在未来添加更多的代码并创建另一个退出该函数的分支，我们也会一直清理并关闭该文件。\n然而，我们通过添加 defer 引入了另一个错误。我们不再检查可能从 Close 方法返回的潜在错误。这是因为当我们使用 defer 时，没有办法将任何返回值传回给我们的函数。\n在 Go 中，在不影响程序行为的情况下多次调用 Close() 被认为是一种安全和公认的做法。如果 Close() 要返回一个错误，它将在第一次被调用时返回。这使得我们可以在函数的成功执行路径中明确地调用它。\n让我们看看我们如何既能 defer 对 Close 的调用，又能在遇到错误时报告错误。\npackage main  import (  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;os\u0026#34; )  func main() {  if err := write(\u0026#34;readme.txt\u0026#34;, \u0026#34;This is a readme file\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to write file:\u0026#34;, err)  } }  func write(fileName string, text string) error {  file, err := os.Create(fileName)  if err != nil {  return err  }  defer file.Close()  _, err = io.WriteString(file, text)  if err != nil {  return err  }   return file.Close() } 这个程序中唯一的变化是最后一行，我们返回 file.Close()。如果对 Close 的调用导致错误，现在将按照预期返回给调用函数。请记住，我们的 defer file.Close() 语句也将在 return 语句之后运行。这意味着 file.Close() 有可能被调用两次。虽然这并不理想，但这是可以接受的做法，因为它不应该对你的程序产生任何副作用。\n然而，如果我们在函数的早期收到一个错误，例如当我们调用 WriteString 时，函数将返回该错误，并且也将尝试调用 file.Close，因为它被推迟了。尽管 file.Close 也可能（而且很可能）返回一个错误，但这不再是我们关心的事情，因为我们收到的错误更有可能告诉我们一开始就出了什么问题。\n到目前为止，我们已经看到我们如何使用一个 defer 来确保我们正确地清理我们的资源。接下来我们将看到如何使用多个 defer 语句来清理多个资源。\n多个 defer 语句 #  在一个函数中拥有多个 defer 语句是很正常的。让我们创建一个只有 defer 语句的程序，看看当我们引入多个 defer 时，会发生什么情况：\npackage main  import \u0026#34;fmt\u0026#34;  func main() {  defer fmt.Println(\u0026#34;one\u0026#34;)  defer fmt.Println(\u0026#34;two\u0026#34;)  defer fmt.Println(\u0026#34;three\u0026#34;) } 如果我们运行该程序，我们将收到以下输出结果：\nthree two one 注意，顺序与我们调用 defer 语句的顺序相反。这是因为每个被调用的延迟语句都是堆叠在前一个语句之上的，然后在函数退出范围时反向调用（后进先出）。\n在一个函数中，你可以根据需要有尽可能多的 defer 调用，但重要的是要记住它们都将以相反的顺序被调用。\n现在我们了解了多个延迟的执行顺序，让我们看看如何使用多个延迟来清理多个资源。我们将创建一个程序，打开一个文件，向其写入内容，然后再次打开，将内容复制到另一个文件。\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;io\u0026#34;  \u0026#34;log\u0026#34;  \u0026#34;os\u0026#34; )  func main() {  if err := write(\u0026#34;sample.txt\u0026#34;, \u0026#34;This file contains some sample text.\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to create file\u0026#34;)  }   if err := fileCopy(\u0026#34;sample.txt\u0026#34;, \u0026#34;sample-copy.txt\u0026#34;); err != nil {  log.Fatal(\u0026#34;failed to copy file: %s\u0026#34;)  } }  func write(fileName string, text string) error {  file, err := os.Create(fileName)  if err != nil {  return err  }  defer file.Close()  _, err = io.WriteString(file, text)  if err != nil {  return err  }   return file.Close() }  func fileCopy(source string, destination string) error {  src, err := os.Open(source)  if err != nil {  return err  }  defer src.Close()   dst, err := os.Create(destination)  if err != nil {  return err  }  defer dst.Close()   n, err := io.Copy(dst, src)  if err != nil {  return err  }  fmt.Printf(\u0026#34;Copied %d bytes from %s to %s\\n\u0026#34;, n, source, destination)   if err := src.Close(); err != nil {  return err  }   return dst.Close() } 我们添加了一个新的函数，叫做 fileCopy。在这个函数中，我们首先打开我们要复制的源文件。我们检查我们是否收到了一个打开文件的错误。如果是的话，我们 return 错误并退出该函数。否则，我们 defer 关闭我们刚刚打开的源文件。\n接下来我们创建目标文件。再次，我们检查我们是否收到了创建文件的错误。如果是的话，我们 return 该错误并退出该函数。否则，我们也 defer 目标文件的 Close()。我们现在有两个 defer 函数，当函数退出其作用域时将被调用。\n现在我们已经打开了两个文件，我们将Copy() 数据从源文件到目标文件。如果成功的话，我们将尝试关闭两个文件。如果我们在试图关闭任何一个文件时收到错误，我们将 return 错误并退出函数作用域。\n注意，我们为每个文件明确地调用 Close()，尽管 defer 也将调用 Close()。这是为了确保如果关闭文件时出现错误，我们会报告这个错误。这也确保了如果因为任何原因函数提前退出，例如我们在两个文件之间复制失败，每个文件仍将尝试从延迟调用中正确关闭。\n总结 #  在这篇文章中，我们了解了 defer 语句，以及如何使用它来确保我们在程序中正确清理系统资源。正确地清理系统资源将使你的程序使用更少的内存，表现更好。要了解更多关于 defer 的使用，请阅读处理恐慌的文章，或者探索我们整个如何在 Go 中编码系列。\n"},{"id":29,"href":"/docs/30_Understanding_init_in_Go/","title":"30 Understanding Init in Go","section":"Docs","content":"了解 Go 中的 init #  简介 #  在 Go 中，预定义的 init() 函数设置了一段代码，在你的包的任何其他部分之前运行。这段代码将在包被导入后立即执行，当你需要你的应用程序在一个特定的状态下初始化时，例如你有一个特定的配置或一组资源，你的应用程序需要用它来启动。它也可以在导入副作用时使用，这是一种通过导入特定包来设置程序状态的技术。这经常被用于 register 一个包和另一个包，以确保程序考虑任务的正确代码。\n尽管 init() 是一个有用的工具，但它有时会使代码难以阅读，因为难以找到的 init() 实例会大大影响代码的运行顺序。正因为如此，对于刚接触 Go 的开发者来说，了解这个函数的方方面面是非常重要的，这样他们在写代码时就能确保以可读的方式使用 init()。\n在本教程中，你将学习 init() 如何用于设置和初始化特定包的变量、一次性计算，以及注册一个包以便与另一个包一起使用。\n先决条件 #  对于本文中的一些例子，你将需要：\n 按照 [如何安装 Go 和设置本地编程环境]（https://www.digitalocean.com/community/tutorial_series/how-to-install-and-set-up-a-local-programming-environment-for-go）设置的 Go 工作空间。本教程将使用以下文件结构：  . ├── bin │ └── src  └── github.com  └── gopherguides 定义 init() #  只要你定义一个 init() 函数，Go 就会在该包的其他东西之前加载并运行它。为了证明这一点，本节将介绍如何定义一个 init() 函数，并展示对包的运行的影响。\n首先，让我们以下面这个没有 init() 函数的代码为例：\npackage main  import \u0026#34;fmt\u0026#34;  var weekday string  func main() { \tfmt.Printf(\u0026#34;Today is %s\u0026#34;, weekday) } 在这个程序中，我们声明了一个全局变量，叫做 weekday。默认情况下，weekday 的值是一个空字符串。\n让我们运行这段代码：\ngo run main.go 因为 weekday 的值是空的，当我们运行程序时，我们将得到以下输出：\nToday is 我们可以通过引入一个 init() 函数，将 weekday 的值初始化为当前日期，来填补这个空白变量。在 main.go 中加入以下高亮行：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;time\u0026#34; )  var weekday string  func init() { \tweekday = time.Now().Weekday().String() }  func main() { \tfmt.Printf(\u0026#34;Today is %s\u0026#34;, weekday) } 在这段代码中，我们导入并使用了 time 包来获取当前的星期（Now().Weekday().String()），然后使用 init() 用这个值来初始化 weekday。 现在当我们运行该程序时，它将打印出当前的工作日：\nToday is Monday 虽然这说明了 init() 是如何工作的，但 init() 更典型的使用情况是在导入软件包时使用它。当你在使用软件包之前需要在软件包中进行特定的设置任务时，这就很有用。为了证明这一点，让我们创建一个程序，该程序需要一个特定的初始化，以便包能够如期工作。\n导入时初始化软件包 #  首先，我们将写一些代码，从切片中选择一个随机的生物并打印出来。然而，我们不会在初始程序中使用 init()。这将更好地展示我们的问题，以及 init() 将如何解决我们的问题。\n在你的 src/github.com/gopherguides/ 目录中，用以下命令创建一个名为 creature 的文件夹。\nmkdir creature 在 creature 文件夹下，创建一个名为 creature.go 的文件：\nnano creature/creature.go 在这个文件中，添加以下内容：\npackage creature  import ( \t\u0026#34;math/rand\u0026#34; )  var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;}  func Random() string { \ti := rand.Intn(len(creatures)) \treturn creatures[i] } 这个文件定义了一个叫做 creatures 的变量，它有一组初始化为数值的海洋生物。它还有一个exported Random 函数，将从 creatures 变量中返回一个随机值。\n保存并退出这个文件。\n接下来，让我们创建一个 cmd 包，我们将用它来编写 main() 函数并调用 creature 包。\n在我们创建 creature 文件夹的同一文件层，用以下命令创建一个 cmd 文件夹：\nmkdir cmd 在 cmd 文件夹中，创建一个名为 main.go 的文件：\nnano cmd/main.go 在文件中添加以下内容：\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/creature\u0026#34; )  func main() { \tfmt.Println(creature.Random()) \tfmt.Println(creature.Random()) \tfmt.Println(creature.Random()) \tfmt.Println(creature.Random()) } 这里我们导入了 creature 包，然后在 main() 函数中，使用 creature.Random() 函数来检索一个随机生物并打印出来四次。\n保存并退出 main.go。\n我们现在已经写好了我们的整个程序。然而，在我们运行这个程序之前，我们还需要创建几个配置文件，以便我们的代码能够正常工作。Go 使用Go Modules来配置导入资源的软件包依赖性。这些模块是放置在你的包目录中的配置文件，告诉编译器从哪里导入包。虽然对模块的学习超出了本文的范围，但我们只需写几行配置就可以让这个例子在本地运行。\n在 cmd 目录下，创建一个名为 go.mod 的文件：\nnano cmd/go.mod 文件打开后，放入以下内容：\nmodule github.com/gopherguides/cmd replace github.com/gopherguides/creature =\u0026gt; ../creature 这个文件的第一行告诉编译器，我们创建的 cmd 包实际上是 github.com/gopherguides/cmd。第二行告诉编译器，github.com/gopherguides/creature可以在磁盘上的 .../creature 目录下找到。 保存并关闭该文件。接下来，在 creature 目录下创建一个 go.mod 文件。\nnano creature/go.mod 在文件中添加以下一行代码：\n module github.com/gopherguides/creature 这告诉编译器，我们创建的 creature 包实际上是 github.com/gopherguides/creature 包。没有这个，cmd 包就不知道从哪里导入这个包。 保存并退出该文件。\n现在你应该有以下的目录结构和文件布局：\n├── cmd │ ├── go.mod │ └── main.go └── creature  ├── go.mod  └── creature.go 现在我们已经完成了所有的配置，我们可以用下面的命令运行 main 程序：\ngo run cmd/main.go 这将输出：\njellyfish squid squid dolphin 当我们运行这个程序时，我们收到了四个数值并打印出来。如果我们多次运行这个程序，我们会注意到，我们总是得到相同的输出，而不是预期的随机结果。这是因为 rand 包创建了伪随机数，对于单一的初始状态会持续产生相同的输出。为了实现更多的随机数，我们可以用 seed 包，或者设置一个不断变化的源，这样每次运行程序时的初始状态都会不同。在 Go 中，通常使用当前时间作为 rand 包的种子。 由于我们想让 creature 包来处理随机功能，所以打开这个文件。\nnano creature/creature.go 在 creature.go 文件中添加以下高亮行：\npackage creature  import ( \t\u0026#34;math/rand\u0026#34; \t\u0026#34;time\u0026#34; )  var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;}  func Random() string { \trand.Seed(time.Now().UnixNano()) \ti := rand.Intn(len(creatures)) \treturn creatures[i] } 在这段代码中，我们导入了 time 包，并使用当前时间作为 Seed() 的种子。保存并退出该文件。 现在，当我们运行该程序时，我们将得到一个随机的结果：\ngo run cmd/main.go jellyfish octopus shark jellyfish 如果你继续反复运行该程序，你将继续得到随机结果。然而，这还不是我们代码的理想实现，因为每次调用 creature.Random() 时，也会通过再次调用 rand.Seed(time.Now().UnixNano() 来重新播种 rand 包。如果内部时钟没有改变，重新播种会增加用相同初始值播种的机会，这将导致随机模式可能的重复，或者会因为让你的程序等待时钟改变而增加 CPU 处理时间。 为了解决这个问题，我们可以使用一个 init() 函数。让我们更新 creature.go 文件：\nnano creature/creature.go 添加以下几行代码：\npackage creature  import ( \t\u0026#34;math/rand\u0026#34; \t\u0026#34;time\u0026#34; )  var creatures = []string{\u0026#34;shark\u0026#34;, \u0026#34;jellyfish\u0026#34;, \u0026#34;squid\u0026#34;, \u0026#34;octopus\u0026#34;, \u0026#34;dolphin\u0026#34;}  func init() { \trand.Seed(time.Now().UnixNano()) }  func Random() string { \ti := rand.Intn(len(creatures)) \treturn creatures[i] } 添加 init() 函数告诉编译器，当 creature 包被导入时，它应该运行一次 init() 函数，为随机数生成提供一个种子。这确保了我们不会超过必须的时间来运行代码。现在，如果我们运行该程序，我们将继续得到随机结果：\ngo run cmd/main.go dolphin squid dolphin octopus 在这一节中，我们已经看到使用 init() 可以确保在使用包之前进行适当的计算或初始化。接下来，我们将看到如何在一个包中使用多个 init() 语句。\n多个 init() 实例 #  与只能声明一次的 main() 函数不同，init() 函数可以在一个包中多次声明。然而，多个 init() 会使我们很难知道哪个函数比其他函数有优先权。在本节中，我们将展示如何保持对多个 init() 语句的控制。\n在大多数情况下，init()函数将按照你遇到它们的顺序执行。让我们以下面的代码为例：\nmain.go\npackage main  import \u0026#34;fmt\u0026#34;  func init() { \tfmt.Println(\u0026#34;First init\u0026#34;) }  func init() { \tfmt.Println(\u0026#34;Second init\u0026#34;) }  func init() { \tfmt.Println(\u0026#34;Third init\u0026#34;) }  func init() { \tfmt.Println(\u0026#34;Fourth init\u0026#34;) }  func main() {} 如果我们用以下命令运行该程序：\ngo run main.go 我们将收到以下输出：\nFirst init Second init Third init Fourth init 注意，每个 init() 都是按照编译器遇到它的顺序来运行的。然而，要确定 init() 函数的调用顺序可能并不总是那么容易。 让我们看看一个更复杂的包结构，其中我们有多个文件，每个文件都有自己的 init() 函数声明。为了说明这一点，我们将创建一个程序，共享一个名为 message 的变量并将其打印出来。\n删除前面的 creature 和 cmd 目录及其内容，用下面的目录和文件结构取代它们：\n├── cmd │ ├── a.go │ ├── b.go │ └── main.go └── message  └── message.go 现在我们来添加每个文件的内容。在 a.go 中，添加以下几行：\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/message\u0026#34; )  func init() { \tfmt.Println(\u0026#34;a -\u0026gt;\u0026#34;, message.Message) } 这个文件包含一个 init() 函数，打印出 message 包中 message.Message 的值。\n接下来，在 b.go 中添加以下内容：\npackage main  import ( \t\u0026#34;fmt\u0026#34;  \t\u0026#34;github.com/gopherguides/message\u0026#34; )  func init() { \tmessage.Message = \u0026#34;Hello\u0026#34; \tfmt.Println(\u0026#34;b -\u0026gt;\u0026#34;, message.Message) } 在 b.go 中，我们有一个 init() 函数，将 message.Message 的值设置为 Hello 并打印出来。\n接下来，创建 main.go，看起来像下面这样：\npackage main  func main() {} 这个文件什么也不做，但为程序的运行提供了一个入口点。\n最后，创建你的 message.go 文件，如下所示：\npackage message  var Message string 我们的 message 包声明了导出的 Message 变量。\n要运行该程序，在 cmd 目录下执行以下命令：\ngo run *.go 因为我们在 cmd 文件夹中有多个 Go 文件组成 main 包，我们需要告诉编译器，cmd 文件夹中所有的 .go 文件都应该被编译。使用 *.go 告诉编译器加载 cmd 文件夹中所有以 .go 结尾的文件。如果我们发出 go run main.go 的命令，程序将无法编译，因为它看不到 a.go 和 b.go 文件中的代码。\n这将得到以下输出：\na -\u0026gt; b -\u0026gt; Hello 根据 Go 语言对包初始化的规范，当一个包中遇到多个文件时，会按字母顺序处理。正因为如此，我们第一次从 a.go 中打印出 message.Message 时，其值是空白的。在运行 b.go 的 init() 函数之前，该值没有被初始化。 如果我们把 a.go 的文件名改为 c.go，我们会得到一个不同的结果：\nb -\u0026gt; Hello a -\u0026gt; Hello 现在编译器先遇到了 b.go，因此，当遇到 c.go 中的 init() 函数时，message.Message 的值已经被初始化为 Hello。\n这种行为可能会在你的代码中产生一个可能的问题。在软件开发中，改变文件名是很常见的，由于 init() 的处理方式，改变文件名可能改变 init() 的处理顺序。这可能会产生改变你的程序输出的不良后果。为了确保可重复的初始化行为，我们鼓励构建系统以词法文件名的顺序向编译器展示属于同一软件包的多个文件。确保所有 init() 函数按顺序加载的一个方法是在一个文件中声明它们。这将防止即使文件名被改变，顺序也不会改变。\n除了确保你的 init() 函数的顺序不发生变化外，你还应该尽量避免使用全局变量来管理包中的状态，即在包中任何地方都可以访问的变量。在前面的程序中， message.Message 变量对整个包都是可用的，并保持着程序的状态。由于这种访问，init() 语句能够改变该变量并破坏你的程序的可预测性。为了避免这种情况，尽量在受控的空间内处理变量，在允许程序工作的同时，尽可能减少访问。\n我们已经看到，你可以在一个包中有多个 init() 声明。然而，这样做可能会产生不想要的效果，使你的程序难以阅读或预测。避免多个 init() 声明或将它们全部放在一个文件中，将确保当文件被移动或名称被改变时，你的程序的行为不会改变。\n接下来，我们将检查 init() 是如何被用来导入产生副作用的。\n使用 init() 的副作用 #  在 Go 中，有时导入一个包并不是为了它的内容，而是为了导入包后产生的副作用。这通常意味着在导入的代码中有一个 init() 语句，在其他代码之前执行，允许开发者操纵他们程序开始的状态。这种技术被称为导入的副作用。\n为副作用而导入的一个常见用例是在你的代码中注册功能，这让包知道你的程序需要使用哪部分代码。例如，在 image 包中，image.Decode 函数在执行前需要知道它要解码的图像格式（jpg，png，gif，等等）。你可以通过首先导入一个有 init() 语句副作用的特定程序来完成这个任务。\n假设你试图在一个.png 文件上使用 image.Decode，代码片段如下：\n. . . func decode(reader io.Reader) image.Rectangle { \tm, _, err := image.Decode(reader) \tif err != nil { \tlog.Fatal(err) \t} \treturn m.Bounds() } . . . 使用这段代码的程序仍然可以编译，但任何时候我们试图对 png 图像进行解码时，都会出现错误。\n为了解决这个问题，我们需要首先为 image.Decode 注册一个图像格式。幸运的是，image/png 包包含以下 init() 语句：\nfunc init() { \timage.RegisterFormat(\u0026#34;png\u0026#34;, pngHeader, Decode, DecodeConfig) } 因此，如果我们将 image/png 导入我们的解码片段，那么 image/png 中的 image.RegisterFormat() 函数将在我们任何代码之前运行：\n. . . import _ \u0026#34;image/png\u0026#34; . . .  func decode(reader io.Reader) image.Rectangle { \tm, _, err := image.Decode(reader) \tif err != nil { \tlog.Fatal(err) \t} \treturn m.Bounds() } 这将设置状态并注册我们需要 image.Decode() 的 png 版本。这个注册将作为导入 image/png 的一个副作用发生。 你可能已经注意到了在image/png之前的空白标识符(_) 。 这是有必要的，因为 Go 不允许你导入那些在整个程序中不使用的包。通过包括空白标识符，导入本身的值被丢弃了，所以只有导入的副作用才会出现。这意味着，即使我们在代码中从未调用 image/png 包，我们仍然可以导入它的副作用。\n当你需要导入一个包的时候，知道它的副作用是很重要的。如果没有适当的注册，你的程序很可能会被编译，但在运行时却不能正常工作。标准库中的包会在其文档中声明需要这种类型的导入。如果你写了一个需要导入副作用的包，你也应该确保你所使用的 init() 语句是有文档的，这样导入你的包的用户就能正确使用它。\n总结 #  在本教程中，我们了解到 init() 函数是在你的包中的其他代码被加载之前加载的，它可以为一个包执行特定的任务，如初始化一个期望的状态。我们还了解到，编译器执行多个 init() 语句的顺序取决于编译器加载源文件的顺序。如果你想了解更多关于 init() 的信息，请查看官方的Golang 文档，或者阅读Go 社区中关于该函数的讨论。\n你可以通过我们的如何在 Go 中定义和调用函数文章阅读更多关于函数的信息，或者探索整个 Go 中如何编程系列。\n"},{"id":30,"href":"/docs/31_Customizing_Go_Binaries_with_Build_Tags/","title":"31 Customizing Go Binaries With Build Tags","section":"Docs","content":"用构建标签定制 Go 二进制文件 #  简介 #  在 Go 中，构建标签 或 构建约束 是添加到一段代码中的标识符，它决定了该文件在 build 过程中何时应被包含在一个包中。这允许你从同一源代码中构建不同版本的 Go 应用程序，并以快速和有组织的方式在它们之间进行切换。许多开发者使用构建标签来改善构建跨平台兼容的应用程序的工作流程，例如需要修改代码以考虑不同操作系统之间的差异的程序。构建标签还可用于集成测试，允许你在集成代码和带有Mock 服务的代码之间快速切换，并用于应用程序内不同级别的功能集。\n让我们以不同的客户功能集的问题为例。在编写一些应用程序时，你可能想控制在二进制文件中包括哪些功能，例如一个提供免费、专业和企业级别的应用程序。当客户在这些应用程序中增加他们的订阅级别时，更多的功能将被解锁并可用。为了解决这个问题，你可以维护独立的项目，并试图通过使用 import 语句来保持它们的同步性。虽然这种方法可行，但随着时间的推移，它将变得乏味和容易出错。另一种方法是使用构建标签。\n在本文中，您将使用 Go 中的构建标签来生成不同的可执行二进制文件，这些文件提供了一个示例应用程序的免费、专业和企业功能集。每一个都有不同的功能集，其中免费版本是默认的。\n先决条件 #  要遵循本文的例子，你将需要：\n 按照 如何安装 Go 和设置本地编程环境设置的 Go 工作区。  构建免费版本 #  让我们从构建应用程序的免费版本开始，因为当运行 go build 而没有任何构建标签时，它将是默认的。稍后，我们将使用构建标签来有选择地将其他部分添加到我们的程序中。\n在 src 目录下，用你的应用程序的名字创建一个文件夹。本教程将使用app：\nmkdir app 移动到这个文件夹中：\ncd app 接下来，在你选择的文本编辑器中建立一个新的文本文件，名为 main.go：\nnano main.go 现在，我们将定义该应用程序的免费版本。在以下内容中加入main.go：\npackage main  import \u0026#34;fmt\u0026#34;  var features = []string{  \u0026#34;Free Feature #1\u0026#34;,  \u0026#34;Free Feature #2\u0026#34;, }  func main() {  for _, f := range features {  fmt.Println(\u0026#34;\u0026gt;\u0026#34;, f)  } } 在这个文件中，我们创建了一个程序，声明了一个名为 features 的切片，它容纳了两个字符串，代表我们免费版本的应用程序的特征。应用程序中的 main() 函数使用一个 for 循环 range 遍历 features 切片，并将所有可用的功能打印到屏幕上。\n保存并退出该文件。现在这个文件已经保存了，在文章的其余部分，我们将不再需要编辑它。相反，我们将使用构建标签来改变我们将从中构建的二进制文件的功能特性。\n构建和运行程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 该程序已经打印出我们的两个免费功能，完成了我们应用程序的免费版本。 到目前为止，你创建了一个具有非常基本功能集的应用程序。接下来，你将建立一种方法，在构建时向应用程序添加更多的功能。\n用 go build 添加专业功能 #  到目前为止，我们避免了对 main.go 的修改，模拟了一个常见的生产环境，在这个环境中，需要在不改变和可能破坏主代码的情况下增加代码。由于我们不能编辑 main.go 文件，我们需要使用另一种机制，使用构建标签将更多的功能注入到 features 切片中。\n让我们创建一个名为 pro.go 的新文件，该文件将使用 init() 函数将更多的特特性追加到 features 切片中：\nnano pro.go 一旦编辑器打开了该文件，添加以下几行：\npackage main  func init() {  features = append(features,  \u0026#34;Pro Feature #1\u0026#34;,  \u0026#34;Pro Feature #2\u0026#34;,  ) } 在这段代码中，我们使用 init() 在我们应用程序的 main() 函数前运行代码，然后使用 append() 将专业功能添加到 features切片中。保存并退出该文件。\n编译并运行应用程序，使用 go build:\ngo build 由于现在我们的当前目录中有两个文件（ pro.go 和 main.go ），go build将从这两个文件创建一个二进制文件。执行这个二进制文件：\n./app 这将为你提供以下功能组合：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 该应用程序现在同时包括专业版和免费版的功能。然而，这并不可取：由于版本之间没有区别，免费版现在包括了本应只有专业版才有的功能。为了解决这个问题，你可以加入更多的代码来管理应用程序的不同层级，或者你可以使用构建标签来告诉 Go 工具链哪些.go文件需要构建，哪些需要忽略。让我们在下一步中添加构建标签。\n添加构建标签 #  你现在可以使用构建标签来区分你的应用程序的专业版本和免费版本。\n让我们先来看看构建标签是什么样子的：\n// +build tag_name 将这行代码作为软件包的第一行，并将 tag_name 替换为你的构建标签的名称，你将把这个软件包标记为可以选择性地包含在最终二进制文件中的代码。让我们来看看这个操作，在 pro.go 文件中添加一个构建标签，告诉 go build 命令忽略它，除非指定标签。在你的文本编辑器中打开该文件：\nnano pro.go 然后添加以下突出显示的一行：\n// +build pro  package main  func init() {  features = append(features,  \u0026#34;Pro Feature #1\u0026#34;,  \u0026#34;Pro Feature #2\u0026#34;,  ) } 在 pro.go 文件的顶部，我们添加了 // +build pro，后面是一个空白的换行。这个尾部的换行是必须的，否则 Go 会将其解释为一个注释。构建标签的声明也必须在 .go 文件的最顶端。任何东西，甚至是评论，都不能在构建标签之上。 +build 声明告诉 go build 命令，这不是一个注释，而是一个构建标签。第二部分是 pro 标签。通过在 pro.go 文件的顶部添加这个标签，go build 命令现在将只包括有 pro 标签的 pro.go 文件。\n编译并再次运行应用程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 由于 pro.go 文件需要有 pro 标签，所以该文件被忽略，应用程序在没有标签的情况下进行编译。 当运行 go build 命令时，我们可以使用 -tags 标志，通过添加标签本身作为参数，有条件地将代码纳入编译后的源代码中。让我们对 pro 标签这样做：\ngo build -tags pro 这将输出以下内容：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 现在，我们只有在使用 pro 构建标签构建应用程序时才能获得额外的功能。 如果只有两个版本，这很好，但当你加入更多标签时，事情就变得复杂了。为了在下一步添加我们应用程序的企业版，我们将使用多个构建标签，用布尔逻辑连接起来。\n构建标签布尔逻辑 #  当一个 Go 包中有多个构建标签时，这些标签会使用布尔逻辑相互作用。为了证明这一点，我们将同时使用 pro 标签和 enterprise 标签来添加我们应用程序的企业级。\n为了建立一个企业级二进制文件，我们将需要包括默认功能、专业级功能和一套新的企业级功能。首先，打开一个编辑器并创建一个新文件，enterprise.go，它将添加新的企业级功能：\nnano enterprise.go enterprise.go 的内容将看起来与 pro.go几乎相同，但将包含新的功能。在该文件中添加以下几行：\npackage main  func init() {  features = append(features,  \u0026#34;Enterprise Feature #1\u0026#34;,  \u0026#34;Enterprise Feature #2\u0026#34;,  ) } 保存并退出该文件。\n目前 enterprise.go 文件没有任何构建标签，正如你在添加 pro.go 时了解到的，这意味着这些功能将在执行 go build 时被添加到免费版本中。对于 pro.go，你在文件的顶部添加了 // +build pro 和一个换行符，以告诉 go build 只有在使用 tags pro 时才应包含它。在这种情况下，你只需要一个构建标记就能达到目的。然而，当添加新的企业版功能时，你首先必须同时拥有专业版功能。\n让我们先在 enterprise.go 中添加对 pro 构建标签的支持。用你的文本编辑器打开该文件：\nnano enterprise.go 接下来，在 package main 声明前添加构建标签，并确保在构建标签后包含一个换行符：\n// +build pro  package main  func init() {  features = append(features,  \u0026#34;Enterprise Feature #1\u0026#34;,  \u0026#34;Enterprise Feature #2\u0026#34;,  ) } 保存并退出该文件。 编译并运行没有任何标签的应用程序：\ngo build ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 企业版的功能在免费版中不再显示。现在让我们添加 pro 构建标签，再次构建并运行该应用程序：\ngo build -tags pro ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 这仍然不完全是我们需要的。现在，当我们试图构建专业版时，企业版的功能出现了。为了解决这个问题，我们需要使用另一个构建标签。但与 pro 标签不同的是，我们现在需要确保 pro 和 enterprise 功能都是可用的。 Go 构建系统通过允许在构建标签系统中使用一些基本的布尔逻辑来说明这种情况。\n让我们再次打开 enterprise.go:\nnano enterprise.go 在pro标签的同一行添加另一个构建标签，enterprise:\n// +build pro enterprise  package main  func init() {  features = append(features,  \u0026#34;Enterprise Feature #1\u0026#34;,  \u0026#34;Enterprise Feature #2\u0026#34;,  ) } 保存并关闭该文件。 现在让我们用新的 enterprise 构建标签来编译和运行该应用程序。\ngo build -tags enterprise ./app 这将得到以下信息：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 现在我们已经失去了专业功能。这是因为当我们在 .go 文件中的同一行放置多个构建标签时，go build 会将它们解释为使用 OR 逻辑。 加上 // +build pro enterprise一行，如果存在 pro 构建标签或 enterprise 构建标签，enterprise.go 文件将被构建。 我们需要正确设置构建标签，要求两个同时，并使用 AND 逻辑来代替。 如果我们不把这两个标签放在同一行，而是把它们放在不同的行上，那么 go build 将使用 AND 逻辑来解释这些标签。\n再次打开 enterprise.go，让我们把构建标签分成多行。\n// +build pro // +build enterprise  package main  func init() {  features = append(features,  \u0026#34;Enterprise Feature #1\u0026#34;,  \u0026#34;Enterprise Feature #2\u0026#34;,  ) } 现在用新的 enterprise 构建标签编译和运行应用程序：\ngo build -tags enterprise ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 仍然没有达到目的。因为 AND 语句需要两个元素都被认为是 true，我们需要同时使用 pro 和 enterprise 构建标签。 让我们再试一次：\ngo build -tags \u0026#34;enterprise pro\u0026#34; ./app 你将收到以下输出：\n\u0026gt; Free Feature #1 \u0026gt; Free Feature #2 \u0026gt; Enterprise Feature #1 \u0026gt; Enterprise Feature #2 \u0026gt; Pro Feature #1 \u0026gt; Pro Feature #2 现在，我们的应用程序可以从同一个源树中以多种方式构建，并相应地解锁应用程序的功能。 在这个例子中，我们使用了一个新的 // +build 标签来表示 AND 逻辑，但也有其他方法可以用构建标签表示布尔逻辑。下表是构建标签的其他语法格式的一些例子，以及它们的布尔等价物：\n   构建标签语法 构建标签示例 布尔声明     空格分隔的元素 // +build pro enterprise pro OR enterprise   逗号分隔的元素 // +build pro,enterprise pro AND enterprise   感叹号元素 // +build !pro NOT pro    总结 #  在本教程中，你使用构建标签来控制你的哪些代码被编译到二进制中。首先，你声明了构建标签并使用它们与 go build，然后你用布尔逻辑组合了多个标签。然后，你建立了一个程序，代表了免费版、专业版和企业版的不同功能集，显示了构建标签对项目的强大控制能力。\n如果你想了解更多关于构建标签的信息，请看一下 Golang 的相关文档，或者继续探索我们的如何在 Go 中编码系列。\n"},{"id":31,"href":"/docs/32_Understanding_Pointers_in_Go/","title":"32 Understanding Pointers in Go","section":"Docs","content":"了解 Go 中的指针 #  简介 #  当你用 Go 编写软件时，你会编写函数和方法。你将数据作为 参数 传递给这些函数。有时，函数会需要一个数据的本地拷贝，你希望原始数据保持不变。例如，如果你是一家银行，你有一个函数可以根据用户选择的储蓄计划来显示他们的余额变化，你不想在客户选择计划之前改变他们的实际余额，而只想用它来做计算。这被称为 按值传递，因为你是在向函数发送变量的值，而不是变量本身。\n其他时候，你可能希望函数能够改变原始变量中的数据。例如，当银行客户向其账户存款时，你希望存款函数能够访问实际的余额，而不是一个副本。在这种情况下，你不需要向函数发送实际数据， 而只需要告诉函数数据在内存中的位置。一个叫做 指针 的数据类型持有数据的内存地址，但不是数据本身。内存地址告诉函数在哪里可以找到数据，而不是数据的值。你可以把指针传给函数而不是实际的数据，然后函数就可以在原地改变原始变量的值。这被称为 通过引用传递，因为变量的值并没有传递给函数，而是传递了它指向的位置。\n在这篇文章中，你将创建并使用指针来分享对一个变量的内存空间的访问。\n定义和使用指针 #  当你使用一个指向变量的指针时，有几个不同的语法元素你需要了解。第一个是与号（\u0026amp;）的使用。如果你在一个变量名称前面加一个与号，你就说明你想获得 地址，或者说是该变量的一个指针。第二个语法元素是使用星号（*）或 引用 操作符。当你声明一个指针变量时，你在变量名后面加上指针指向的变量类型，前面加一个*，像这样：\nvar myPointer *int32 = \u0026amp;someint 这将创建 myPointer 作为一个指向 int32 变量的指针，并以 someint 的地址初始化该指针。指针实际上并不包含一个 int32，而只是一个地址。\n让我们来看看一个指向 string 的指针。下面的代码既声明了一个字符串的值，又声明了一个指向字符串的指针：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar creature string = \u0026#34;shark\u0026#34; \tvar pointer *string = \u0026amp;creature  \tfmt.Println(\u0026#34;creature =\u0026#34;, creature) \tfmt.Println(\u0026#34;pointer =\u0026#34;, pointer) } 用以下命令运行该程序：\ngo run main.go 当你运行程序时，它将打印出变量的值，以及该变量的存储地址（指针地址）。内存地址是一个十六进制的数字，并不是为了让人看懂。在实践中，你可能永远不会输出内存地址来查看它。我们给你看是为了说明问题。因为每个程序运行时都是在自己的内存空间中创建的，所以每次运行时指针的值都会不同，也会与下面显示的输出不同：\ncreature = shark pointer = 0xc0000721e0 我们定义的第一个变量名为 creature，并将其设置为一个 string，其值为 shark 。然后我们创建了另一个名为 pointer 的变量。这一次，我们将 pointer 变量的值设置为 creature 变量的地址。我们通过使用与号（\u0026amp;）符号将一个值的地址存储在一个变量中。这意味着 pointer 变量存储的是 creature 变量的 地址 ，而不是实际值。 这就是为什么当我们打印出 pointer 的值时，我们收到的值是 0xc0000721e0 ，这是 creature 变量目前在计算机内存中的地址。\n如果你想打印出 pointer 变量所指向的变量的值，你需要 解引用 该变量。下面的代码使用 * 操作符来解除对 pointer 变量的引用并检索其值。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar creature string = \u0026#34;shark\u0026#34; \tvar pointer *string = \u0026amp;creature  \tfmt.Println(\u0026#34;creature =\u0026#34;, creature) \tfmt.Println(\u0026#34;pointer =\u0026#34;, pointer)  \tfmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) } 如果你运行这段代码，你会看到以下输出：\ncreature = shark pointer = 0xc000010200 *pointer = shark 我们添加的最后一行现在解除了对 pointer 变量的引用，并打印出了存储在该地址的值。 如果你想修改存储在 pointer 变量位置的值，你也可以使用解除引用操作：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar creature string = \u0026#34;shark\u0026#34; \tvar pointer *string = \u0026amp;creature  \tfmt.Println(\u0026#34;creature =\u0026#34;, creature) \tfmt.Println(\u0026#34;pointer =\u0026#34;, pointer)  \tfmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer)  \t*pointer = \u0026#34;jellyfish\u0026#34; \tfmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer) } 运行这段代码可以看到输出：\ncreature = shark pointer = 0xc000094040 *pointer = shark *pointer = jellyfish 我们通过在变量名称前使用星号（*）来设置 pointer 变量所指的值，然后提供一个 jellyfish 的新值。正如你所看到的，当我们打印解引用的值时，它现在被设置为 jellyfish 。 你可能没有意识到，但实际上我们也改变了 creature 变量的值。这是因为 pointer 变量实际上是指向 creature 变量的地址。这意味着如果我们改变了 pointer 变量所指向的值，同时我们也会改变 creature 变量的值。\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tvar creature string = \u0026#34;shark\u0026#34; \tvar pointer *string = \u0026amp;creature  \tfmt.Println(\u0026#34;creature =\u0026#34;, creature) \tfmt.Println(\u0026#34;pointer =\u0026#34;, pointer)  \tfmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer)  \t*pointer = \u0026#34;jellyfish\u0026#34; \tfmt.Println(\u0026#34;*pointer =\u0026#34;, *pointer)  \tfmt.Println(\u0026#34;creature =\u0026#34;, creature) } 输出看起来像这样：\ncreature = shark pointer = 0xc000010200 *pointer = shark *pointer = jellyfish creature = jellyfish 虽然这段代码说明了指针的工作原理，但这并不是你在 Go 中使用指针的典型方式。更常见的是在定义函数参数和返回值时使用它们，或者在定义自定义类型的方法时使用它们。让我们看看如何在函数中使用指针来共享对一个变量的访问。 同样，请记住，我们正在打印 pointer 的值，是为了说明它是一个指针。在实践中，你不会使用指针的值，除了引用底层的值来检索或更新该值之外。\n函数指针接收器 #  当你写一个函数时，你可以定义参数，以 值 或 引用 的方式传递。通过 值 传递意味着该值的副本被发送到函数中，并且在该函数中对该参数的任何改变 只 在该函数中影响该变量，而不是从哪里传递。然而，如果你通过 引用 传递，意味着你传递了一个指向该参数的指针，你可以在函数中改变该值，也可以改变传递进来的原始变量的值。你可以在我们的如何在 Go 中定义和调用函数中阅读更多关于如何定义函数的信息。\n什么时候传递一个指针，什么时候发送一个值，都取决于你是否希望这个值发生变化。如果你不希望数值改变，就把它作为一个值来发送。如果你希望你传递给你的变量的函数能够改变它，那么你就把它作为一个指针传递。\n为了看到区别，让我们先看看一个通过 值 传递参数的函数：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func main() { \tvar creature Creature = Creature{Species: \u0026#34;shark\u0026#34;}  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tchangeCreature(creature) \tfmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) }  func changeCreature(creature Creature) { \tcreature.Species = \u0026#34;jellyfish\u0026#34; \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 输出看起来像这样：\n1) {Species:shark} 2) {Species:jellyfish} 3) {Species:shark} 首先我们创建了一个名为 Creature 的自定义类型。它有一个名为 Species 的字段，它是一个字符串。在 main 函数中，我们创建了一个名为Creature 的新类型实例，并将Species 字段设置为shark 。然后我们打印出变量，以显示存储在 creature 变量中的当前值。 接下来，我们调用 changeCreature，并传入 creature 变量的副本。\nchangeCreature 被定义为接受一个名为 creature 的参数，并且它是我们之前定义的 Creature 类型的函数。然后我们将Species 字段的值改为 jellyfish 并打印出来。注意在 changeCreature 函数中，Species 的值现在是 jellyfish，并且打印出 2) {Species:jellyfish}。这是因为我们被允许在我们的函数范围内改变这个值。\n然而，当 main 函数的最后一行打印出 creature 的值时，Species 的值仍然是 shark 。值没有变化的原因是我们通过 值 传递变量。这意味着在内存中创建了一个值的副本，并传递给 changeCreature 函数。这允许我们有一个函数，可以根据需要对传入的任何参数进行修改，但不会影响函数之外的任何变量。\n接下来，让我们改变 changeCreature 函数，使其通过 引用 接受一个参数。我们可以通过使用星号（*）操作符将类型从 Creature 改为指针来做到这一点。我们现在传递的不是一个 Creature，而是一个指向 Creature 的指针，或者是一个 *Creature。在前面的例子中，creature 是一个 struct，它的 Species 值为 shark。*creature 是一个指针，不是一个结构体，所以它的值是一个内存位置，这就是我们传递给 changeCreature() 真正的东西。\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func main() { \tvar creature Creature = Creature{Species: \u0026#34;shark\u0026#34;}  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tchangeCreature(\u0026amp;creature) \tfmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) }  func changeCreature(creature *Creature) { \tcreature.Species = \u0026#34;jellyfish\u0026#34; \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 运行这段代码可以看到以下输出：\n1) {Species:shark} 2) \u0026amp;{Species:jellyfish} 3) {Species:jellyfish} 注意，现在当我们在 changeCreature 函数中把 Species 的值改为 jellyfish 时，它也改变了 main 函数中定义的原始值。这是因为我们通过 引用 传递了 creature 变量，它允许访问内存里的原始值并可以根据需要改变它。 因此，如果你想让一个函数能够改变一个值，你需要通过引用来传递它。要通过引用传递，你就需要传递变量的指针，而不是变量本身。\n然而，有时你可能没有为一个指针定义一个实际的值。在这些情况下，有可能在程序中出现恐慌。让我们来看看这种情况是如何发生的，以及如何对这种潜在的问题进行规划。\n空指针 #  Go 中的所有变量都有一个零值。即使对指针来说也是如此。如果你声明了一个类型的指针，但是没有赋值，那么零值将是 nil。nil 是一种表示变量 \u0026ldquo;没有被初始化\u0026rdquo; 的方式。\n在下面的程序中，我们定义了一个指向 Creature 类型的指针，但是我们从来没有实例化过 Creature 的实际实例，也没有将它的地址分配给 creature 指针变量。该值将是 nil，因此我们不能引用任何定义在 Creature 类型上的字段或方法：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func main() { \tvar creature *Creature  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tchangeCreature(creature) \tfmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) }  func changeCreature(creature *Creature) { \tcreature.Species = \u0026#34;jellyfish\u0026#34; \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 输出看起来像这样：\n1) \u0026lt;nil\u0026gt; panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x8 pc=0x109ac86]  goroutine 1 [running]: main.changeCreature(0x0)  /Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:18 +0x26 \tmain.main() \t/Users/corylanou/projects/learn/src/github.com/gopherguides/learn/_training/digital-ocean/pointers/src/nil.go:13 +0x98 \texit status 2 当我们运行程序时，它打印出了 creature 变量的值，该值是 \u0026lt;nil\u0026gt;。然后我们调用 changeCreature 函数，当该函数试图设置 Species 字段的值时，它 panics(恐慌) 了。这是因为实际上没有创建 creature 变量的实例。正因为如此，程序没有地方可以实际存储这个值，所以程序就恐慌了。 在 Go 中很常见的是，如果你以指针的形式接收一个参数，在对它进行任何操作之前，你要检查它是否为 nil，以防止程序恐慌。\n这是检查 nil 的一种常见方法：\nif someVariable == nil { \t// print an error or return from the method or fuction } 实际上，你想确保你没有一个 nil 指针被传入你的函数或方法。如果有的话，你可能只想返回，或者返回一个错误，以表明一个无效的参数被传递到函数或方法中。下面的代码演示了对 nil 的检查：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func main() { \tvar creature *Creature  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tchangeCreature(creature) \tfmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) }  func changeCreature(creature *Creature) { \tif creature == nil { \tfmt.Println(\u0026#34;creature is nil\u0026#34;) \treturn \t}  \tcreature.Species = \u0026#34;jellyfish\u0026#34; \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 我们在 changeCreature 中添加了一个检查，看 creature 参数的值是否为 nil。如果是，我们打印出 \u0026ldquo;creature is nil\u0026rdquo;，并返回函数。否则，我们继续并改变 Species 字段的值。如果我们运行该程序，我们现在将得到以下输出：\n1) \u0026lt;nil\u0026gt; creature is nil 3) \u0026lt;nil\u0026gt; 请注意，虽然我们仍然为 creature 变量设置了 nil 值，但我们不再恐慌，因为我们正在检查这种情况。 最后，如果我们创建一个 Creature 类型的实例，并将其赋值给 creature 变量，程序现在将按照预期改变值：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func main() { \tvar creature *Creature \tcreature = \u0026amp;Creature{Species: \u0026#34;shark\u0026#34;}  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tchangeCreature(creature) \tfmt.Printf(\u0026#34;3) %+v\\n\u0026#34;, creature) }  func changeCreature(creature *Creature) { \tif creature == nil { \tfmt.Println(\u0026#34;creature is nil\u0026#34;) \treturn \t}  \tcreature.Species = \u0026#34;jellyfish\u0026#34; \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 现在我们有了一个 Creature 类型的实例，程序将运行，我们将得到以下预期输出：\n1) \u0026amp;{Species:shark} 2) \u0026amp;{Species:jellyfish} 3) \u0026amp;{Species:jellyfish} 当你在使用指针时，程序有可能会出现恐慌。为了避免恐慌，你应该在试图访问任何字段或定义在其上的方法之前，检查一个指针值是否为 nil。 接下来，让我们看看使用指针和值是如何影响在一个类型上定义方法的。\n方法指针接收器 #  Go 中的 接收器 是指在方法声明中定义的参数。看一下下面的代码：\ntype Creature struct { \tSpecies string }  func (c Creature) String() string { \treturn c.Species } 这个方法的接收器是 c Creature。它说明 c 的实例属于 Creature 类型，你将通过该实例变量引用该类型。\n方法跟函数一样，也是根据你送入的参数是指针还是值而有不同的行为。最大的区别是，如果你用一个值接收器定义一个方法，你就不能对该方法所定义的那个类型的实例进行修改。\n有的时候，你希望你的方法能够更新你所使用的变量的实例。为了实现这一点，你会想让接收器成为一个指针。\n让我们给我们的 Creature 类型添加一个 Reset 方法，将 Species字段设置为一个空字符串：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func (c Creature) Reset() { \tc.Species = \u0026#34;\u0026#34; }  func main() { \tvar creature Creature = Creature{Species: \u0026#34;shark\u0026#34;}  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tcreature.Reset() \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 如果我们运行该程序，我们将得到以下输出：\n1) {Species:shark} 2) {Species:shark} 注意到即使在 Reset 方法中我们将 Species 的值设置为空字符串，当我们在 main 函数中打印出 creature 变量的值时，该值仍然被设置为 shark 。这是因为我们定义的 Reset 方法有一个 值 接收器。这意味着该方法只能访问 creature 变量的 副本。 如果我们想在方法中修改 creature 变量的实例，我们需要将它们定义为有一个 指针 接收器：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tSpecies string }  func (c *Creature) Reset() { \tc.Species = \u0026#34;\u0026#34; }  func main() { \tvar creature Creature = Creature{Species: \u0026#34;shark\u0026#34;}  \tfmt.Printf(\u0026#34;1) %+v\\n\u0026#34;, creature) \tcreature.Reset() \tfmt.Printf(\u0026#34;2) %+v\\n\u0026#34;, creature) } 注意，我们现在在定义 Reset 方法时，在 Creature 类型前面添加了一个星号（*）。这意味着传递给 Reset 方法的 Creature 实例现在是一个指针，因此当我们进行修改时，将影响到该变量的原始实例。\n1) {Species:shark} 2) {Species:} 现在 Reset 方法已经改变了 Species 字段的值。\n总结 #  将一个函数或方法定义为通过 值 或通过 引用，将影响你的程序的哪些部分能够对其他部分进行修改。控制该变量何时能被改变，将使你能写出更健壮和可预测的软件。现在你已经了解了指针，你也可以看到它们是如何在接口中使用的。\n"},{"id":32,"href":"/docs/33_Defining_Structs_in_Go/","title":"33 Defining Structs in Go","section":"Docs","content":"在 Go 中定义结构体 #  简介 #  围绕具体的细节建立抽象，是编程语言能给开发者的最大工具。结构体使我们可以谈论 Address 而不是通过描述 Street, City, 或 PostalCode 字符串来进行推断。它们作为文档的一个自然纽带，致力于告诉未来的开发者（包括我们自己）哪些数据对我们的 Go 程序是重要的，以及未来的代码应该如何正确使用这些数据。结构体可以用几种不同的方式来定义和使用。在本教程中，我们将会逐一看下这些技术。\n定义结构体 #  结构体的工作方式类似于你可能正在使用的纸质表格，例如用来报税的表单。纸质表格可能有文本信息的字段，比如你的名字和姓氏。除了文本字段外，表单可能还有复选框来表示布尔值，如“已婚”或“单身”，或表示出生日期的日期字段。同样，结构体将不同数据收集在一起，并通过不同的字段名组织它们。当你用一个新的结构体初始化一个变量时，就好像你影印了一张表格并准备填写。\n要创建一个新的结构体，你必须首先给 Go 定义一个蓝图来描述结构体所包含的字段。这个结构定义通常以关键字 type 开始，紧跟着结构体的名称。随后，使用 struct 关键字，后面跟着一对大括号 {}，在这里声明结构体将包含的字段。一旦你定义了结构体，就可以声明使用该结构体定义的变量。本例定义了一个结构并使用它。\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string }  func main() { \tc := Creature{ \tName: \u0026#34;Sammy the Shark\u0026#34;, \t} \tfmt.Println(c.Name) } 当你运行这段代码时，会看到这样的输出：\noutput Sammy the Shark 在这个例子中，我们首先定义了一个 Creature 结构体，包含一个字符串类型的 Name 字段。在 main 方法中，我们通过在 Creature 类型名称后添加一对大括号来创建一个 Creature 实例，然后为该实例的字段设定值。c 实例的 Name 字段将被设置为 “Sammy the Shark”。在 fmt.Println 方法的调用中，我们通过在实例变量后加点号与我们想访问的字段名来检索实例的字段值。例如，c.Name 在本例中返回 Name 字段值。\n当你声明一个新的结构体实例时，通常会列举字段名和它们的值，就像上一个例子。此外，如果每个字段的值都会在结构的实例化过程中提供，也可以省略字段名，如本例。\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string \tType string }  func main() { \tc := Creature{\u0026#34;Sammy\u0026#34;, \u0026#34;Shark\u0026#34;} \tfmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) } 输出结果与上一个例子相同：\noutput Sammy the Shark 我们为 Creature 增加了一个额外的字段，用字符串类型来追踪生物 Type 。当在 main 方法中实例化 Creature 时，我们选择使用较短的实例化方式，即按顺序为每个字段提供值，并省略其字段名。在 Creature{\u0026quot;Sammy\u0026quot;, \u0026quot;Shark\u0026quot;} 的声明中，因为 Name 在类型声明中首先出现，然后为Type，所以Name 字段取值为 Sammy，Type 字段取值为 Shark。\n这种较短的声明方式有一些缺点，导致 Go 社区在大多数情况下都倾向于采用较长的方式。使用简短声明时，你必须为结构体中的每个字段提供值，而不能省略你并不关心的字段。这很快就会导致包含很多字段的结构体短声明变得混乱。出于这个原因，简短声明通常用于字段少的结构体。\n到目前为止，例子中的字段名都是以大写字母开头。这并不仅是风格上的偏好，而是在字段名中使用大写或小写字母会影响到你的字段名是否能被其他包中运行的代码所访问。\n结构体字段导出 #  结构体的字段遵循与 Go 编程语言中其他标识符相同的导出规则。如果字段名以大写字母开头，则该字段可被定义该结构体的包之外的代码读写。如果字段以小写字母开头，则只有该结构体包内的代码才可以读写该字段。这个例子定义了可导出和不可导出的字段：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string \tType string  \tpassword string }  func main() { \tc := Creature{ \tName: \u0026#34;Sammy\u0026#34;, \tType: \u0026#34;Shark\u0026#34;,  \tpassword: \u0026#34;secret\u0026#34;, \t} \tfmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) \tfmt.Println(\u0026#34;Password is\u0026#34;, c.password) } 这将输出：\noutput Sammy the Shark Password is secret 我们在之前的例子中添加了一个额外的字段，secret。secret 是一个未导出的字符串类型字段，这意味着任何试图实例化 Creature 的其他包将无法访问或设置其 secret 字段。在同一个包内，我们能够访问这些字段，正如本例所做的那样。由于 main 方法也在 main 包中，它能够引用 c.password 并检索所存储的值。在结构中拥有未导出的字段是很常见的，对它们的访问由导出的方法来进行配置。\n内联结构体 #  除了定义一个新的类型来表示一个结构体外，你还可以定义一个内联结构。在为结构类型想一个新的名称会造成浪费的情况下，这些即时创建的结构定义(不需要命名的 struct)会非常有用。例如，测试经常使用一个结构体来定义构成一个特定测试案例的所有参数。当该结构只会在一个地方使用时，想出 CreatureNamePrintingTestCase 这样的新名字会很麻烦。\n内联结构定义出现在变量赋值的右侧。你必须立即使用一对额外的大括号进行实例化并为定义的每个字段赋值。下面的例子显示了一个内联结构定义：\npackage main  import \u0026#34;fmt\u0026#34;  func main() { \tc := struct { \tName string \tType string \t}{ \tName: \u0026#34;Sammy\u0026#34;, \tType: \u0026#34;Shark\u0026#34;, \t} \tfmt.Println(c.Name, \u0026#34;the\u0026#34;, c.Type) } 这个例子的输出结果将是：\noutput Sammy the Shark 本例没有使用 type 关键字定义一个新的类型来描述我们的结构体，而是通过将 struct 定义放在短赋值运算符 := 之后定义一个内联结构。我们像之前的例子一样定义了结构体的字段，但是必须立即提供一对大括号和每个字段将赋的值。现在我们可以和以前完全一样使用这个结构体，用点符号来访问字段名。内联结构最常用于测试过程中声明，因为经常会需要用到一次性结构体来定义包含特定测试案例的数据和预期测试结果。\n总结 #  结构体是开发者为组织信息而定义的各种各样的数据的集合。大多数程序都要处理大量的数据，如果没有结构体，就很难记住哪些 string 或 int 变量相关，哪些无关。下一次，当你发现自己在组织一些变量时，问问自己，也许这些变量用 struct 来分组会更好。这些变量可能一直都在描述更高层级的概念。\n"},{"id":33,"href":"/docs/34_Defining_Methods_in_Go/","title":"34 Defining Methods in Go","section":"Docs","content":"在 Go 中定义方法 #  简介 #  函数允许你将逻辑组织成可重复的程序，每次运行时可以使用不同的参数。在定义函数的过程中，你常常会发现，可能会有多个函数每次对同一块数据进行操作。Go 可以识别这种模式，并允许您定义特殊的函数，称为方法，其目的是对某些特定类型（称为接收器）的实例进行操作。将方法添加到类型中，不仅可以传达数据是什么，还可以传达如何使用这些数据。\n定义一个方法 #  定义一个方法的语法与定义一个函数的语法很相似。唯一的区别是在 func 关键字后面增加了一个额外的参数，用于指定方法的接收器。接收器是你希望定义的方法的类型声明。下面的例子为一个结构体类型定义了一个方法。\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string \tGreeting string }  func (c Creature) Greet() { \tfmt.Printf(\u0026#34;%s says %s\u0026#34;, c.Name, c.Greeting) }  func main() { \tsammy := Creature{ \tName: \u0026#34;Sammy\u0026#34;, \tGreeting: \u0026#34;Hello!\u0026#34;, \t} \tCreature.Greet(sammy) } 如果你运行这段代码，输出将是：\nOutput Sammy says Hello! 我们创建了一个名为 Creature 的结构，包含字符串类型的 Name 和 Greeting 字段。这个 Creature 结构体有一个定义的方法，即 Greet。在接收器声明中，我们将 Creature 的实例分配给变量 c，以便我们在 fmt.Printf 中打印问候信息时可以引用 Creature 字段。\n在其他编程语言中，方法调用的接收器通常用一个关键字来表示（例如：this 或 self）。Go 认为接收器和其他变量一样，是一个变量，所以你可以自由地命名。社区对这个参数的首选风格是接收器类型小写版本的第一个字符。在这个例子中，我们使用了 c，因为接收器的类型是 Creature。\n在 main 方法中，我们创建了一个 Creature 实例，并为其 Name 和 Greeting 字段进行赋值。我们在这里调用了 Greet 方法，用 . 连接类型名和方法名，并提供 Creature 实例作为第一个参数。\nGo 提供了另一种更简洁的方式来调用结构体实例的方法，如本例所示：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string \tGreeting string }  func (c Creature) Greet() { \tfmt.Printf(\u0026#34;%s says %s\u0026#34;, c.Name, c.Greeting) }  func main() { \tsammy := Creature{ \tName: \u0026#34;Sammy\u0026#34;, \tGreeting: \u0026#34;Hello!\u0026#34;, \t} \tsammy.Greet() } 如果你运行这个，输出将与前面的例子相同：\nOutput Sammy says Hello! 这个例子与前一个例子相同，但这次我们使用点号来调用 Greet 方法，使用存储在 sammy 变量中的 Creature 作为接收器，这是对第一个例子中的方法调用的简化。标准库和 Go 社区更喜欢这种风格，以至于你很少看到前面所示的方法调用风格。\n下一个例子展示了使用点号比较普遍的一个原因：\npackage main  import \u0026#34;fmt\u0026#34;  type Creature struct { \tName string \tGreeting string }  func (c Creature) Greet() Creature { \tfmt.Printf(\u0026#34;%s says %s!\\n\u0026#34;, c.Name, c.Greeting) \treturn c }  func (c Creature) SayGoodbye(name string) { \tfmt.Println(\u0026#34;Farewell\u0026#34;, name, \u0026#34;!\u0026#34;) }  func main() { \tsammy := Creature{ \tName: \u0026#34;Sammy\u0026#34;, \tGreeting: \u0026#34;Hello!\u0026#34;, \t} \tsammy.Greet().SayGoodbye(\u0026#34;gophers\u0026#34;)  \tCreature.SayGoodbye(Creature.Greet(sammy), \u0026#34;gophers\u0026#34;) } 如果你运行这段代码，输出看起来像这样：\nOutput Sammy says Hello!! Farewell gophers ! Sammy says Hello!! Farewell gophers ! 我们修改了前面的例子，引入了另一个名为 SayGoodbye 的方法，并将 Greet 改为返回一个 Creature，这样我们就可以对该实例调用更多的方法。在 main 方法中，我们首先使用点号调用 sammy 变量上的 Greet 和 SayGoodbye 方法，然后使用函数式调用方式。\n两种风格输出的结果相同，但使用点号的例子更易读。点号调用链路还会告诉我们方法被调用的顺序，而函数式则颠倒了这个顺序。在 SayGoodbye 的调用中增加了一个参数，进一步模糊了方法调用的顺序。点号调用的清晰性是 Go 中调用方法的首选风格，无论是在标准库中还是在整个 Go 生态的第三方包中都是如此。\n相对于定义对某些值进行操作的方法，为类型定义方法对 Go 编程语言还有其他特殊意义，方法是接口背后的核心概念。\n接口 #  当你在 Go 中为任何类型定义方法时，该方法会被添加到该类型的方法集中。方法集是与该类型相关联的方法的集合，并被 Go 编译器用来确定某种类型是否可以分配给具有接口类型的变量。接口类型是一种方法的规范，被编译器用来保证一个类型会实现这些方法。任何具有与接口定义中相同名称、相同参数与相同返回值的方法类型都被称为实现了该接口，并允许被分配给具有该接口类型的变量。下面是标准库中 fmt.Stringer 接口的定义。\ntype Stringer interface {  String() string } 一个类型要实现 fmt.Stringer 接口，需要提供一个返回 string 的 String() 方法。实现了这个接口，当你把你的类型实例传递给 fmt 包中定义的函数时，你的类型就可以完全按照你的意愿被打印出来（有时称为 “pretty-printed”）。下面的例子定义了一个实现了这个接口的类型：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;strings\u0026#34; )  type Ocean struct { \tCreatures []string }  func (o Ocean) String() string { \treturn strings.Join(o.Creatures, \u0026#34;, \u0026#34;) }  func log(header string, s fmt.Stringer) { \tfmt.Println(header, \u0026#34;:\u0026#34;, s) }  func main() { \to := Ocean{ \tCreatures: []string{ \t\u0026#34;sea urchin\u0026#34;, \t\u0026#34;lobster\u0026#34;, \t\u0026#34;shark\u0026#34;, \t}, \t} \tlog(\u0026#34;ocean contains\u0026#34;, o) } 当你运行该代码时，你会看到这样的输出：\nOutput ocean contains : sea urchin, lobster, shark 这个例子定义了一个名为 Ocean 的新结构体类型。Ocean 实现了 fmt.Stringer 接口，因为 Ocean 定义了一个名为 String 的方法，该方法不需要参数，返回一个 string。在 main 方法中，我们定义了一个新的 Ocean，并把它传递给一个 log 函数，该函数首先接收一个 string 来打印，然后是任何实现 fmt.Stringer 的参数。Go 编译器允许我们在这里传递 o，因为 Ocean 实现了 fmt.Stringer 所要求的所有方法。在 log 中，我们使用 fmt.Println ，当它遇到 fmt.Stringer 作为其参数之一时，会调用 Ocean 的 String 方法。\n如果 Ocean 没有实现 String() 方法，Go 会产生一个编译错误，因为 log 方法要求一个 fmt.Stringer 作为其参数。这个错误看起来像这样：\nOutput src/e4/main.go:24:6: cannot use o (type Ocean) as type fmt.Stringer in argument to log:  Ocean does not implement fmt.Stringer (missing String method) Go 还将确保提供的 String() 方法与 fmt.Stringer 接口所要求的方法完全一致。如果不匹配，就会产生一个类似这样的错误：\nOutput src/e4/main.go:26:6: cannot use o (type Ocean) as type fmt.Stringer in argument to log:  Ocean does not implement fmt.Stringer (wrong type for String method)  have String()  want String() string 在到目前为止的例子中，我们已经在值接收器上定义了方法。也就是说，如果我们使用方法的功能调用，第一个参数（指的是方法所定义的类型）将是一个该类型的值，而不是一个指针。因此，我们对方法实例所做的任何修改都会在方法执行完毕后被丢弃，因为收到的值是数据的副本。此外，我们也可以在一个类型的指针接收器上定义方法。\n指针接收器 #  在指针接收器上定义方法的语法与在值接收器上定义方法的语法几乎相同。不同的是在接收器声明中用星号（*）作为类型名称的前缀。下面的例子在指针接收器上定义了一个类型的方法：\npackage main  import \u0026#34;fmt\u0026#34;  type Boat struct { \tName string  \toccupants []string }  func (b *Boat) AddOccupant(name string) *Boat { \tb.occupants = append(b.occupants, name) \treturn b }  func (b Boat) Manifest() { \tfmt.Println(\u0026#34;The\u0026#34;, b.Name, \u0026#34;has the following occupants:\u0026#34;) \tfor _, n := range b.occupants { \tfmt.Println(\u0026#34;\\t\u0026#34;, n) \t} }  func main() { \tb := \u0026amp;Boat{ \tName: \u0026#34;S.S. DigitalOcean\u0026#34;, \t}  \tb.AddOccupant(\u0026#34;Sammy the Shark\u0026#34;) \tb.AddOccupant(\u0026#34;Larry the Lobster\u0026#34;)  \tb.Manifest() } 当你运行这个例子时，你会看到以下输出：\nOutput The S.S. DigitalOcean has the following occupants: \tSammy the Shark \tLarry the Lobster 这个例子定义了一个包含 Name 和 occupants 的 Boat 类型。我们想规定其他包中的代码只用 AddOccupant 方法来添加乘员，所以我们通过小写字段名的第一个字母使 occupants 字段不被导出。我们还想确保调用 AddOccupant 会导致 Boat 实例被修改，这就是为什么我们通过指针接收器定义 AddOccupant。指针作为一个类型的特定实例的引用，而不是该类型的副本。AddOccupant 将使用 Boat 类型的指针调用，可以保证任何修改都是持久的。\n在 main 方法中，我们定义了一个新的变量 b，它将持有一个指向 Boat（*Boat）的指针。我们在这个实例上调用了两次 AddOccupant 方法来增加两名乘客。Manifest 方法是在Boat 值上定义的，因为在其定义中，接收器被指定为（b Boat）。在 main 方法中，我们仍然能够调用 Manifest，因为 Go 能够自动解引用指针以获得 Boat 值。b.Manifest()在这里等同于 (*b).Manifest()。\n当试图为接口类型的变量赋值时，一个方法是定义在一个指针接收器上还是定义在一个值接收器上有重要的影响。\n指针接收器和接口 #  当你为一个接口类型的变量赋值时，Go 编译器会检查被赋值类型的方法集，以确保它实现了所有接口方法。指针接收器和值接收器的方法集是不同的，因为接收指针的方法可以修改其接收器，而接收值的方法则不能。\n下面的例子演示了定义两个方法：一个在一个类型的指针接收器上，一个在它的值接收器上。然而，只有指针接收器能够满足本例中也定义的接口：\npackage main  import \u0026#34;fmt\u0026#34;  type Submersible interface { \tDive() }  type Shark struct { \tName string  \tisUnderwater bool }  func (s Shark) String() string { \tif s.isUnderwater { \treturn fmt.Sprintf(\u0026#34;%s is underwater\u0026#34;, s.Name) \t} \treturn fmt.Sprintf(\u0026#34;%s is on the surface\u0026#34;, s.Name) }  func (s *Shark) Dive() { \ts.isUnderwater = true }  func submerge(s Submersible) { \ts.Dive() }  func main() { \ts := \u0026amp;Shark{ \tName: \u0026#34;Sammy\u0026#34;, \t}  \tfmt.Println(s)  \tsubmerge(s)  \tfmt.Println(s) } 当你运行该代码时，你会看到这样的输出：\nOutput Sammy is on the surface Sammy is underwater 这个例子定义了一个叫做 Submersible 的接口，它要求类型实现一个 Dive() 方法。然后我们定义了一个包含 Name 字段 和 isUnderwater 方法的 Shark 类型来跟踪 Shark 的状态。我们在 Shark 的指针接收器上定义了一个 Dive() 方法，将 isUnderwater 修改为 true。我们还定义了值接收器的 String() 方法，这样它就可以使用 fmt.Println 干净利落地打印出 Shark 的状态，方法使用我们之前看过的 fmt.Println 所接收的 fmt.Stringer 接口。我们还使用了一个函数 submerge，它接受一个 Submersible 参数。\n使用 Submersible 接口而不是 *Shark 允许 submerge 方法只依赖于一个类型所提供的行为。这使得 submerge 方法更容易重用，因为你不必为 Submarine、Whale 或任何其他我们还没有想到的未来水生居民编写新的 submerge 方法。只要它们定义了一个 Dive() 方法，就可以和 submerge 方法一起使用。\n在 main 方法中，我们定义了一个变量 s，它是一个指向 Shark 的指针，并立即用 fmt.Println 打印了 s。这展示了输出的第一部分，Sammy is on the surface。我们把 s 传给submerge，然后再次调用 fmt.Println，以 s 为参数，看到输出的第二部分，Sammy is underwater。\n如果我们把 s 改成 Shark而不是 *Shark，Go 编译器会产生错误：\nOutput cannot use s (type Shark) as type Submersible in argument to submerge: \tShark does not implement Submersible (Dive method has pointer receiver) Go 编译器很好心地告诉我们，Shark 确实有一个 Dive 方法，它只在指针接收器上定义。当你在自己的代码中看到这条信息时，解决方法是在分配值类型的变量前使用 \u0026amp; 操作符，传递一个指向接口类型的指针。\n总结 #  在 Go 中声明方法与定义接收不同类型变量的函数本质上没有区别。同样，使用指针规则也适用。Go 为这种极其常见的函数定义提供了一些便利，并将这些方法收集到可以通过接口类型进行要求的方法集中。有效地使用方法可以让你在代码中使用接口来提高可测试性，并为你的代码的未来读者留下更好的结构。\n如果你想了解更多关于 Go 编程语言的一般信息，请查看我们的 How To Code in Go 系列。\n"},{"id":34,"href":"/docs/35_How_To_Build_and_Install_Go_Programs/","title":"35 How to Build and Install Go Programs","section":"Docs","content":"如何构建和安装 Go 程序 #  简介 #  到目前为止，在我们的 How To Code in Go 系列中，你已经使用了go run 命令来自动编译你的源代码并生成可执行文件。虽然这个命令对于在命令行上测试你的代码很有用，但是分发或部署你的应用程序则需要将你的代码构建成一个可共享的二进制可执行文件，或者一个包含机器字节码的单一文件来运行你的应用程序。要做到这一点，你可以使用 Go 工具链来构建和安装你的程序。\n在 Go 中，将源代码转译成二进制可执行文件的过程被称为构建。一旦这个可执行文件被构建，它将不仅包含你的应用程序，还包含在目标平台上执行二进制文件所需的所有支持代码。这意味着 Go 二进制文件不需要 Go 工具链等系统依赖就可以在新系统上运行。将这些可执行文件放在自己系统的可执行文件路径中，就可以在系统的任何地方运行程序，这与把程序安装到你的操作系统上是一样的。\n在本教程中，你将使用 Go 工具链来运行、构建和安装一个示例 Hello, World! 程序，让你有效地使用、分发和部署未来的应用程序。\n前置条件 #  要遵循本文的例子，你将需要：\n 按照如何安装 Go 与设置本地编程环境设置的 Go 工作区。  第 1 步 - 设置和运行 Go 二进制文件 #  首先，创建一个应用程序，作为演示 Go 工具链的例子。要做到这一点，你将使用如何用 Go 写第一个程序教程中的经典程序 \u0026ldquo;Hello, World!\u0026quot;。\n在你的 src 目录下创建一个名为 greeter 的目录：\nmkdir greeter 接下来，进入新创建的目录，在你选择的文本编辑器中创建 main.go 文件：\ncd greeter nano main.go 打开文件，添加以下内容：\n# src/greeter/main.go  package main  import \u0026#34;fmt\u0026#34;  func main() {  fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 当程序运行时，这个程序将在控制台打印 Hello, World! 这句话，然后程序将成功退出。\n保存并退出该文件。\n要测试这个程序，使用 go run 命令，就像你在之前的教程中做的那样：\ngo run main.go 你会收到以下输出：\nOutput Hello, World! 如前文所述，go run 命令将你的源文件构建成可执行的二进制文件，然后运行编译后的程序。然而，本教程的目的是以一种可以随意分享和分发的方式来构建二进制文件。要做到这一点，你将在下一步使用 go build 命令。\n第 2 步 \u0026ndash; 创建 Go 模块，建立 Go 二进制文件 #  Go 程序和库是围绕着模块的核心概念建立的。一个模块包含了你的程序所使用的库的信息，以及要使用这些库的什么版本。\n为了告诉 Go 这是一个 Go 模块，你需要使用 go mod 命令创建一个 Go 模块：\ngo mod init greeter 这将创建 go.mod 文件，其中包含模块的名称和用于构建模块的 Go 的版本。\nOutput go: creating new go.mod: module greeter go: to add module requirements and sums: \tgo mod tidy Go 会提示你运行 go mod tidy，以便在将来该模块的需求发生变化时更新它，现在运行它不会有额外的效果。\n第 3 步 - 用 go build 构建 Go 二进制文件 #  使用 go build，你可以为我们的示例 Go 应用程序生成可执行的二进制文件，以便在任何你想要的地方分发和部署该程序。\n在 main.go 尝试一下，在你的 greeter 目录下，运行以下命令：\ngo build 如果你没有给这个命令提供参数，go build 将自动编译你当前目录下的 main.go 程序。该命令将包括该目录中所有的 *.go 文件。它还将编译所有支持代码，以便能够在任何具有相同系统结构的计算机上执行二进制文件，无论该系统是否有 .go 源文件，甚至是否安装了 Go。\n在这种情况下，你把你的 greeter 程序构建在一个可执行文件中，并被添加到你的当前目录中。通过运行 ls 命令来检查：\nls 如果你运行的是 macOS 或 Linux 系统，你会发现一个以你构建程序的目录命名的新可执行文件：\nOutput greeter main.go go.mod 注：在Windows上，你的可执行文件将是 greeter.exe。 默认情况下，go build 将为当前平台和架构生成一个可执行文件。例如，如果在 linux/386 系统上构建，可执行文件将与任何其他 linux/386 系统兼容，即使并没有安装 Go。Go 支持为其他平台和架构进行构建，你可以在我们的为不同操作系统和架构构建 Go 应用程序文章中了解更多信息。\n现在，你已经创建了你的可执行文件，运行它以确保二进制文件已被正确构建。在 macOS 或 Linux 上，运行以下命令：\n./greeter 在 Windows 上，运行：\ngreeter.exe 二进制文件的输出将与你用 go run 运行程序时的输出一致：\nOutput Hello, World! 现在你已经创建了一个单一的可执行二进制文件，它不仅包含你的程序，还包含运行该二进制文件所需的所有系统代码。因为这个文件将始终运行同一个程序，你现在可以将这个程序分发到新的系统中，或者将其部署到服务器上。\n在下一节中，本教程将解释二进制文件是如何命名的，以及你如何改变它，以便你能更好地控制程序的构建过程。\n第 4 步 - 改变二进制名称 #  现在你知道了如何生成可执行文件，下一步则是确定 Go 如何为二进制文件选择一个名字，并为你的项目定制这个名字。\n当你运行 go build 时，默认情况下 Go 会自动决定生成的可执行文件的名称。它通过使用你之前创建的模块来实现这一目的。当运行 go mod init greeter 命令时，它创建了名为 greeter 的模块，这就是为什么生成的二进制文件被命名为 greeter。\n让我们仔细看看这个模块方法。如果你的项目中有一个 go.mod 文件，其中有一个 module 声明，像下面这样：\n# go.mod module github.com/sammy/shark 那么生成的可执行文件默认名称将是 shark。\n在需要特定命名规则的更复杂的程序中，这些默认值并不总是你命名二进制文件的最佳选择。在这些情况下，最好用 -o 标识来定制你的输出。\n为了测试这一点，把你在上一节中制作的可执行文件的名称改为 hello，并把它放在一个名为 bin 的子文件夹中。你不需要创建这个文件夹，Go 会在构建过程中自行完成。\n运行以下带有 -o 标志的 go build 命令：\ngo build -o bin/hello -o 标志使 Go 将命令的输出与你选择的任何参数相匹配。在本例中，结果是在一个名为 bin 的子文件夹中产生一个名为 hello 的新可执行文件。\n要测试新的可执行文件，请切换到新目录并运行二进制文件:\ncd bin ./hello 你将收到以下输出:\nOutput Hello, World! 现在你可以自定义你的可执行文件名称，以适应项目需要，这完成了我们对如何在 Go 中构建二进制文件的调研。但是使用 go build，你仍然只限于在当前目录下运行你的二进制文件。为了在系统的任何地方使用新建立的可执行文件，你可以用 go install 来安装它们。\n第 5 步 - 用 go install 安装 Go 程序 #  到目前为止，在这篇文章中，我们已经讨论了如何从我们的 .go 源文件中生成可执行二进制文件。这些可执行文件有助于分发、部署和测试，但它们还不能在其源文件目录之外执行。如果你想在 shell 脚本或其他工作流程中使用你的程序，这将是一个问题。为了使这些程序更容易使用，你可以把它们安装到你的系统中，并从任何地方访问它们。\n为了理解这一点的含义，你将使用 go install 命令来安装你的示例程序。\ngo install 命令与 go build 几乎相同，但它不是将可执行文件留在当前目录或由 o 标志编译到指定的目录中，而是将可执行文件放到 $GOPATH/bin 目录中。\n要找到你的 $GOPATH 目录的位置，请运行以下命令：\ngo env GOPATH 你收到的输出会有所不同，但默认是你的 $HOME 目录下的 go 目录：\nOutput $HOME/go 由于 go install 会将生成的可执行文件放入 $GOPATH 的一个子目录，名为 bin，这个目录必须被添加到 $PATH 环境变量中。这在先决条件文章如何安装 Go 和设置本地编程环境的创建 Go 工作空间步骤中有所涉及。\n设置好 $GOPATH/bin 目录后，切回你的 greeter 目录：\ncd .. 现在运行安装命令：\ngo install 这将构建你的二进制文件并将其放在 $GOPATH/bin 中。要测试这一点，请运行以下程序：\nls $GOPATH/bin 这将列出 $GOPATH/bin 的内容：\nOutput greeter 注：`go install` 命令不支持 `-o` 标记，所以它将使用前面描述的默认名称来命名可执行文件。 安装好二进制文件后，测试一下程序是否能从其源目录外运行，切回你的主目录：\ncd $HOME 使用以下方法来运行该程序：\ngreeter 这将产生以下结果：\nOutput Hello, World! 现在，你可以把你编写的程序安装到你的系统中，让你在任何地方、任何时候都能使用它们。\n总结 #  在本教程中，你演示了 Go 工具链是如何从源代码中轻松构建可执行二进制文件的。这些二进制文件可以分发到其他系统上运行，甚至是那些没有 Go 工具链和环境的系统。你还使用 go install 自动构建并将程序作为可执行文件安装在系统的 $PATH 中。有了 go build 和 go install，你现在可以随意分享和使用你的应用程序。\n现在你了解了 go build 的基础知识，你可以通过用 Build 标签定制 Go 二进制文件教程来探索如何制作模块化的源代码，或者通过为不同的操作系统和架构构建 Go 应用程序来探索如何为不同的平台构建。如果你想了解更多关于 Go 编程语言的信息，请查看整个How To Code in Go 系列。\n"},{"id":35,"href":"/docs/36_How_To_Use_Struct_Tags_in_Go/","title":"36 How to Use Struct Tags in Go","section":"Docs","content":"如何在 Go 中使用结构体标签 #  简介 #  结构，或称结构体，被用来将多个信息聚合在一个单元中。这些信息集合被用来描述更高层次的概念，例如由 Street、City、State 和 PostalCode 组成的 Address。当你从数据库或 API 等系统中读取这些信息时，你可以使用结构体标签来控制这些信息如何被分配到结构体的字段中。结构体标签是附加在结构体字段上的小块元数据，为与该结构体一起工作的其他 Go 代码提供指示。\n结构体标签是怎么样的 #  Go 结构体标签是出现在 Go 结构声明中类型后的注释，每个标签都由与一些相应的值相关的短字符串组成。\n一个结构体的标签看起来像这样，标签的偏移量为 ` 字符：\ntype User struct { \tName string `example:\u0026#34;name\u0026#34;` } 其他 Go 代码就能够检查这些结构并提取分配给它所要求的特定键的值。如果没有其他代码对其进行检查，结构体标签对你的代码运行没有任何影响。\n试试这个例子，看看结构体标签是怎么样的，如果没有来自另一个包的代码，它们将没有任何作用。\npackage main  import \u0026#34;fmt\u0026#34;  type User struct { \tName string `example:\u0026#34;name\u0026#34;` }  func (u *User) String() string { \treturn fmt.Sprintf(\u0026#34;Hi! My name is %s\u0026#34;, u.Name) }  func main() { \tu := \u0026amp;User{ \tName: \u0026#34;Sammy\u0026#34;, \t}  \tfmt.Println(u) } 这将输出：\nOutput Hi! My name is Sammy 这个例子定义了一个带有 Name 字段的 User 类型。Name 字段被赋了一个结构体标签 example: \u0026quot;name\u0026quot;。我们把这个特定的标签称为 “example 结构体标签”，因为它使用 “example”这个词作为它的键。example 结构体标签的 Name 字段值是 \u0026quot;name\u0026quot;。在 User 类型中，我们还定义了 fmt.Stringer 接口要求的 String() 方法。当我们将该类型传递给 fmt.Println 时，该方法将被自动调用，并使我们可以生成一个格式化的结构体版本。\n在 main 方法中，我们创建了一个新的 User 类型实例，并将其传递给 fmt.Println。尽管这个结构体有一个结构体标签，但我们可以看到它对这个 Go 代码的操作没有影响。如果不存在结构标签，它的行为也会完全一样。\n要使用结构标签来完成某些事，必须编写其他 Go 代码在运行时检查结构体。标准库中有一些包将结构体标签作为其操作的一部分，其中最受欢迎的是 encoding/json 包。\n编码 JSON #  JavaScript 对象符号（JSON）是一种文本格式，用于编码根据不同字符串键组织的数据集合。它通常用于不同程序之间的数据通信，因为这种格式足够简单，以至于许多不同的语言都有库对其进行解码，下面是一个 JSON 的例子：\n{  \u0026#34;language\u0026#34;: \u0026#34;Go\u0026#34;,  \u0026#34;mascot\u0026#34;: \u0026#34;Gopher\u0026#34; } 这个 JSON 对象包含两个键，language 和 mascot。这些键后面是相关的值，language 键的值为 Go，mascot 则为 Gopher。\n标准库中的 JSON 编码器利用结构体标签作为注解，向编码器表明你想在 JSON 输出中如何命名你的字段。这些 JSON 编码和解码机制可以在 encoding/json 包中找到。\n试试这个例子，看看没有结构体标签的 JSON 是如何编码的：\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  type User struct { \tName string \tPassword string \tPreferredFish []string \tCreatedAt time.Time }  func main() { \tu := \u0026amp;User{ \tName: \u0026#34;Sammy the Shark\u0026#34;, \tPassword: \u0026#34;fisharegreat\u0026#34;, \tCreatedAt: time.Now(), \t}  \tout, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) \tif err != nil { \tlog.Println(err) \tos.Exit(1) \t}  \tfmt.Println(string(out)) } 这将打印以下输出：\nOutput {  \u0026#34;Name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;,  \u0026#34;Password\u0026#34;: \u0026#34;fisharegreat\u0026#34;,  \u0026#34;CreatedAt\u0026#34;: \u0026#34;2019-09-23T15:50:01.203059-04:00\u0026#34; } 我们定义了一个描述用户的结构，其字段包括用户的姓名、密码和用户的创建时间。在 main 方法中，我们为所有字段提供了值，除了 PreferredFish（Sammy 喜欢所有的鱼），从而创建了这个用户的实例。然后我们把 User 实例传递给 json.MarshalIndent 方法。这样我们可以更容易地看到 JSON 的输出，而不需要使用外部格式化工具。这个调用可以用 json.Marshal(u) 代替，以接收没有任何额外空白的 JSON。json.MarshalIndent 的两个额外参数控制输出的前缀（我们用空字符串省略了），以及缩进使用的字符，这里是两个空格字符。任何由 json.MarshalIndent 产生的错误都会被记录下来，程序使用 os.Exit(1) 终止。最后，我们将从 json.MarshalIndent 返回的 []byte 转换为 string，并将生成的字符串交给 fmt.Println 处理以便在终端打印。\n该结构的字段完全按照我们的命名出现。这不是您所期望的典型的 JSON 风格，它使用了字段名的骆驼字母大小写。在接下来的例子中，你将改变字段的名称，使其遵循骆驼大写的风格。正如你在运行这个例子时看到的，这不会起作用，因为想要的字段名与 Go 导出字段名的规则相冲突。\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  type User struct { \tname string \tpassword string \tpreferredFish []string \tcreatedAt time.Time }  func main() { \tu := \u0026amp;User{ \tname: \u0026#34;Sammy the Shark\u0026#34;, \tpassword: \u0026#34;fisharegreat\u0026#34;, \tcreatedAt: time.Now(), \t}  \tout, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) \tif err != nil { \tlog.Println(err) \tos.Exit(1) \t}  \tfmt.Println(string(out)) } 这将呈现以下输出：\nOutput {} 在这个版本中，我们把字段的名字改成了驼峰式。现在 Name 是 name，Password 是 password，最后 CreatedAt 是 createdAt。在 main 方法中，我们改变了结构的实例化，以使用这些新的名称。然后我们像以前一样将结构体传递给 json.MarshalIndent 函数。这次输出是一个空的 JSON 对象，{}。\n骆驼对字段的正确命名要求第一个字符必须是小写的。虽然 JSON 并不关心你如何命名你的字段，但 Go 关心，因为它表示字段在包外的可见性。由于 encoding/json 包与我们使用的 main 包是互相独立的，我们必须将第一个字符大写，以使其对 encoding/json 可见。看来我们陷入了僵局，我们需要一些方法来向 JSON 编码器传达我们希望这个字段被命名成什么。\n使用结构体标签来控制编码 #  你可以修改前面的例子，通过给每个字段注解一个结构体标签，使导出的字段用驼峰大写的字段名进行正确编码。encoding/json 识别的结构体标签有一个 json 的键和一个控制输出的值。通过将字段名的驼峰版本作为 json 键的值，编码器将使用该名称代替。这个例子修正了前两次的尝试：\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  type User struct { \tName string `json:\u0026#34;name\u0026#34;` \tPassword string `json:\u0026#34;password\u0026#34;` \tPreferredFish []string `json:\u0026#34;preferredFish\u0026#34;` \tCreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` }  func main() { \tu := \u0026amp;User{ \tName: \u0026#34;Sammy the Shark\u0026#34;, \tPassword: \u0026#34;fisharegreat\u0026#34;, \tCreatedAt: time.Now(), \t}  \tout, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) \tif err != nil { \tlog.Println(err) \tos.Exit(1) \t}  \tfmt.Println(string(out)) } 这将输出：\nOutput {  \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;,  \u0026#34;password\u0026#34;: \u0026#34;fisharegreat\u0026#34;,  \u0026#34;preferredFish\u0026#34;: null,  \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T18:16:17.57739-04:00\u0026#34; } 我们把字段名改回来了，通过把名字的第一个字母大写来让其他包看到。然而，这次我们以 json: \u0026quot;name\u0026quot; 的形式添加了结构体标签，其中 \u0026quot;name\u0026quot; 是我们希望 json.MarshalIndent 将结构体打印成 JSON 时使用的名称。\n我们现在已经成功地正确格式化了我们的 JSON。然而，请注意，一些我们没有设置值的字段也被打印了出来。如果你愿意，JSON 编码器也可以省略这些字段。\n删除空的 JSON 字段 #  最常见的是，我们想省略输出 JSON 中未设置的字段。由于 Go 中的所有类型都有一个“零值”，即它们被设置成的一些默认值，encoding/json 包需要额外的信息，以便能够告诉某些字段在赋这个零值时应该被视为未设置。在任何 json 结构体标签的值部分，你可以在你的字段的所需名称后面加上 ,omitempty 来告诉 JSON 编码器，当字段被设置为零值时，省略这个字段的输出。下面的例子修正了之前的例子，不再输出空字段：\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  type User struct { \tName string `json:\u0026#34;name\u0026#34;` \tPassword string `json:\u0026#34;password\u0026#34;` \tPreferredFish []string `json:\u0026#34;preferredFish,omitempty\u0026#34;` \tCreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` }  func main() { \tu := \u0026amp;User{ \tName: \u0026#34;Sammy the Shark\u0026#34;, \tPassword: \u0026#34;fisharegreat\u0026#34;, \tCreatedAt: time.Now(), \t}  \tout, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) \tif err != nil { \tlog.Println(err) \tos.Exit(1) \t}  \tfmt.Println(string(out)) } 这个例子将输出：\nOutput {  \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;,  \u0026#34;password\u0026#34;: \u0026#34;fisharegreat\u0026#34;,  \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T18:21:53.863846-04:00\u0026#34; } 我们修改了前面的例子，使 PreferredFish 字段现在有结构体标签 json:\u0026quot;preferredFish,omitempty\u0026quot;。,omitempty 的存在使 JSON 编码器跳过该字段，因为我们决定不设置它。在我们以前的例子的输出中，它的值是 null。\n这个输出看起来好多了，但我们仍然打印出了用户的密码。encoding/json 包提供了另一种方法，让我们完全忽略私有字段。\n忽略私有字段 #  有些字段必须从结构体中导出，以便其他包可以正确地与该类型交互。然而，这些字段的性质可能是敏感的，所以在这些情况下，即使它被设置了值，我们仍希望 JSON 编码器能够完全忽略该字段。这可以用特殊值 \u0026quot;-\u0026quot; 作为 json: 结构体标签的值参数来实现。\n这个例子修正了暴露用户密码的问题。\npackage main  import ( \t\u0026#34;encoding/json\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;log\u0026#34; \t\u0026#34;os\u0026#34; \t\u0026#34;time\u0026#34; )  type User struct { \tName string `json:\u0026#34;name\u0026#34;` \tPassword string `json:\u0026#34;-\u0026#34;` \tCreatedAt time.Time `json:\u0026#34;createdAt\u0026#34;` }  func main() { \tu := \u0026amp;User{ \tName: \u0026#34;Sammy the Shark\u0026#34;, \tPassword: \u0026#34;fisharegreat\u0026#34;, \tCreatedAt: time.Now(), \t}  \tout, err := json.MarshalIndent(u, \u0026#34;\u0026#34;, \u0026#34; \u0026#34;) \tif err != nil { \tlog.Println(err) \tos.Exit(1) \t}  \tfmt.Println(string(out)) } 当你运行这个例子时，你会看到这样的输出：\nOutput {  \u0026#34;name\u0026#34;: \u0026#34;Sammy the Shark\u0026#34;,  \u0026#34;createdAt\u0026#34;: \u0026#34;2019-09-23T16:08:21.124481-04:00\u0026#34; } 这个例子与之前的例子相比，唯一的变化是密码字段。现在使用了特殊的 \u0026quot;-\u0026quot; 作为其 json: 结构体标签的值。我们看到，在这个例子的输出中，password 字段不再存在了。\nencoding/json 包的这些特征，,omitempty 和 \u0026quot;-\u0026quot;，并不是标准。一个包决定对结构体标签的值做什么取决于它的实现。因为 encoding/json 包是标准库的一部分，其他包也以同样的方式实现这些功能，这是一个惯例。然而，很重要的一点是阅读任何使用结构体标签的第三方软件包的文档，以了解哪些是支持的，哪些是不支持的。\n总结 #  结构体标签提供了一种强大的手段来拓展了使用你定义的结构体代码的功能。许多标准库和第三方包提供了通过使用结构体标签来定制其操作的方法。在你的代码中有效地使用它们，既能提供这种定制行为，又能为未来的开发者简要记录这些字段的使用方法。\n"},{"id":36,"href":"/docs/37-How_To_Use_Interfaces_in_Go/","title":"37 How to Use Interfaces in Go","section":"Docs","content":"如何在 Go 使用 interface #  简述 #  编写灵活的、可重复使用的、模块化的代码对于开发多功能的程序至关重要。以这种方式开发，可以避免在多个地方做同样的修改，从而确保代码更容易维护。如何完成这个目标，不同语言有不同的实现方法来完成这个目标。例如，继承是一种常见的方法，在 Java、C++、C#等语言中都有使用。\n开发者们也可以通过组合实现这个设计目标。组合是一个将多个对象和数据类型组合到一个复杂的结构体中的方式。这个是 Go 用来促进代码复用，模块化和灵活性的方法。在 Go 中 intrerface 提供了一个方法用于构建复杂的组合，学习使用它们，将会使你创建通用的可重复使用的代码。\n在这篇文章中，我们将会学习如何构建那些有相同行为的自定义类型，用于复用代码。 我们还将学习如何为我们自己的自定义类型实现 interface，以满足在另一个包中定义的接口。\n定义一个行为 #  组合实现的核心之一是使用 interface。一个 interface 定义一个类型的行为。Go 标准库中最常用的 interface 之一是fmt.Stringer 接口：\ntype Stringer interface {  String() string } 第一行代码定义一个type叫Stringer。然后表明它是一个interface。就好像定义一个结构体，Go 使用大括号({})来囊括 interface 的定义。跟结构体的定义相比，我们只定义interface的行为，就是“这个类型可以做什么”\n对这个Stringer接口的例子来说，唯一的行为就是String()这个方法。这个方法没有参数。\n接着，让我们看一些代码，这些代码有fmt.Stringer的行为：\npackage main  import \u0026#34;fmt\u0026#34;  type Article struct { \tTitle string \tAuthor string }  func (a Article) String() string { \treturn fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) }  func main() { \ta := Article{ \tTitle: \u0026#34;Understanding Interfaces in Go\u0026#34;, \tAuthor: \u0026#34;Sammy Shark\u0026#34;, \t} \tfmt.Println(a.String()) } 第一件事是我们创建了一个新的类型叫做Article。这个类型有一个Title和一个Author字段，两个都是 string 的 数据类型:\n... type Article struct { \tTitle string \tAuthor string } ... 接着，我们为 Article 类型定义了一个叫做 String 的 方法。String方法将会返回一个用于表示Article类型的字符串：\n... func (a Article) String() string { \treturn fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) } ... 然后，在我们的mainfunction里，我们创建一个Article类型的实例，并且将它赋值给一个变量叫a。我们给Title字段设置了一个值，为\u0026quot;理解Go中的Interfaces\u0026quot;，给Author字段赋值\u0026quot;Sammy Shark\u0026quot;：\n... a := Article{ \tTitle: \u0026#34;Understanding Interfaces in Go\u0026#34;, \tAuthor: \u0026#34;Sammy Shark\u0026#34;, } ... 紧接着，我们通过调用fmt.Println并传入调用a.String()后的结果，打印出String方法的结果：\n... fmt.Println(a.String()) 随后运行程序，你会发现如下输出：\nOutput The \u0026#34;Understanding Interfaces in Go\u0026#34; article was written by Sammy Shark. 至此，我们还没有使用 interface，但是我们创建了一个具备一个行为的类型。这个行为匹配fmt.Stringer接口。随后，让我们看看如何利用这种行为来使我们的代码更容易重复使用。\n定义一个 interface #  现在，我们已经用所需的行为定义了我们的类型，我们可以看看如何使用该行为。\n然而，在这之前，让我们看看如果我们想在一个函数中从Article类型中调用String方法，我们需要做什么：\npackage main  import \u0026#34;fmt\u0026#34;  type Article struct { \tTitle string \tAuthor string }  func (a Article) String() string { \treturn fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) }  func main() { \ta := Article{ \tTitle: \u0026#34;Understanding Interfaces in Go\u0026#34;, \tAuthor: \u0026#34;Sammy Shark\u0026#34;, \t} \tPrint(a) }  func Print(a Article) { \tfmt.Println(a.String()) } 这段代码中，我们添加了一个名为Print的新函数，该函数接收一个Article作为参数。请注意，Print函数唯一做的事情是调用String方法。正因为如此，我们则可以定义一个接口来传递给函数。\npackage main  import \u0026#34;fmt\u0026#34;  type Article struct { \tTitle string \tAuthor string }  func (a Article) String() string { \treturn fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) }  type Stringer interface { \tString() string }  func main() { \ta := Article{ \tTitle: \u0026#34;Understanding Interfaces in Go\u0026#34;, \tAuthor: \u0026#34;Sammy Shark\u0026#34;, \t} \tPrint(a) }  func Print(s Stringer) { \tfmt.Println(s.String()) } 这里我们创建了一个 interface 叫做Stringer：\n... type Stringer interface { \tString() string } ... Stringerinterface 只有一个方法，叫做String()，返回一个string。method是一个特殊的函数，在 Go 中被限定于一个特殊类型。不像函数，一个方法只能从它所定义的类型的实例中被调用。\n然后我们更新Print方法的签名来接收一个Stringer，而不是一个Article的具体类型。因为编译器知道Stringer接口定义了String方法，所以它只接收也有String方法的类型。\n现在我们可以对任何满足Stringer接口的东西使用Print方法。让我们创建另一个类型来证明这一点：\npackage main  import \u0026#34;fmt\u0026#34;  type Article struct { \tTitle string \tAuthor string }  func (a Article) String() string { \treturn fmt.Sprintf(\u0026#34;The %q article was written by %s.\u0026#34;, a.Title, a.Author) }  type Book struct { \tTitle string \tAuthor string \tPages int }  func (b Book) String() string { \treturn fmt.Sprintf(\u0026#34;The %q book was written by %s.\u0026#34;, b.Title, b.Author) }  type Stringer interface { \tString() string }  func main() { \ta := Article{ \tTitle: \u0026#34;Understanding Interfaces in Go\u0026#34;, \tAuthor: \u0026#34;Sammy Shark\u0026#34;, \t} \tPrint(a)  \tb := Book{ \tTitle: \u0026#34;All About Go\u0026#34;, \tAuthor: \u0026#34;Jenny Dolphin\u0026#34;, \tPages: 25, \t} \tPrint(b) }  func Print(s Stringer) { \tfmt.Println(s.String()) } 现在，我们添加了第二个类型叫Book。它同样也有定义String方法。这表示它也满足Stringer接口。因此，我们也可以传递它到Print函数：\nOutput The \u0026#34;Understanding Interfaces in Go\u0026#34; article was written by Sammy Shark. The \u0026#34;All About Go\u0026#34; book was written by Jenny Dolphin. It has 25 pages. 到目前为止，我们已经演示了如何只使用一个 interface。然而，一个 interface 可以有不止一个行为的定义。接下来，我们将看到如何通过声明更多的方法来使我们的 interface 更加通用。\n多行为 interface #  编写 Go 代码的核心原则之一是编写小而简洁的类型，并将它们组成更大，更复杂的类型。组合 interface 也是一样的。为了了解我们是如何建立一个 interface 的，我们先从只定义一个 interface 开始。我们将会定义 2 个形状，一个Circle和一个Square，然后他们都会定义一个方法叫Area。这个方法会返回它们对应形状的几何面积：\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;math\u0026#34; )  type Circle struct { \tRadius float64 }  func (c Circle) Area() float64 { \treturn math.Pi * math.Pow(c.Radius, 2) }  type Square struct { \tWidth float64 \tHeight float64 }  func (s Square) Area() float64 { \treturn s.Width * s.Height }  type Sizer interface { \tArea() float64 }  func main() { \tc := Circle{Radius: 10} \ts := Square{Height: 10, Width: 5}  \tl := Less(c, s) \tfmt.Printf(\u0026#34;%+v is the smallest\\n\u0026#34;, l) }  func Less(s1, s2 Sizer) Sizer { \tif s1.Area() \u0026lt; s2.Area() { \treturn s1 \t} \treturn s2 } 因为每个类型都定义了Area方法，我们可以创建一个 interface 来定义这个行为。我们创建如下的Sizerinterface:\n... type Sizer interface { \tArea() float64 } ... 然后定义一个函数叫做Less，传入 2 个Sizer并返回最小的那一个：\n... func Less(s1, s2 Sizer) Sizer { \tif s1.Area() \u0026lt; s2.Area() { \treturn s1 \t} \treturn s2 } ... 注意到我们不仅接收 2 个都为Sizer的类型，而且返回的结果也用Sizer。这意味着我们不再返回一个Square或者一个Circle，而是Sizerinterface。\n最后，我们打印出哪一个是最小的面积：\nOutput {Width:5 Height:10} is the smallest 接着，让我们给每个类型添加另一个行为。这次我们添加String()方法，返回一个 string。这个满足fmt.Stringerinterface:\npackage main  import ( \t\u0026#34;fmt\u0026#34; \t\u0026#34;math\u0026#34; )  type Circle struct { \tRadius float64 }  func (c Circle) Area() float64 { \treturn math.Pi * math.Pow(c.Radius, 2) }  func (c Circle) String() string { \treturn fmt.Sprintf(\u0026#34;Circle {Radius: %.2f}\u0026#34;, c.Radius) }  type Square struct { \tWidth float64 \tHeight float64 }  func (s Square) Area() float64 { \treturn s.Width * s.Height }  func (s Square) String() string { \treturn fmt.Sprintf(\u0026#34;Square {Width: %.2f, Height: %.2f}\u0026#34;, s.Width, s.Height) }  type Sizer interface { \tArea() float64 }  type Shaper interface { \tSizer \tfmt.Stringer }  func main() { \tc := Circle{Radius: 10} \tPrintArea(c)  \ts := Square{Height: 10, Width: 5} \tPrintArea(s)  \tl := Less(c, s) \tfmt.Printf(\u0026#34;%v is the smallest\\n\u0026#34;, l)  }  func Less(s1, s2 Sizer) Sizer { \tif s1.Area() \u0026lt; s2.Area() { \treturn s1 \t} \treturn s2 }  func PrintArea(s Shaper) { \tfmt.Printf(\u0026#34;area of %s is %.2f\\n\u0026#34;, s.String(), s.Area()) } 因为Circle和Square类型都同时实现了Area和String方法，我们现在可以创建另一个 interface 来描述这些更广泛的行为。为了实现这个，我们创建了一个 interface 叫做Shaper。这个Shaper将由Sizerinterface 和fmt.Stringerinterface 组成：\n... type Shaper interface { \tSizer \tfmt.Stringer } ... **注意：**基于习惯，尝试以er结尾来给你的 interface 命名，例如fmt.Stringer，io.Writer等等。这也是为什么我们用Shaper来命名我们的 interface，而不是Shape。\n现在我们可以创建一个名为PrintArea的函数，该函数以Shaper为参数。这意味着我们可以对传入的值调用Area和String这两个方法：\n... func PrintArea(s Shaper) { \tfmt.Printf(\u0026#34;area of %s is %.2f\\n\u0026#34;, s.String(), s.Area()) } 如果我们运行程序，将会收到如下输出：\nOutput area of Circle {Radius: 10.00} is 314.16 area of Square {Width: 5.00, Height: 10.00} is 50.00 Square {Width: 5.00, Height: 10.00} is the smallest 我们现在已经看到了我们如何创建较小的 interface，并根据需要将它们建立成较大的 interface。虽然我们可以从较大的 interface 开始，并将其传递给我们所有的函数，但最好的做法是只将最小的 interface 发送给需要的函数。这通常会使代码更加清晰，因为任何接收特定的较小的 interface 的东西都只打算执行其定义的行为。\n例如，如果我们将Shaper传递给Less函数，我们可能会认为它要同时调用Area和String方法。然而，由于我们只打算调用Area方法，这使得Less函数很清楚，因为我们知道我们只能调用传递给它的任何参数的Area方法。\n总结 #  我们已经看到，创建较小的 interface 并将其构建为较大的 interface，可以让我们只分享我们需要的函数或方法。我们还了解到，我们可以从其他 interface 中组成我们的 interface，包括从其他包中定义的 interface，而不仅仅是我们的包。\n"},{"id":37,"href":"/docs/38-Building_Go_Applications_for_Different_Operating_Systems_and_Architectures/","title":"38 Building Go Applications for Different Operating Systems and Architectures","section":"Docs","content":"在不同的操作系统和架构编译 Go 应用 #  在软件开发中，重要的是要考虑你想为之编译二进制的操作系统和底层处理器架构。因为在不同的操作系统/架构平台上运行一个二进制文件通常很慢或不可能，所以通常的做法是为许多不同的平台编译你最终的二进制文件，以最大化你的程序的受众。然而，这通常是很困难的，当你开发软件的平台和你想要部署的平台不是同一个的时候。例如，在过去，在 Windows 上开发一个程序并将其部署到 Linux 或 macOS 机器上，需要为每一个你想要的二进制文件的环境设置构建机器。你还需要保持你的工具同步，此外还有其他考虑因素，这些因素会增加成本，使协作测试和分布式更加困难。\nGo 通过在go build工具中直接建立对多平台的支持，以及 Go 工具链的其他部分解决了这个问题。通过使用环境变量和构建标签，你可以控制你最终的二进制文件是为哪个操作系统和架构构建的，此外还可以把一个工作流程放在一起，在不改变你的代码库的情况下快速切换对平台依赖的代码。\n在本教程中，你将把一个将strings连接成文件路径的示例应用程序放在一起，创建并有选择地包括与平台有关的片段，并在你自己的系统上为多个操作系统和系统架构构建二进制文件，向你展示如何使用 Go 编程语言的这一强大能力。\n前期准备 #  为了跟随本文的例子，你将需要：\n 按照如何安装 Go 和设置本地程序环境设置的 Go 的 workspace  GOOS和GOARCH可能支持的平台 #  在展示如何控制构建过程为不同的平台构建二进制文件之前，让我们先了解一下 Go 能够为哪些类型的平台进行构建，以及 Go 如何使用环境变量GOOS和GOARCH关联这些平台。\nGo 工具有一个命令，可以打印出 Go 可以构建的平台的列表。这个列表会随着每一个新的 Go 版本而改变，所以这里讨论的组合在另一个版本的 Go 中可能不一样。当下写这个教程的时候，Go release 版本是 1.13.\n为了找到适用的平台，执行如下命令：\ngo tool dist list 你将会收到如下相似的输出：\nOutput aix/ppc64 freebsd/amd64 linux/mipsle openbsd/386 android/386 freebsd/arm linux/ppc64 openbsd/amd64 android/amd64 illumos/amd64 linux/ppc64le openbsd/arm android/arm js/wasm linux/s390x openbsd/arm64 android/arm64 linux/386 nacl/386 plan9/386 darwin/386 linux/amd64 nacl/amd64p32 plan9/amd64 darwin/amd64 linux/arm nacl/arm plan9/arm darwin/arm linux/arm64 netbsd/386 solaris/amd64 darwin/arm64 linux/mips netbsd/amd64 windows/386 dragonfly/amd64 linux/mips64 netbsd/arm windows/amd64 freebsd/386 linux/mips64le netbsd/arm64 windows/arm 输出是一些以/分割的键值对。键值对的第一个部分，在/之前的是操作系统。在 Go 里面，这些操作系统会是环境变量GOOS的值，发音像“goose”，代表Go Operation System。第二部分，在/之后的，是架构。如前所述，这些都是环境变量GOARCH可能的值。这个发音\u0026quot;gore-ch\u0026quot;，代表Go Architecture。\n让我们以linux/386为例，对其中的一个组合进行分解，了解它的含义和工作原理。键值对以GOOS开始，在这个例子中是linux，指的是Linux 操作系统。这里的GOARCH应该是386，它代表英特尔 80386 微处理器。\n有许多平台可以使用go build命令，但大多数情况下，你最终会使用linux , windows或darwin作为 GOOS 的值。这些涵盖了三大操作系统平台： Linux、Windows和macOS，后者是基于Darwin Operating system的，因此被称为darwin。然而，Go 也可以覆盖不太主流的平台，如nacl，它代表了谷歌的本地客户端。\n当你运行go build这样的命令时，Go 使用当前平台的GOOS和GOARCH来决定如何构建二进制文件。要想知道你的平台是什么组合，你可以使用go env命令，并将GOOS和GOARCH作为参数：\ngo env GOOS GOARCH 在测试这个例子时，我们在一台AMD64 架构的机器上的 macOS 上运行这个命令，所以我们将收到以下输出：\nOutput darwin amd64 这个命令的输出告诉我们系统的 GOOS 是 darwin，GOARCH 是 amd64。\n你现在知道了 Go 中的GOOS和GOARCH是什么，以及它们的可能值。接下来，你将编写一个程序，作为如何使用这些环境变量和构建标签为其他平台构建二进制文件的例子。\n用filepath.Join编写一个平台依赖的应用程序 #  在你开始构建其他平台的二进制前，让我们先构建一个范例程序。出于这个目的，一个好的例子可以用 Go 标准库中的path/filepath包内的Join函数。这个函数以多个 string 为传参，并返回一个用正确文件路径分隔符拼接的 string。\n这是一个很好的范例程序，因为该程序的运行取决于它在哪个操作系统上运行。在 Windows 上，路径分隔符是反斜杠，\\，而基于 Unix 的系统使用正斜杠，/。\n让我们从构建一个使用filepath.Join()的应用程序开始，稍后，你将编写你自己的Join()函数的实现，将代码定制为特定平台的二进制文件。\n首先，在你的src目录下创建一个文件夹，用你的应用程序的名字命名：\nmkdir app 进入目录：\ncd app 接下来，在你选择的文本编辑器中创建一个名为main.go的新文件。在本教程中，我们将使用 Nano。\nnano main.go 文件打开后，添加如下代码：\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;path/filepath\u0026#34; )  func main() {  s := filepath.Join(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)  fmt.Println(s) } 在这个文件的main()函数用filepath.Join()将三个strings用正确的，平台依赖的路径分隔符连接起来。\n保存并退出文件，然后运行程序：\ngo run main.go 当运行这个程序时，你将收到不同的输出，这取决于你所使用的平台。在 Windows 上，你会看到用\\分隔的字符串。\nOutput a\\b\\c 在 MacOS 和 Linux 等 Unix 系统上，你将收到以下内容。\nOutput a/b/c 这表明，由于这些操作系统使用的文件系统协议不同，程序将不得不为不同的平台构建不同的代码。但由于它已经根据操作系统使用了不同的文件分隔符，所有我们知道filepath.Join()已经考虑了平台的差异。这是因为 Go 工具链会自动检测你的机器的GOOS和GOARCH，并使用这些信息来使用具有正确构建标签和文件分隔符的代码片段。\n让我们思考一下filepath.Join()函数的分隔符是从哪里来的。运行以下命令来查看 Go 标准库中的相关片段：\nless /usr/local/go/src/os/path_unix.go 这将显示path_unix.go的内容。寻找该文件的如下部分：\n. . . // +build aix darwin dragonfly freebsd js,wasm linux nacl netbsd openbsd solaris  package os  const (  PathSeparator = \u0026#39;/\u0026#39; // OS-specific path separator  PathListSeparator = \u0026#39;:\u0026#39; // OS-specific path list separator ) . . . 这一段为 Go 为支持的所有类 Unix 系统定义了 PathSeparator。 注意顶部的所有构建标签，它们是与 Unix 相关的每一个可能的 Unix GOOS平台。当GOOS与这些名词匹配时，你的程序将产生 Unix 风格的文件路径分隔符。\n按q返回到命令行。\n接下来，打开定义在 Windows 上使用filepath.Join()时的行为的文件。\nless /usr/local/go/src/os/path_windows.go 你会看到如下内容：\n. . . package os  const (  PathSeparator = \u0026#39;\\\\\u0026#39; // OS-specific path separator  PathListSeparator = \u0026#39;;\u0026#39; // OS-specific path list separator ) . . . 虽然PathSeparator的值在这里是\\\\，但代码将呈现 Windows 文件路径所需的单一反斜杠（\\），因为第一个反斜杠只需要作为转义字符。\n请注意，与 Unix 文件不同，它的顶部没有构建标签。这是因为GOOS和GOARCH可以通过在文件后缀加上分隔符和环境变量的值来作为参数传递给go build，这个我们将会在使用 GOOS 和 GOARCH 文件后缀名做更多的研究。这里，path_windows.go的_windows部分使文件的行为就像它在文件的顶部有 build 标签//+build windows。因为这个，但你程序在 windows 上运行时，它将使用path_windows.go代码片段中的PathSeparator和PathListSeparator常量。\nTo return to the command line, quit less by pressing q.\n要返回到命令行，按q键退出less。\n在这一步，你建立了一个程序，展示了 Go 如何将GOOS和GOARCH自动转换为构建标签。考虑到这一点，你现在可以更新你的程序，编写你自己的filepath.Join()的实现，使用构建标签为 Windows 和 Unix 平台手动设置正确的PathSeparator。\n实现一个平台特定函数 #  现在你已经知道 Go 的标准库是如何实现特定平台的代码的，你可以使用构建标签在你自己的应用程序中做到这一点。要做到这一点，你将编写你自己的filepath.Join()的实现。\n打开你的main.go文件：\nnano main.go 用你自己的函数Join()替换main.go的内容，如下：\npackage main  import (  \u0026#34;fmt\u0026#34;  \u0026#34;strings\u0026#34; )  func Join(parts ...string) string {  return strings.Join(parts, PathSeparator) }  func main() {  s := Join(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)  fmt.Println(s) } Join 函数接收若干parts，并使用strings 包中的strings.Join()方法将它们连接起来，使用PathSeparator将各部分连接起来。\n你还没有定义PathSeparator，所以现在在另一个文件中做。保存并退出main.go，打开你喜欢的编辑器，创建一个名为path.go的新文件。\nnano path.go 定义PathSeparator，并将其设置为 Unix 文件路径分隔符，/。\npackage main  const PathSeparator = \u0026#34;/\u0026#34; 编译并运行该应用程序：\ngo build ./app 你将会收到如下输出：\nOutput a/b/c 这样运行成功，得到一个 Unix 风格的文件路径。但这还不是我们想要的：无论在什么平台上运行，输出总是 a/b/c。为了添加创建 Windows 风格文件路径的功能，你需要添加一个 Windows 版本的PathSeparator，并告诉go build命令使用哪个版本。在下一节中，你将使用构建标签来完成这个任务。\n使用GOOS或GOARCH构建标签 #  为了考虑到 Windows 平台，你现在将创建一个替代文件到path.go，并使用构建标签来确保代码片段只在GOOS和GOARCH是合适的平台时运行。\n但首先，在path.go中添加一个构建标签，告诉它除 Windows 之外的所有东西都可以进行构建。打开该文件：\nnano path.go 加入如下高亮构建标签到文件：\n// +build !windows  package main  const PathSeparator = \u0026#34;/\u0026#34; Go 构建标签允许反转，也就是说，你可以指示 Go 为除 Windows 之外的任何平台构建此文件。 要反转一个构建标签，请在标签前加上一个!。\n保存并退出文件。\n现在，如果你要在 Windows 上运行这个程序，你会得到以下错误：\nOutput ./main.go:9:29: undefined: PathSeparator 在这种情况下，Go 将无法通过引入path.go来定义变量PathSeparator。\n现在你已经确保当GOOS是 Windows 时，path.go不会运行，添加一个新的文件，windows.go：\nnano windows.go 在windows.go中，定义 Windows 的PathSeparator，以及一个构建标签让go build命令知道它是 Windows 的实现：\n// +build windows  package main  const PathSeparator = \u0026#34;\\\\\u0026#34; 保存文件并从文本编辑器中退出。该应用程序现在可以以一种方式为 Windows 编译，另一种方式为所有其他平台编译。\n虽然现在二进制文件可以在其他平台正确编译，但你必须做进一步的修改，以便为你无法访问的平台进行编译。要做到这一点，你将在下一步改变你的本地GOOS和GOARCH环境变量。\n使用你本地GOOS和GOARCH环境变量 #  在前面，你通过执行go env GOOS GOACH指令来找到你正在工作的平台是哪个操作系统和架构。当你执行go env指令时，它会去找 2 个环境变量GOOS和GOARCH；如果找到，他们就会使用环境变量，如果找不到，Go 就会用当前平台的信息来设置它们。这意味着你可以改变GOOS或GOARCH，所以它们不是根据你的操作系统和架构默认设置的。\ngo build命令的行为方式与go env命令类似。你可以设置GOOS或GOARCH的环境变量，用go build为不同的平台进行编译。\n如果你没有使用Windows系统，可以在运行go build命令时将GOOS环境变量设置为windows，从而构建应用程序windows 下的二进制版本：\nGOOS=windows go build 现在列出你当前目录中的文件：\nls 列出目录文件的输出项显示在项目目录中现在有一个app.exe的 Windows 可执行文件：\nOutput app app.exe main.go path.go windows.go 使用file命令，你可以得到关于这个文件的更多信息，确认它的构建构建信息：\nfile app.exe 你将会看到如下信息：\nOutput app.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows 你也可以在构建时设置一个，或两个环境变量。运行如下命令：\nGOOS=linux GOARCH=ppc64 go build 你的应用程序的可执行文件现在将被一个不同架构的文件所取代。在这个二进制文件上运行file命令：\nfile app 你将会收到类似如下的信息：\napp: ELF 64-bit MSB executable, 64-bit PowerPC or cisco 7500, version 1 (SYSV), statically linked, not stripped 通过设置本地的 GOOS 和 GOARCH 环境变量，你将可以为任何兼容 Go 的平台构建二进制文件，而无需复杂的配置或设置。接下来，你将使用文件名的约定来保持你的文件整齐，并自动为特定平台构建，而不需要构建标签。\n使用GOOS和GOARCH文件名后缀 #  正如你之前看到的，Go 标准库大量使用构建标签，通过将不同的平台实现分离到不同的文件中来简化代码。当你打开os/path_unix.go文件时，有一个构建标签，列出了所有被认为是类 Unix 平台的可能组合。然而，os/path_windows.go文件不包含任何构建标签，因为文件名的后缀就足以告诉 Go 该文件是为哪个平台准备的。\n让我们来看看这个功能的语法。命名.go文件时，可以在文件名中按顺序添加GOOS和GOARCH作为后缀，用下划线(_)来分开这两个值。如果你有一个名为filename.go的 Go 文件，你可以通过将文件名改为 filename_GOOS_GOARCH.go来指定操作系统和架构。举个例子，如果你希望将其编译为 64 位ARM 架构的 Windows，你会将文件名定为filename_windows_arm64.go。这种命名方式有助于保持代码的整齐性。\n使用文件名后缀而非构建标签来更新你的程序。首先，重新命名path.go和windows.go文件，使用os包中使用的惯例：\nmv path.go path_unix.go mv windows.go path_windows.go 改变了这两个文件名后，你可以删除你添加到path_windows.go的构建标签：\nnano path_windows.go 移除// +build windows，所以你的文件会看起来像这样：\npackage main  const PathSeparator = \u0026#34;\\\\\u0026#34; 保存并退出文件。\n因为unix不是一个有效的GOOS，_unix.go后缀对 Go 编译器没有任何意义。然而，它确实传达了文件的预期目的。 和os/path_unix.go文件一样，你的path_unix.go文件仍然需要使用构建标签，所以保持该文件不变。\n通过使用文件名惯例，你从你的源代码中删除了不需要的构建标签，并使文件系统更干净、更清晰。\n总结 #  为多个平台生成不需要依赖的二进制文件的能力是 Go 工具链的一个强大功能。在本教程中，你通过添加构建标签和文件名后缀来使用这种能力，以标记某些代码片段，使其只针对某些架构进行编译。你创建了你自己的平台依赖的程序，然后操纵GOOS和GOARCH环境变量，为你当前平台以外的平台生成二进制文件。这是一项有价值的技能，因为有一个持续集成过程，自动运行这些环境变量，为所有平台构建二进制文件，这是一个常见的做法。\n"},{"id":38,"href":"/docs/39-Using_ldflags_to_Set_Version_Information_for_Go_Applications/","title":"39 Using Ldflags to Set Version Information for Go Applications","section":"Docs","content":"用 ldflags 设置 Go 应用程序的版本信息 #  简介 #  当把应用程序部署到生产环境中时，用版本信息和其他元数据构建二进制文件将改善你的监控、日志和调试过程，增加识别信息来帮助跟踪随着时间推移后，应用程序的构建信息。这种版本信息通常包括高度动态的数据，如构建时间、构建二进制文件的机器或用户、版本控制系统（VCS）的提交 ID，等其他更多信息。因为这些值是不断变化的，将这些数据直接编码到源代码中，并在每次新的构建之前进行修改，是很繁琐的，而且容易出错：源文件可能会移动，变量/常量在整个开发过程中可能会随着切换文件而改动，打断构建过程。\n在 Go 中解决这个问题的一个方法是在使用go build命令时加上-ldflags，在构建时将动态信息插入二进制文件中，而不需要修改源代码。在这个标志中，ld代表linker，这个程序将编译后的源代码的不同部分连接成最终的二进制文件。ldflags就代表linker 的标志。之所以这样说，是因为它向底层的 Go 工具链 linkercmd/link传递了一个标志，允许你在构建时从命令行中改变导入的包的值。\n在本教程中，你将使用-ldflags在构建时改变变量的值，并将你自己的动态信息加入二进制，用一个将版本信息打印到屏幕上的应用程序作为示例应用程序。\n前期准备 #  为了接下去在文章中的例子，你需要：\n 按照如何安装 Go 和设置本地编程环境设置 Go 的 workspace。  构建你的范例应用程序 #  在使用ldflags加入动态数据之前，你首先需要一个应用程序来插入信息。在这一步，你将制作这个应用程序，在这个阶段，它将只打印静态的版本信息。现在让我们来创建这个应用程序。\n在你的src目录下，建立一个以你的应用程序命名的目录。本教程将使用叫app的应用程序：\nmkdir app 跳转你的目录到这个文件夹：\ncd app 然后，使用你喜欢的文本编辑器，在main.go创建你的程序的 entry point：\nnano main.go 现在，通过加入如下内容到你的程序内，来打印出版本信息：\npackage main  import ( \t\u0026#34;fmt\u0026#34; )  var Version = \u0026#34;development\u0026#34;  func main() { \tfmt.Println(\u0026#34;Version:\\t\u0026#34;, Version) } 在main()函数内，你宣告了Version变量，然后打印string类型的Version：紧跟着 tab 的字符，\\t，然后是声明的变量。\n现在，参数Version被定义为development，将作为 app 的默认版本。稍后，你将会修改这个值来符合官方版本编号，根据semantic versioning format来定义。\n保存并退出该文件。完成后，构建并运行该应用程序，来确认它打印的是正确的版本：\ngo build ./app 你将会看到如下输出：\nOutput Version:\tdevelopment 你现在有一个打印默认版本信息的应用程序，但你还没有办法在构建时传入当前版本信息。在下一步，你将使用-ldflags和go build来解决这个问题。\n在 go build中使用ldflags的方法 #  在前面提到的，ldflags代表linker 标志，用于向 Go 工具链中的底层 linker 传递标志。这是按以下语法进行的：\ngo build -ldflags=\u0026#34;-flag\u0026#34; 在这个例子中，我们向作为go build的一部分运行的go tool link命令传递了flag。这个命令在传递给ldflags的内容周围使用双引号，以避免其中字符串被分开，或者被命令行翻译为与我们想要的不同的字符。从这里，你可以传入许多不同的linker标志。为了本教程中的目的，我们将使用-X标志在链接时将信息写入变量，跟着的是参数的package路径和它的新值：\ngo build -ldflags=\u0026#34;-X \u0026#39;package_path.variable_name=new_value\u0026#39;\u0026#34; 在引号内，现在有X选项和一个键值对，代表要改变的变量和它的新值。.字符将包路径和变量名称分开，单引号用于避免键值对被断开。\n要在你的示例程序中替换Version变量，使用最后一个命令块中的语法，传入一个新的值并建立新的二进制。\ngo build -ldflags=\u0026#34;-X \u0026#39;main.Version=v1.0.0\u0026#39;\u0026#34; 在这个命令中，main是Version变量的包路径，因为这个变量在main.go文件中。Version是你要写入的变量，v1.0.0是新的值。\n为了使用ldflags，你想改变的值必须存在，并且是一个string类型的包级变量。这个变量可以是对外导出的也可以不是。变量的值不可以是const或者是需要通过调用函数后得到的结果赋值的。幸运的是，Version满足了所有的要求：它已经在main.go文件中被声明为一个变量，而且当前值(development)和期望值(v1.0.0)都是字符串。\n一旦你的新app二进制文件构建起来，运行应用程序：\n./app 你将会收到如下输出：\nOutput Version:\tv1.0.0 通过-ldflags，你成功地把Version变量的值从development改成v1.0.0。\n现在你已经在一个简单的应用程序构建时修改了一个string变量。使用ldflags，你可以在二进制文件中嵌入版本细节、许可信息等，只需使用命令行就可以发布。\n在这个例子中，你改变的变量在main程序中，减少了确定路径名称的难度。但有时这些变量的路径寻找起来比较复杂。在下一步中，你将给子包中的变量赋值，来阐述确定更复杂的包路径的最佳方法。\n锁定子包变量 #  在上一节中，你操作了Version变量，它位于应用程序的顶层包。但这不是常见的案例。通常情况下，将这些变量放在另一个包中更为实际，因为main不是一个可导入的包。为了在你的示例程序中模拟这一点，你将创建一个新的子包，app/build，它将存储关于二进制文件被构建的时间和发出构建命令的用户名称的信息。\n要添加一个新的子包，首先在你的项目中添加一个名为`build\u0026rsquo;的新目录：\nmkdir -p build 然后创建一个名为build.go的新文件来保存新的变量：\nnano build/build.go 在你的文本编辑器中，添加Time和User这两个新变量\npackage build  var Time string  var User string Time变量将保存二进制文件建立的时间的字符串表示。User变量将保存构建二进制文件的用户名称。由于这两个变量总是有值，你不需要像对Version那样用默认值初始化这些变量。\n保存并退出文件。\n然后，打开main.go文件添加这些变量到你的应用程序中：\nnano main.go 在main.go中，添加如下高亮代码：\npackage main  import ( \t\u0026#34;app/build\u0026#34; \t\u0026#34;fmt\u0026#34; )  var Version = \u0026#34;development\u0026#34;  func main() { \tfmt.Println(\u0026#34;Version:\\t\u0026#34;, Version) \tfmt.Println(\u0026#34;build.Time:\\t\u0026#34;, build.Time) \tfmt.Println(\u0026#34;build.User:\\t\u0026#34;, build.User) } 在这些代码里，你第一次引用app/build包，然后用打印Version的方式打印build.Time和build.User。\n保存文件，然后从你的文本编辑器退出。\n接下来，为了用ldflags锁定这些变量，你可以使用导入路径app/build，然后是.User或.Time，因为你已经知道导入的路径。 然而，为了模拟一种更复杂的情况，即不知道变量的导入路径，让我们改用 Go 工具链中的nm命令。\ngo tool nm命令将输出在给定的可执行文件、对象文件或存档中涉及的符号。在这种情况下，符号指的是代码中的一个对象，例如一个定义的或导入的变量或函数。通过使用nm生成一个符号表，并使用grep搜索一个变量，你可以快速找到其路径信息。\n注意：如果软件包名称中有任何非ASCII字符，或者有\u0026quot;或%字符，nm命令将不能帮助你找到变量的路径，因为这是工具本身的限制。\n要使用这个命令，首先要为app构建二进制文件：\ngo build 现在app已经构建好了，将nm工具指向它，并在输出中搜索：\ngo tool nm ./app | grep app 当运行时，nm工具将输出大量的数据。因为如此，前面的命令使用|将输出的数据输送给grep命令，然后搜索标题中带有一级app的数据。\n你将会收到类似如下的输出：\nOutput  55d2c0 D app/build.Time  55d2d0 D app/build.User  4069a0 T runtime.appendIntStr  462580 T strconv.appendEscapedRune . . . 在这种情况下，结果集的前两行包含你要找的两个变量的路径。app/build.Time和app/build.User。\n现在你知道了路径，再次构建应用程序，这次在构建时改变版本、用户和时间。要做到这一点，需要向-ldflags传递多个-X标志：\ngo build -v -ldflags=\u0026#34;-X \u0026#39;main.Version=v1.0.0\u0026#39; -X \u0026#39;app/build.User=$(id -u -n)\u0026#39; -X \u0026#39;app/build.Time=$(date)\u0026#39;\u0026#34; 这里你传入了id -u -n Bash 命令来列出当前用户，以及date命令来列出当前日期。\n构建好了可执行文件，运行该程序：\n./app 该命令在 Unix 系统上运行时，将产生与下面类似的输出：\nOutput Version:\tv1.0.0 build.Time:\tFri Oct 4 19:49:19 UTC 2019 build.User:\tsammy 现在你有一个包含版本和构建信息的二进制文件，在生产中解决问题时可以提供重要帮助。\n总结 #  这个教程展示了，如果应用得当，ldflags可以成为一个强大的工具，在构建时向二进制文件注入有价值的信息。这样，你可以控制功能标志、环境信息、版本信息等等，而不需要对你的源代码进行修改。通过添加ldflags到你当前的构建工作流程中，你可以最大限度地发挥 Go 自成一体的二进制的发布格式的优势。\n"},{"id":39,"href":"/docs/40-How_To_Use_the_Flag_Package_in_Go/","title":"40 How to Use the Flag Package in Go","section":"Docs","content":"在 Go 里面如何使用 Flag 包 #  简介 #  命令行工具很少在没有额外配置的情况下开箱即用。好的默认值固然很重要，但有用的工具需要接受用户的配置。在大多数平台上，命令行工具通过接收标志来指定命令的执行。标志是以键值分隔的字符串，加在命令的名称后面。Go 让你通过使用标准库中的 flag 包来制作接受标志的命令行工具。\n在本教程中，你将探索使用 flag 包来建立不同种类的命令行工具的各种方法。你将使用一个标志来控制程序输出，引入位置参数，在这里你将混合标志和其他数据，然后实现子命令。\n用 Flag 来改变程序的行为 #  使用 flag 包包括三个步骤：首先，定义变量以捕获标志值，然后定义你的 Go 应用程序将使用的标志，最后解析执行时提供给应用程序的标志。flag包内的大多数函数都与定义标志和将它们与你定义的变量绑定有关。解析阶段由Parse()函数处理。\n为了阐述这一点，你将创建一个程序，定义一个 Boolean标志，改变这个标志将会把信息打印到标准输出上。如果提供一个-color标志，程序会用蓝色来打印消息。如果没有这个标志，则打印消息不会有颜色。\n创建一个叫boolean.go的文件：\nnano boolean.go 添加如下代码到文件里面来创建程序：\npackage main  import ( \t\u0026#34;flag\u0026#34; \t\u0026#34;fmt\u0026#34; )  type Color string  const ( \tColorBlack Color = \u0026#34;\\u001b[30m\u0026#34; \tColorRed = \u0026#34;\\u001b[31m\u0026#34; \tColorGreen = \u0026#34;\\u001b[32m\u0026#34; \tColorYellow = \u0026#34;\\u001b[33m\u0026#34; \tColorBlue = \u0026#34;\\u001b[34m\u0026#34; \tColorReset = \u0026#34;\\u001b[0m\u0026#34; )  func colorize(color Color, message string) { \tfmt.Println(string(color), message, string(ColorReset)) }  func main() { \tuseColor := flag.Bool(\u0026#34;color\u0026#34;, false, \u0026#34;display colorized output\u0026#34;) \tflag.Parse()  \tif *useColor { \tcolorize(ColorBlue, \u0026#34;Hello, DigitalOcean!\u0026#34;) \treturn \t} \tfmt.Println(\u0026#34;Hello, DigitalOcean!\u0026#34;) } 这个例子使用ANSI 逃逸序列来指示终端显示彩色输出。这些是专门的 character 序列，所以为它们定义一个新的类型是有意义的(L8)。在这个例子中，我们称该类型为color，并将该类型定义为string。然后我们定义了一个调色板，在后面的 const 块中使用。定义在const块之后的colorize函数接受Color常量其中之一和一个string，用于对信息进行着色。然后它指示终端改变颜色，首先打印所要求的颜色的转义序列，然后打印信息，最后要求终端通过打印特殊的颜色重置序列来重置其颜色。\n在main中，我们使用flag.Bool函数来定义一个名为color的 Boolean 标志。这个函数的第二个参数，false，在没有提供这个标志的情况下，设置这个标志的默认值。与你可能有的期望相反，将其设置为true并不会颠倒行为，如提供一个标志会导致它变成 false。因此，这个参数的值在布尔标志下几乎总是false。\n最后一个参数是一个可以作为使用信息打印出来的文档 string。从这个函数返回的值是一个指向bool的指针。下一行的flag.Parse函数使用这个指针，然后根据用户传入的标志，设置bool变量。 然后我们就可以通过取消引用这个指针来检查这个bool指针的值。更多关于指针变量的信息可以在指针教程找到。使用这个 Boolean，我们就可以在设置-color标志时调用colorize，而在没有这个标志时调用fmt.Println变量。\n保存文件，并在未传入没有任何标志的情况下运行该程序：\ngo run boolean.go 你将会看到如下输出：\nOutput Hello, DigitalOcean! 现在带上-color标志再跑一遍程序：\ngo run boolean.go -color 输出文本会是一样的，只不过这时候颜色时蓝色的。\n标志不是传递给命令的唯一参数。你也能发送文件名或其他数据。\n使用位置参数 #  通常情况下，命令会接受一些参数，这些参数作为命令的重点对象。例如，打印文件第一行的head命令经常被以head example.txt调用。文件example.txt是调用head命令时的一个位置参数。\nParse()函数将一直解析它所遇到的标志，直到它检测到一个非标志参数。flag包通过Args()和Arg()函数使这些参数可用。\n为了阐述这一点，你将重新实现一个简化的head命令，它显示一个给定文件的前几行：\n创建一个新的文件称为head.go，然后添加如下代码：\npackage main  import ( \t\u0026#34;bufio\u0026#34; \t\u0026#34;flag\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;io\u0026#34; \t\u0026#34;os\u0026#34; )  func main() { \tvar count int \tflag.IntVar(\u0026amp;count, \u0026#34;n\u0026#34;, 5, \u0026#34;number of lines to read from the file\u0026#34;) \tflag.Parse()  \tvar in io.Reader \tif filename := flag.Arg(0); filename != \u0026#34;\u0026#34; { \tf, err := os.Open(filename) \tif err != nil { \tfmt.Println(\u0026#34;error opening file: err:\u0026#34;, err) \tos.Exit(1) \t} \tdefer f.Close()  \tin = f \t} else { \tin = os.Stdin \t}  \tbuf := bufio.NewScanner(in)  \tfor i := 0; i \u0026lt; count; i++ { \tif !buf.Scan() { \tbreak \t} \tfmt.Println(buf.Text()) \t}  \tif err := buf.Err(); err != nil { \tfmt.Fprintln(os.Stderr, \u0026#34;error reading: err:\u0026#34;, err) \t} } 首先，我们定义了一个count变量，用来保存程序应该从文件中读取的行数。然后，我们使用flag.IntVar定义-n标志，模拟原始head程序的行为。 这个函数允许我们将自己的pointer传递给一个变量，与没有Var后缀的标志函数相反。除了这个区别之外，flag.IntVar的其他参数与flag.Int对应的参数相同：标志名称、默认值和描述。 和前面的例子一样，我们随后调用flag.Parse()来处理用户的输入。\n下一节读取文件。我们首先定义一个io.Reader变量，该变量将被设置为用户请求的文件，或传递给程序的标准输入。在if语句中，我们使用flag.Arg函数来访问所有标志之后的第一个位置参数。如果用户提供了文件名，这个位置参数会被设置。否则，它将为空 string(\u0026quot;\u0026quot;)。当文件名提供时，我们使用os.Open函数来打开该文件，并将我们之前定义的io.Reader设置为该文件。否则，我们使用os.stdin来读取标准输入。\n最后一节使用一个用bufio.NewScanner创建的*bufio.Scanner从io.Reader变量in中读取行数据。我们使用forloop遍历到 count 的值，如果用buf.Scan扫描该行结果为false，则调用break，表示行数少于用户要求的数量。\n运行这个程序，用head.go作为文件参数，显示你刚才写的文件的内容：\ngo run head.go -- head.go --分隔符是一个被flag包识别的特殊标志，它表示后面没有更多的 flag 参数。当你运行这个命令时，你会收到以下输出：\nOutput package main  import (  \u0026#34;bufio\u0026#34;  \u0026#34;flag\u0026#34; 使用你定义的-n标志来调整输出的数量：\ngo run head.go -n 1 head.go 这只输出包的声明：\nOutput package main 最后，当程序检测到没有提供位置参数时，它从标准输入中读取输入，就像head一样。试着运行这个命令：\necho \u0026#34;fish\\nlobsters\\nsharks\\nminnows\u0026#34; | go run head.go -n 3 你将会看到如下输出：\nOutput fish lobsters sharks 到目前为止，你所看到的flag函数的行为仅限于检查整个命令的调用。你并不总是想要这种行为，特别是当你在编写一个支持子命令的命令行工具时。\n用 FlagSet 来实现子命令 #  现代的命令行应用程序经常实现 \u0026ldquo;子命令\u0026rdquo;，将一套工具捆绑在一个命令之下。使用这种模式的最著名的工具是git。 当检查像git init这样的命令时，git是命令，init是 git 的子命令。子命令的一个显著特点是，每个子命令可以有自己的标志集合。\nGo 应用程序可以使用flag.(*FlagSet)类型支持具有自己的标志集的子命令。为了阐述这一点，创建一个程序，使用两个具有不同标志的子命令来实现一个命令。\n创建一个名为subcommand.go的新文件，并在该文件中添加以下内容：\npackage main  import ( \t\u0026#34;errors\u0026#34; \t\u0026#34;flag\u0026#34; \t\u0026#34;fmt\u0026#34; \t\u0026#34;os\u0026#34; )  func NewGreetCommand() *GreetCommand { \tgc := \u0026amp;GreetCommand{ \tfs: flag.NewFlagSet(\u0026#34;greet\u0026#34;, flag.ContinueOnError), \t}  \tgc.fs.StringVar(\u0026amp;gc.name, \u0026#34;name\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;name of the person to be greeted\u0026#34;)  \treturn gc }  type GreetCommand struct { \tfs *flag.FlagSet  \tname string }  func (g *GreetCommand) Name() string { \treturn g.fs.Name() }  func (g *GreetCommand) Init(args []string) error { \treturn g.fs.Parse(args) }  func (g *GreetCommand) Run() error { \tfmt.Println(\u0026#34;Hello\u0026#34;, g.name, \u0026#34;!\u0026#34;) \treturn nil }  type Runner interface { \tInit([]string) error \tRun() error \tName() string }  func root(args []string) error { \tif len(args) \u0026lt; 1 { \treturn errors.New(\u0026#34;You must pass a sub-command\u0026#34;) \t}  \tcmds := []Runner{ \tNewGreetCommand(), \t}  \tsubcommand := os.Args[1]  \tfor _, cmd := range cmds { \tif cmd.Name() == subcommand { \tcmd.Init(os.Args[2:]) \treturn cmd.Run() \t} \t}  \treturn fmt.Errorf(\u0026#34;Unknown subcommand: %s\u0026#34;, subcommand) }  func main() { \tif err := root(os.Args[1:]); err != nil { \tfmt.Println(err) \tos.Exit(1) \t} } 这个程序分为几个部分：main函数，root函数，以及实现子命令的各个函数。main函数处理从命令返回的错误。如果任何函数返回错误，if语句将捕捉到它，打印出错误，程序将以1的状态码退出，向操作系统的其他部分表明发生了错误。在main中，我们将程序被调用的所有参数传递给root。我们通过先将os.Args切片来删除第一个参数，也就是程序的名称（在前面的例子中是./subcommand）。\nroot函数定义了[]Runner，所有的子命令都会在这里定义。Runner是一个子命令的 interface ，允许root使用Name()获取子命令的名称，并将其与变量subcommand内容进行比较。一旦在遍历cmds变量后找到了正确的子命令，我们就用其余的参数初始化子命令，并调用该命令的Run()方法。\n我们只定义了一个子命令，尽管这个框架很容易让我们创建其他子命令。GreetCommand是使用NewGreetCommand实例化的，在这里我们使用flag.NewFlagSet创建一个新的*flag.FlagSet。flag.NewFlagSet需要两个参数：一个标志集的名称，和一个报告解析错误的策略。用flag.(*FlagSet).Name方法获取*flag.FlagSet的名称。我们在(*GreetCommand).Name()方法中使用这个方法，所以子命令的名字与我们给*flag.FlagSet的名字一致。 NewGreetCommand也用了类似于以前的例子的方式定义了一个-name标志，但它改为从*GreetCommand的*flag.FlagSet字段中调用这个方法，gc.fs。当root调用*GreetCommand的Init()方法时，我们将传入的参数传递给*flag.FlagSet字段的Parse方法。\n如果你构建这个程序，然后运行它，就会更容易看到子命令。建立该程序：\ngo build subcommand.go 现在运行该程序，没有参数：\n./subcommand 你会看到如下输出：\nOutput You must pass a sub-command 现在用greet子命令运行该程序。\n./subcommand greet 这会输出如下内容：\nOutput Hello World ! 现在使用-name标志和greet来指定一个名字：\n./subcommand greet -name Sammy 你会看到程序给出的这个输出：\nOutput Hello Sammy ! 这个例子说明了在 Go 中如何构建大型命令行应用程序的一些原则。 FlagSets的设计是为了给开发者提供更多的控制权，使其能够通过 flag 解析逻辑，分析flag的位置和处理方式。\n总结 #  标记使你的应用程序在更多情景下更有用，因为它们让你的用户控制程序的执行方式。给用户提供有用的默认值很重要，但你应该让他们有机会覆盖那些不适合他们情况的设置。你已经看到，flag包提供了灵活的选择，向你的用户展示配置选项。你可以选择一些简单的标志，或者建立一套可扩展的子命令。 无论是哪种情况，在过去长久历史沉淀的风格下，使用flag包都可以帮助你按照灵活的、可编写脚本的命令行工具。\n"}]